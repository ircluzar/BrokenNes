@page "/continue"
@using NesEmulator
@using NesEmulator.Shaders
@using System.Text.Json
@using BrokenNes.Shared
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@inject IJSRuntime JS
@inject NavigationManager Nav
@inject BrokenNes.Services.GameSaveService SaveSvc
@inject IShaderProvider ShaderProvider

<div class="options-root continue-root">
  <h2 class="opt-title">DECK BUILDER</h2>

  <section class="cont-header">
    <div class="hdr-main">
      <div class="lvl-title">
        <span class="chip">@CurrentLevel</span>
        <strong>@LevelTitle</strong>
      </div>
      <div class="lvl-status">
        <span class="status-chip @(LevelCleared?"cleared":"not-cleared")" title="@(LevelCleared?"Any 1 achievement completed":"No achievements completed yet")">
          @(LevelCleared?"Cleared":"Not Cleared")
        </span>
      </div>
    </div>
    <div class="hdr-cards">
      <span class="small-note">Enforced:</span>
      @foreach (var c in EnforcedCards)
      {
        <button type="button" class="enf-chip" style="border-color:@c.border" title="View card" @onclick="(()=>OpenCardZoom(c.domain, c.id))">@c.label</button>
      }
    </div>
    <div class="hdr-cta">
      <button class="btn-next" disabled="@(!CanAdvanceLevel)" title="Requires @RequiredStars stars" @onclick="AdvanceLevel">Go to next level (@RequiredStars ⭐)</button>
    </div>
  </section>

  <section class="opt-section">
    <h3 class="opt-h3">Build Console</h3>
    <div class="core-grid">
      @CoreSlot("CPU", EnforcedCpu, SelectedCpu, OpenCpuPicker)
      @CoreSlot("PPU", EnforcedPpu, SelectedPpu, OpenPpuPicker)
      @CoreSlot("APU", EnforcedApu, SelectedApu, OpenApuPicker)
  @CoreSlot("SHADER", EnforcedShader, SelectedShader, OpenShaderPicker)
    </div>
  </section>

  <section class="opt-section">
    <h3 class="opt-h3">Cartridge</h3>
    <div class="rom-selector">
      <div class="rom-toolbar">
        <label class="small-note"><input type="checkbox" @bind="FilterCompatibleOnly" /> Only show compatible</label>
        <div class="rom-toolbar-right">
          <button type="button" class="rom-import-btn" @onclick="OpenImport">Import</button>
          <input class="rom-search" placeholder="Search title…" @bind="RomSearch" />
        </div>
      </div>
      @if (RomRowsFiltered.Count == 0)
      {
        <div class="rom-empty small-note">No games found. Import the default DB in CRUD or add your own.</div>
      }
      else
      {
        <div class="rom-table" role="table" aria-label="ROM list">
          <div class="rom-thead" role="rowgroup">
            <div class="rom-tr rom-th" role="row">
              <div class="c-title" role="columnheader">Title</div>
              <div class="c-compat" role="columnheader">Compat</div>
              <div class="c-ach" role="columnheader">Stars</div>
            </div>
          </div>
          <div class="rom-tbody" role="rowgroup">
            @foreach (var g in RomRowsFiltered)
            {
              var disabled = !g.Compatible;
              <button type="button"
                      class="rom-tr rom-td @(SelectedGameId==g.Id?"selected":null) @(disabled?"disabled":null)"
                      role="row"
                      aria-disabled="@disabled"
                      title="@(disabled?"No achievements available":"Select game")"
                      disabled="@disabled"
                      @onclick="(()=>SelectGame(g.Id))">
                <div class="c-title" role="cell">
                  <div class="rom-title">@g.Title</div>
                  @if (!string.IsNullOrWhiteSpace(g.Subtitle)) { <div class="rom-sub">@g.Subtitle</div>; }
                </div>
                <div class="c-compat" role="cell"><span class="chip @(g.Compatible?"ok":"no")">@(g.Compatible?"Yes":"No")</span></div>
                <div class="c-ach" role="cell">@g.Completed/@g.Total</div>
              </button>
            }
          </div>
        </div>
      }
    </div>
  </section>

  <section class="opt-section">
    <h3 class="opt-h3">Achievements</h3>
    @if (SelectedGame != null)
    {
      <div class="ach-box">
        <div class="ach-summary">
          <span class="small-note">@SelectedGame.Title</span>
          <strong>@SelectedGame.Completed/@SelectedGame.Total</strong>
          <span class="small-note">completed</span>
        </div>
        <div class="small-note">Full achievement list coming soon.</div>
      </div>
    }
    else
    {
      <div class="ach-box small-note">Select a compatible game to view achievements.</div>
    }
  </section>

  <div class="opt-footer">
    <button class="opt-link start-btn" disabled="@(!CanStartGame)" title="Build valid and game with achievements required">Start the game</button>
    <a href="./deck-builder?skipHW=1" class="opt-link" @onclick="OnReturn" @onclick:preventDefault>RETURN</a>
  </div>
</div>

@if (ImportOpen)
{
  <div class="import-modal-backdrop" @onclick="CloseImport" @onclick:stopPropagation>
    <div class="import-modal" @onclick="StopClick" @onclick:stopPropagation>
      <h3 class="import-title">Import ROMs</h3>
      <div class="import-body">
        <div class="import-controls">
          <button type="button" class="rom-import-btn" @onclick="TriggerBrowse">Browse…</button>
          <input id="continue-import-input" type="file" accept=".nes" multiple style="display:none" @ref="ImportInputRef" @onchange="OnBrowseChanged" />
        </div>
        <div id="import-drop-area" class="import-drop">Drag and drop .nes files here</div>
        @if (PendingImports.Count == 0)
        {
          <div class="small-note">No files added yet.</div>
        }
        else
        {
          <ul class="import-list">
            @foreach (var f in PendingImports)
            {
              <li title="@f.Name">@f.Name <span class="small-note">(@f.SizeLabel)</span></li>
            }
          </ul>
        }
      </div>
      <div class="import-footer">
        <button type="button" class="rom-import-btn" disabled="@(PendingImports.Count==0)" @onclick="DoImportGamesAsync">Import games</button>
        <button type="button" class="rom-cancel-btn" @onclick="CloseImport">Cancel</button>
      </div>
    </div>
  </div>
}

@if (ZoomCard != null)
{
  <div class="card-modal-backdrop @(ModalClosing?"closing":"opening")" @onclick="CloseZoom">
    <div class="card-modal-content @(ModalClosing?"closing":"opening")" @onclick="CloseZoom">
      @((MarkupString)CardSvgRenderer.Render(ZoomCard))
    </div>
  </div>
}

@code {
  // State
  private int CurrentLevel = 1;
  private int Stars = 0;
  private string LevelTitle = " ";
  private int RequiredStars = 5;

  private (string domain, string id, string label, string border)[] EnforcedCards = Array.Empty<(string,string,string,string)>();

  // Enforced slots (null = not enforced)
  private string? EnforcedCpu = null;
  private string? EnforcedPpu = null;
  private string? EnforcedApu = null;
  private string? EnforcedShader = null;

  // Player-selected (temporary choices for this level/session)
  private string? SelectedCpu = null;
  private string? SelectedPpu = null;
  private string? SelectedApu = null;
  private string? SelectedShader = null;

  private CoreCardModel? ZoomCard;
  private bool ModalClosing = false;
  private bool _zoomInit = false;

  // Owned choices
  private IReadOnlyList<string> OwnedCpu = Array.Empty<string>();
  private IReadOnlyList<string> OwnedPpu = Array.Empty<string>();
  private IReadOnlyList<string> OwnedApu = Array.Empty<string>();
  private IReadOnlyList<string> OwnedShader = Array.Empty<string>();

  // ROM selector state
  private sealed class DbGame { public string id { get; set; } = string.Empty; public string? commonName { get; set; } public string? title { get; set; } public string? name { get; set; } public string? romKey { get; set; } public string? system { get; set; } public string? platform { get; set; } public string? notes { get; set; } public string? subtitle { get; set; } }
  private sealed class DbAchievement { public string id { get; set; } = string.Empty; public string gameId { get; set; } = string.Empty; public string? title { get; set; } }
  private sealed class RomRow { public string Id { get; set; } = string.Empty; public string Title { get; set; } = string.Empty; public string? Subtitle { get; set; } public string System { get; set; } = "NES"; public int Total { get; set; } public int Completed { get; set; } public bool Compatible => Total > 0; public string? Notes { get; set; } }
  private List<RomRow> RomRows = new();
  private List<RomRow> RomRowsFiltered => RomRows
    .Where(r => !FilterCompatibleOnly || r.Compatible)
    .Where(r => string.IsNullOrWhiteSpace(RomSearch) || (r.Title?.Contains(RomSearch, StringComparison.OrdinalIgnoreCase) ?? false))
    .OrderByDescending(r => r.Compatible)
    .ThenBy(r => r.Title, StringComparer.OrdinalIgnoreCase)
    .ToList();
  private string? SelectedGameId = null;
  private RomRow? SelectedGame => RomRows.FirstOrDefault(r => r.Id == SelectedGameId);
  private bool FilterCompatibleOnly = true;
  private string RomSearch = string.Empty;
  private HashSet<string> UnlockedAchievementIds = new(StringComparer.OrdinalIgnoreCase);
  // Import modal state
  private bool ImportOpen = false;
  private ElementReference ImportInputRef;
  private IDisposable? _importRef; // holds DotNetObjectReference to prevent GC
  private bool _importDropInit = false;
  private readonly List<ImportItem> PendingImports = new();

  protected override async Task OnInitializedAsync()
  {
    try { await JS.InvokeVoidAsync("nesInterop.ensureAudioContext"); } catch { }
    try { await JS.InvokeVoidAsync("nesInterop.applySavedAudioVolumes"); } catch { }
    try { await JS.InvokeVoidAsync("eval", "window.homePixelBgEnsure && window.homePixelBgEnsure();"); } catch { }

  // Load save, then fetch level data from continueDb and derive enforced chips and cost
  var save = await SaveSvc.LoadAsync();
  CurrentLevel = Math.Max(1, save.Level);
  Stars = save.Achievements?.Count ?? 0;
  UnlockedAchievementIds = new(save.Achievements ?? new());
  await LoadLevelFromDbAsync(CurrentLevel);

  // Owned sets (used by pickers)
  OwnedCpu = (save.OwnedCpuIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();
  OwnedPpu = (save.OwnedPpuIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();
  OwnedApu = (save.OwnedApuIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();
  OwnedShader = (save.OwnedShaderIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();

  await LoadRomsFromDbAsync();
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      // Crossfade into DeckBuilder music for continuity
      try { await JS.InvokeVoidAsync("nesInterop.fadeOutAndStopTitleMusic"); } catch { }
      try { await JS.InvokeVoidAsync("eval", @"(function(){try{var want='music/DeckBuilder.mp3';if(!window.music)return;var cur=(typeof window.music.currentSrc==='function'?(window.music.currentSrc()||''):''),isP=(typeof window.music.isPlaying==='function'&&!!window.music.isPlaying());if(cur.indexOf('DeckBuilder.mp3')!==-1&&isP)return;if(isP&&typeof window.music.fadeOut==='function'){try{window.music.fadeOut(700,true);}catch(e){} setTimeout(function(){try{window.music.play(want,{loop:true,fadeInMs:900});}catch(e){}},150);} else {try{window.music.play(want,{loop:true,fadeInMs:700});}catch(e){}}}catch(e){}})();"); } catch { }
    }

    if (ZoomCard != null && !_zoomInit)
    {
      _zoomInit = true;
      try { await JS.InvokeVoidAsync("eval", @"(function(){window.nesUi=window.nesUi||{};window.nesUi.zoomModalSvg=function(){try{var host=document.querySelector('.card-modal-content');if(!host)return;var svg=host.querySelector('svg');if(!svg)return;svg.removeAttribute('width');svg.removeAttribute('height');svg.style.width='98vw';svg.style.maxWidth='98vw';svg.style.height='auto';svg.style.maxHeight='98vh';svg.style.display='block';}catch(e){}};window.nesUi.zoomModalSvg();})();"); } catch { }
    }

    // When import modal opens, wire drag/drop once
    if (ImportOpen && !_importDropInit)
    {
      _importDropInit = true;
      try
      {
        var self = DotNetObjectReference.Create(this);
        _importRef?.Dispose();
        _importRef = self;
        await JS.InvokeVoidAsync("nesInterop.initRomDragDrop", "import-drop-area", self);
      }
      catch { }
    }
  }

  private bool LevelCleared => Stars > 0; // Placeholder until per-level attribution exists
  private bool CanAdvanceLevel => Stars >= RequiredStars;
  private bool BuildValid => (EnforcedCpu ?? SelectedCpu) != null
    && (EnforcedPpu ?? SelectedPpu) != null
    && (EnforcedApu ?? SelectedApu) != null
    && (EnforcedShader ?? SelectedShader) != null;
  private bool CanStartGame => BuildValid && SelectedGame != null && SelectedGame.Total > 0;

  private async Task AdvanceLevel()
  {
    try
    {
      var save = await SaveSvc.LoadAsync();
      if (Stars < RequiredStars) return;
      save.Level = Math.Max(1, save.Level) + 1;
      // Grant any forced cards for next level here (stub: grant FMC if missing)
      void grant(List<string> list, string id){ if (!list.Contains(id, StringComparer.OrdinalIgnoreCase)) list.Add(id); }
      save.OwnedCpuIds ??= new(); save.OwnedPpuIds ??= new(); save.OwnedApuIds ??= new();
      grant(save.OwnedCpuIds, "FMC"); grant(save.OwnedPpuIds, "FMC"); grant(save.OwnedApuIds, "FMC");
      await SaveSvc.SaveAsync(save);
      // Reset selections for new level
      SelectedCpu = SelectedPpu = SelectedApu = null;
      CurrentLevel = save.Level;
      Stars = save.Achievements?.Count ?? 0;
  await LoadLevelFromDbAsync(CurrentLevel);
  StateHasChanged();
    }
    catch { }
  }

  private void SelectGame(string id)
  {
    SelectedGameId = id;
  }

  // ===== Import modal logic =====
  private void OpenImport()
  {
    ImportOpen = true; _importDropInit = false; StateHasChanged();
  }
  private void CloseImport()
  {
    ImportOpen = false; StateHasChanged();
  }
  private void StopClick(MouseEventArgs _){ /* prevent backdrop close */ }
  private async Task TriggerBrowse()
  {
    try { await JS.InvokeVoidAsync("eval", "document.getElementById('continue-import-input')?.click()"); } catch { }
  }
  private async Task OnBrowseChanged(ChangeEventArgs _)
  {
    await AddFilesFromInputAsync();
  }
  public sealed class UploadedRom { public string name { get; set; } = string.Empty; public string base64 { get; set; } = string.Empty; }
  private sealed class ImportItem { public string Name { get; set; } = string.Empty; public string Base64 { get; set; } = string.Empty; public string SizeLabel { get; set; } = string.Empty; }
  private static string HumanSizeFromBase64(string b64)
  {
    try { var pad = b64.EndsWith("==") ? 2 : (b64.EndsWith("=") ? 1 : 0); var bytes = Math.Max(0, (b64.Length * 3 / 4) - pad); string[] u = {"B","KB","MB","GB"}; double val = bytes; int i=0; while(val>=1024 && i<u.Length-1){ val/=1024; i++; } return $"{val:0.#} {u[i]}"; } catch { return ""; }
  }
  private void AddPendingUnique(IEnumerable<UploadedRom> files)
  {
    var set = new HashSet<string>(PendingImports.Select(p => p.Name), StringComparer.OrdinalIgnoreCase);
    foreach (var f in files)
    {
      if (string.IsNullOrWhiteSpace(f.name) || string.IsNullOrWhiteSpace(f.base64)) continue;
      if (set.Contains(f.name)) continue; // skip duplicate by name
      PendingImports.Add(new ImportItem { Name = f.name, Base64 = f.base64, SizeLabel = HumanSizeFromBase64(f.base64) });
      set.Add(f.name);
    }
  }
  private async Task AddFilesFromInputAsync()
  {
    try
    {
      var arr = await JS.InvokeAsync<UploadedRom[]>("nesInterop.readSelectedRoms", ImportInputRef);
      if (arr != null && arr.Length > 0)
      {
        AddPendingUnique(arr);
        StateHasChanged();
      }
    }
    catch { }
  }
  [JSInvokable]
  public Task OnRomsDropped(UploadedRom[] roms)
  {
    try { if (roms != null && roms.Length > 0) { AddPendingUnique(roms); StateHasChanged(); } } catch { }
    return Task.CompletedTask;
  }
  private async Task DoImportGamesAsync()
  {
    if (PendingImports.Count == 0) return;
    try
    {
      foreach (var item in PendingImports)
      {
        try
        {
          // Save ROM blob to nesStorage
          try { await JS.InvokeVoidAsync("nesInterop.saveRom", item.Name, item.Base64); } catch { }
          // Put minimal Game record into continue-db if missing
          var nameJson = JsonSerializer.Serialize(item.Name);
          var b64Json = JsonSerializer.Serialize(item.Base64);
          var js = @"(async()=>{ try { if(!window.continueDb) return; await window.continueDb.open(); const name = __NAME__; const b64 = __B64__;
const bin = atob(b64);
const size = bin.length;
const title = name.replace(/\.nes$/i,'');
// Build Uint8Array from base64 string
const bytes = new Uint8Array(size); for (let i=0;i<size;i++){ bytes[i] = bin.charCodeAt(i) & 0xFF; }
// Compute iNES header signature (sha1 of first 16 bytes)
async function sha1Hex(buf){ const d = await crypto.subtle.digest('SHA-1', buf); const arr = new Uint8Array(d); let s=''; for (let b of arr){ s += b.toString(16).padStart(2,'0'); } return s; }
let headerSignature = '';
try { if (bytes.length >= 16) { const hdr = bytes.slice(0,16); const h = await sha1Hex(hdr); headerSignature = 'ines_' + h; } } catch {}
// Parse iNES sizes and trainer to locate PRG+CHR
function parseIdFromInes(u8){ try{ if(u8.length<16) return ''; if(!(u8[0]==0x4E && u8[1]==0x45 && u8[2]==0x53 && u8[3]==0x1A)) return ''; const prg16=u8[4]; const chr8=u8[5]; const f6=u8[6]; const hasTrainer = (f6 & 0x04) !== 0; let off=16 + (hasTrainer?512:0); let prgBytes = prg16*16384; let chrBytes = chr8*8192; if (off+prgBytes+chrBytes>u8.length){ prgBytes = Math.max(0, Math.min(prgBytes, u8.length-off)); chrBytes = Math.max(0, Math.min(chrBytes, u8.length-off-prgBytes)); }
  const prg = u8.slice(off, off+prgBytes); const chr = u8.slice(off+prgBytes, off+prgBytes+chrBytes);
  return {prg, chr}; } catch{ return ''; } }
let gameId = name; try{ const parts = parseIdFromInes(bytes); if (parts && parts.prg){ const concat = new Uint8Array(parts.prg.length + parts.chr.length); concat.set(parts.prg,0); if (parts.chr && parts.chr.length>0) concat.set(parts.chr, parts.prg.length); const sha = await sha1Hex(concat); gameId = 'nes_' + sha; } } catch {}
const id = gameId;
let g = await window.continueDb.get('games', id);
if(!g){ const rec = { id: id, title: title, system:'nes', romKey:name, builtIn:false, size:size, createdAt:new Date().toISOString(), status:'Nothing', commonName:'', note:'', headerSignature: headerSignature }; await window.continueDb.put('games', rec); } } catch(e) { console.warn('continue import failed', e); } } )()";
          js = js.Replace("__NAME__", nameJson).Replace("__B64__", b64Json);
          try { await JS.InvokeVoidAsync("eval", js); } catch { }
        }
        catch { }
      }
    }
    catch { }
    finally
    {
      ImportOpen = false; PendingImports.Clear();
      await LoadRomsFromDbAsync();
      StateHasChanged();
    }
  }

  private RenderFragment CoreSlot(string domain, string? enforced, string? selected, Action openPicker) => builder =>
  {
    int seq = 0; bool isLocked = !string.IsNullOrWhiteSpace(enforced);
    builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", $"core-slot{(isLocked?" locked":"")}");
      builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", "slot-title"); builder.AddContent(seq++, domain); builder.CloseElement();
      builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", "slot-body");
  // Card container
  builder.OpenElement(seq++, "div");
  builder.AddAttribute(seq++, "class", "card-wrap");
  // Inline positioning + explicit size to guarantee overlay coverage
  builder.AddAttribute(seq++, "style", "position:relative; width:142px; height:200px; line-height:0; display:inline-block;");
          // Determine which card to render
          CoreCardModel cardModel;
          if (isLocked)
          {
            cardModel = BuildCard(domain, enforced!);
          }
          else if (!string.IsNullOrWhiteSpace(selected))
          {
            cardModel = BuildCard(domain, selected!);
          }
          else
          {
            cardModel = new CoreCardModel{
              Id = "EMPTY",
              ShortName = $"{domain}",
              DisplayName = $"Select a {domain} Core",
              Description = "Click to choose from your owned cores.",
              Rating = 0,
              Performance = 0,
              FooterNote = domain,
              Domain = domain
            };
          }
          var svg = CardSvgRenderer.Render(cardModel, 142, 200);
          builder.AddMarkupContent(seq++, svg);

          if (isLocked)
          {
            builder.OpenElement(seq++, "div");
            builder.AddAttribute(seq++, "class", "card-enforced-overlay");
            // Inline overlay styles to guarantee coverage over the SVG
            builder.AddAttribute(seq++, "style", "position:absolute;inset:0;background:rgba(0,0,0,0.75);display:flex;align-items:center;justify-content:center;z-index:1000;pointer-events:none;");
            builder.AddAttribute(seq++, "title", "Enforced by level");
            builder.AddAttribute(seq++, "aria-hidden", "true");

            // Centered lock icon behind text
            builder.OpenElement(seq++, "svg");
            builder.AddAttribute(seq++, "viewBox", "0 0 64 64");
            builder.AddAttribute(seq++, "aria-hidden", "true");
            builder.AddAttribute(seq++, "focusable", "false");
            builder.AddAttribute(seq++, "style", "position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:128px;height:128px;opacity:.22;fill:#fff;stroke:#fff;stroke-width:4;overflow:visible;");
            builder.AddMarkupContent(seq++, "<rect x='16' y='28' width='32' height='28' rx='5' ry='5'/>\n<path d='M22 28 V20 a10 10 0 0 1 20 0 v8' fill='none' stroke-linecap='round' stroke-linejoin='round'/>\n");
            builder.CloseElement();

            builder.OpenElement(seq++, "div");
            builder.AddAttribute(seq++, "class", "enforced-text");
            builder.AddAttribute(seq++, "style", "color:#fff;font-size:0.9rem;font-weight:700;text-shadow:0 1px 2px rgba(0,0,0,0.8);");
            builder.AddContent(seq++, "Enforced");
            builder.CloseElement();
            builder.CloseElement();
          }
          else
          {
            // Make the whole card clickable to open the picker when not locked
            builder.OpenElement(seq++, "button"); builder.AddAttribute(seq++, "type", "button"); builder.AddAttribute(seq++, "class", "card-cover-btn"); builder.AddAttribute(seq++, "aria-label", $"Select {domain} core"); builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, openPicker)); builder.CloseElement();
          }
        builder.CloseElement(); // .card-wrap
      builder.CloseElement(); // .slot-body
    builder.CloseElement(); // .core-slot
  };

  // Mirror the SVG card's rating-to-border palette for consistency
  private static string RatingToBorderColor(int rating)
  {
    return rating switch
    {
      <= 0 => "#6b7280", // slate/neutral
      1 => "#ef4444",    // red 500
      2 => "#f59e0b",    // amber 500
      3 => "#10b981",    // emerald 500
      4 => "#3b82f6",    // blue 500
      _ => "#a855f7"      // purple 500 for 5
    };
  }

  private void OpenCpuPicker() => OpenPicker("CPU");
  private void OpenPpuPicker() => OpenPicker("PPU");
  private void OpenApuPicker() => OpenPicker("APU");
  private void OpenShaderPicker() => OpenPicker("SHADER");

  private void OpenPicker(string domain)
  {
    // Simple cycle picker for now (first non-FMC choice if exists, else FMC)
    switch (domain)
    {
      case "CPU": SelectedCpu = OwnedCpu.FirstOrDefault() ?? "FMC"; break;
      case "PPU": SelectedPpu = OwnedPpu.FirstOrDefault() ?? "FMC"; break;
      case "APU": SelectedApu = OwnedApu.FirstOrDefault() ?? "FMC"; break;
  case "SHADER": SelectedShader = OwnedShader.FirstOrDefault() ?? "PX"; break;
    }
  }

  private async Task OpenCardZoom(string domain, string id)
  {
    ZoomCard = BuildCard(domain, id);
    ModalClosing = false; _zoomInit = false;
    await InvokeAsync(StateHasChanged);
  }

  private async Task CloseZoom()
  {
    if (ZoomCard == null) return;
    ModalClosing = true; await InvokeAsync(StateHasChanged);
    try { await Task.Delay(160); } catch { }
    ZoomCard = null; ModalClosing = false; _zoomInit = false;
  }

  private CoreCardModel BuildCard(string domain, string id)
  {
    // Fetch meta via reflection to enrich the card (best-effort)
    string name = id; string desc = string.Empty; int perf = 0; int rating = 0; string footer = domain;
    try
    {
      // Minimal iNES to allow core instantiation when needed
      var dummy = new byte[16 + 16 * 1024]; dummy[0]=0x4E; dummy[1]=0x45; dummy[2]=0x53; dummy[3]=0x1A; dummy[4]=1; dummy[5]=0; var cart = new Cartridge(dummy); var bus = new Bus(cart);
      switch (domain)
      {
        case "CPU":
          if (CoreRegistry.CpuTypes.TryGetValue(id, out var tCpu))
          {
            var cpu = CoreRegistry.CreateInstance<ICPU>(tCpu, bus);
            if (cpu != null) { name = cpu.CoreName ?? ("CPU_" + id); desc = cpu.Description ?? ""; perf = cpu.Performance; rating = Math.Clamp(cpu.Rating,0,5); footer = cpu.Category ?? domain; }
          }
          break;
        case "PPU":
          if (CoreRegistry.PpuTypes.TryGetValue(id, out var tPpu))
          {
            var ppu = CoreRegistry.CreateInstance<IPPU>(tPpu, bus);
            if (ppu != null) { name = ppu.CoreName ?? ("PPU_" + id); desc = ppu.Description ?? ""; perf = ppu.Performance; rating = Math.Clamp(ppu.Rating,0,5); footer = ppu.Category ?? domain; }
          }
          break;
        case "APU":
          if (CoreRegistry.ApuTypes.TryGetValue(id, out var tApu))
          {
            var apu = CoreRegistry.CreateInstance<IAPU>(tApu, bus);
            if (apu != null) { name = apu.CoreName ?? ("APU_" + id); desc = apu.Description ?? ""; perf = apu.Performance; rating = Math.Clamp(apu.Rating,0,5); footer = apu.Category ?? domain; }
          }
          break;
        case "SHADER":
          try
          {
            var sh = ShaderProvider?.GetById(id);
            if (sh != null)
            {
              name = !string.IsNullOrWhiteSpace(sh.DisplayName) ? sh.DisplayName : (sh.CoreName ?? ("SHADER_" + id));
              desc = sh.Description ?? string.Empty;
              perf = sh.Performance;
              rating = Math.Clamp(sh.Rating, 0, 5);
              footer = "SHADER";
            }
          }
          catch { }
          break;
        default:
          // Unknown domain (e.g., MAPPER/CLOCK/SHADER) — synthesize a reasonable card label
          name = $"{domain}_" + id; desc = string.Empty; perf = 0; rating = 0; footer = domain;
          break;
      }
    }
    catch { }
    return new CoreCardModel{ Id=id, ShortName=$"{domain}_{id}", DisplayName=name, Description=desc, Performance=perf, Rating=rating, FooterNote=footer, Domain=domain };
  }

  private string BuildRel(string path){ if(string.IsNullOrWhiteSpace(path)) return string.Empty; return path.TrimStart('/'); }

  private async Task OnReturn()
  {
    try { await JS.InvokeVoidAsync("eval", @"(function(){try{if(window.music){try{window.music.fadeOut&&window.music.fadeOut(700,true);}catch(e){}} setTimeout(function(){try{window.nesInterop&&window.nesInterop.playTitleMusic&&window.nesInterop.playTitleMusic();}catch(e){}},150);}catch(e){}})();"); } catch { }
    try { await Task.Delay(120); } catch { }
    Nav.NavigateTo(BuildRel("deck-builder?skipHW=1"), false);
  }

  // ===== Level data (continueDb) =====
  private sealed class DbLevel
  {
    public int index { get; set; }
    public string[]? requiredCards { get; set; }
    public int requiredStars { get; set; }
    public string? title { get; set; }
    public string? cardChallenge { get; set; }
  }

  private async Task LoadLevelFromDbAsync(int index)
  {
    try
    {
      // Ask continueDb for this level by primary key (index)
      var json = await JS.InvokeAsync<string>("eval", @$"(async()=>{{ try {{ if(!window.continueDb) return ''; await window.continueDb.open(); const rec = await window.continueDb.get('levels', {index}); return JSON.stringify(rec||null); }} catch(e) {{ return ''; }} }})()");
      DbLevel? level = string.IsNullOrWhiteSpace(json) ? null : JsonSerializer.Deserialize<DbLevel>(json);

      // Defaults if no record
      LevelTitle = level?.title ?? level?.cardChallenge ?? $"Level {index}";
  // Respect 0 as a valid value; only fallback to 5 if the level record is missing
  RequiredStars = level != null ? Math.Max(0, level.requiredStars) : 5;

  // Reset enforced slots
  EnforcedCpu = EnforcedPpu = EnforcedApu = EnforcedShader = null;

      // Parse requiredCards => fill per-domain enforced ids and build header chips
      var enforced = new List<(string domain, string id, string label, string border)>();
      foreach (var raw in (level?.requiredCards ?? Array.Empty<string>()))
      {
        if (string.IsNullOrWhiteSpace(raw)) continue;
        var parts = raw.Split('_', 2, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length != 2) continue;
        var domain = parts[0].ToUpperInvariant();
        var id = parts[1];
        switch (domain)
        {
          case "CPU": EnforcedCpu = id; break;
          case "PPU": EnforcedPpu = id; break;
          case "APU": EnforcedApu = id; break;
          case "SHADER": EnforcedShader = id; break;
        }
  // Skip displaying CLOCK in the enforced chips header
  if (domain == "CLOCK") continue;
  var card = BuildCard(domain, id);
  enforced.Add((domain, id, $"{domain}_"+id, RatingToBorderColor(Math.Clamp(card.Rating,0,5))));
      }
      // If DB had no enforced cards, retain a sensible default to keep the page functional
      if (enforced.Count == 0)
      {
        EnforcedCpu ??= "FMC"; EnforcedPpu ??= "FMC"; EnforcedApu ??= "FMC";
        var cpu = BuildCard("CPU", EnforcedCpu);
        var ppu = BuildCard("PPU", EnforcedPpu);
        var apu = BuildCard("APU", EnforcedApu);
        enforced.Add(("CPU", EnforcedCpu, "CPU_"+EnforcedCpu, RatingToBorderColor(Math.Clamp(cpu.Rating,0,5))));
        enforced.Add(("PPU", EnforcedPpu, "PPU_"+EnforcedPpu, RatingToBorderColor(Math.Clamp(ppu.Rating,0,5))));
        enforced.Add(("APU", EnforcedApu, "APU_"+EnforcedApu, RatingToBorderColor(Math.Clamp(apu.Rating,0,5))));
      }
      EnforcedCards = enforced.ToArray();
    }
    catch
    {
      // Fallbacks if continueDb not available
      LevelTitle = $"Level {index}";
      RequiredStars = 5;
      EnforcedCpu ??= "FMC"; EnforcedPpu ??= "FMC"; EnforcedApu ??= "FMC";
      var cpu = BuildCard("CPU", EnforcedCpu);
      var ppu = BuildCard("PPU", EnforcedPpu);
      var apu = BuildCard("APU", EnforcedApu);
      EnforcedCards = new[]{
        ("CPU", EnforcedCpu, "CPU_"+EnforcedCpu, RatingToBorderColor(Math.Clamp(cpu.Rating,0,5))),
        ("PPU", EnforcedPpu, "PPU_"+EnforcedPpu, RatingToBorderColor(Math.Clamp(ppu.Rating,0,5))),
        ("APU", EnforcedApu, "APU_"+EnforcedApu, RatingToBorderColor(Math.Clamp(apu.Rating,0,5)))
      };
    }
  }

  private async Task LoadRomsFromDbAsync()
  {
    try
    {
      var json = await JS.InvokeAsync<string>("eval", @"(async()=>{try{if(!window.continueDb)return '';await window.continueDb.open();const [games,ach]=await Promise.all([window.continueDb.getAll('games'),window.continueDb.getAll('achievements')]);return JSON.stringify({games,ach});}catch(e){return ''}})()");
      if (string.IsNullOrWhiteSpace(json)) return;
      using var doc = JsonDocument.Parse(json);
      var root = doc.RootElement;
      if (!root.TryGetProperty("games", out var gArr) || !root.TryGetProperty("ach", out var aArr)) return;

    var games = new List<DbGame>();
      foreach (var g in gArr.EnumerateArray())
      {
        games.Add(new DbGame
        {
          id = g.GetProperty("id").GetString() ?? string.Empty,
      commonName = g.TryGetProperty("commonName", out var cn) ? cn.GetString() : null,
          title = g.TryGetProperty("title", out var t) ? t.GetString() : null,
          name = g.TryGetProperty("name", out var n) ? n.GetString() : null,
          romKey = g.TryGetProperty("romKey", out var rk) ? rk.GetString() : null,
          system = g.TryGetProperty("system", out var s) ? s.GetString() : null,
          platform = g.TryGetProperty("platform", out var p) ? p.GetString() : null,
          notes = g.TryGetProperty("notes", out var no) ? no.GetString() : null,
          subtitle = g.TryGetProperty("subtitle", out var sub) ? sub.GetString() : null,
        });
      }

      var achByGame = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
      var completedByGame = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
      foreach (var a in aArr.EnumerateArray())
      {
        var gid = a.TryGetProperty("gameId", out var gpe) ? (gpe.GetString() ?? string.Empty) : string.Empty;
        if (string.IsNullOrEmpty(gid)) continue;
        achByGame[gid] = (achByGame.TryGetValue(gid, out var c) ? c : 0) + 1;
        var aid = a.TryGetProperty("id", out var idpe) ? idpe.GetString() : null;
        if (!string.IsNullOrWhiteSpace(aid) && UnlockedAchievementIds.Contains(aid!))
        {
          completedByGame[gid] = (completedByGame.TryGetValue(gid, out var cc) ? cc : 0) + 1;
        }
      }

      RomRows = games.Select(g => new RomRow
      {
        Id = g.id,
        Title = !string.IsNullOrWhiteSpace(g.commonName) ? g.commonName! : (g.romKey ?? g.title ?? g.name ?? g.id),
        Subtitle = string.IsNullOrWhiteSpace(g.subtitle) ? null : g.subtitle,
        Total = achByGame.TryGetValue(g.id, out var tot) ? tot : 0,
        Completed = completedByGame.TryGetValue(g.id, out var comp) ? comp : 0,
        Notes = g.notes
      }).ToList();

      // Default select first compatible game if none selected
      if (SelectedGameId == null)
      {
        SelectedGameId = RomRows.FirstOrDefault(r => r.Compatible)?.Id;
      }
    }
    catch { }
  }
}
