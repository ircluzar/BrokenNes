using System;
using System.Linq;
using BrokenNes.CorruptorModels;
using System.Threading.Tasks;

namespace BrokenNes
{
    public partial class Emulator
    {
        private sealed class JsPredictRequest
        {
            public int[] window { get; set; } = Array.Empty<int>();
            public int holeStart { get; set; }
            public int holeEnd { get; set; }
            public double temperature { get; set; }
            public int? topK { get; set; }
        }

        private sealed class JsPredictResponse
        {
            public int[] bytes { get; set; } = Array.Empty<int>();
        }

        /// <summary>
        /// Core API: Load imagine model for an epoch. Returns true on success and records EP label.
        /// </summary>
        public async Task<bool> ImagineLoadModelAsync(int epoch)
        {
            try
            {
                ImagineLastError = string.Empty;
                var res = await JS.InvokeAsync<JsLoadModelResult>("imagine.loadModel", new object?[] { epoch });
                if (res != null && res.ok)
                {
                    ImagineEpoch = epoch;
                    ImagineModelLoaded = true;
                    ImagineEpLabel = res.info ?? string.Empty;
                    return true;
                }
                ImagineModelLoaded = false; ImagineEpLabel = string.Empty;
                ImagineLastError = res?.error ?? "Unknown error";
                return false;
            }
            catch (Exception ex)
            {
                ImagineModelLoaded = false; ImagineEpLabel = string.Empty; ImagineLastError = ex.Message;
                return false;
            }
            finally { StateHasChanged(); }
        }

        /// <summary>
        /// Core API: Call JS predictor with a prepared 128-token window and hole span. Returns generated bytes.
        /// </summary>
        public async Task<byte[]> ImaginePredictSpanAsync(int[] tokens128, int holeStart, int holeEnd, float temperature, int? topK)
        {
            if (tokens128 == null || tokens128.Length != 128) throw new ArgumentException("tokens128 must be length 128");
            if (holeStart < 0 || holeStart >= 128) throw new ArgumentOutOfRangeException(nameof(holeStart));
            if (holeEnd <= holeStart || holeEnd > 128) throw new ArgumentOutOfRangeException(nameof(holeEnd));
            if (!ImagineModelLoaded) throw new InvalidOperationException("Imagine model not loaded");

            var req = new JsPredictRequest
            {
                window = tokens128.ToArray(),
                holeStart = holeStart,
                holeEnd = holeEnd,
                temperature = Math.Clamp(temperature, 0.0, 1.5),
                topK = (topK.HasValue && topK.Value <= 0) ? null : topK
            };
            try
            {
                var res = await JS.InvokeAsync<JsPredictResponse>("imagine.predictSpan", new object?[]{ req });
                var arr = res?.bytes ?? Array.Empty<int>();
                var bytes = new byte[arr.Length];
                for (int i = 0; i < arr.Length; i++) bytes[i] = (byte)Math.Clamp(arr[i], 0, 255);
                return bytes;
            }
            catch (Exception ex)
            {
                ImagineLastError = ex.Message; StateHasChanged();
                throw;
            }
        }

        /// <summary>
        /// Build a 128-length token window centered around PC where possible; mask [PC..PC+holeLen) with 256.
        /// Returns tokens and outputs holeStart/holeEnd indices into the window.
        /// </summary>
        public int[] BuildTokens128AroundPc(ushort pc, int holeLen, out int holeStart, out int holeEnd)
        {
            holeStart = 0; holeEnd = 0;
            if (nes == null) throw new InvalidOperationException("NES not initialized");
            if (pc < 0x8000 || pc > 0xFFFF) throw new InvalidOperationException("PC not in PRG ROM ($8000..$FFFF)");
            int L = Math.Clamp(holeLen, 1, 32);
            // Clamp to end-of-address-space safety
            int remain = 0x10000 - pc; if (L > remain) L = remain;
            // Choose a base so that PC is near the middle but ensure full [PC..PC+L) within window
            int start = pc - 64;
            if (start < 0x8000) start = 0x8000;
            // Ensure hole fits fully
            if (pc + L - start > 128) start = pc + L - 128;
            if (start < 0x8000) start = 0x8000;
            if (start > 0xFFFF - 127) start = 0xFFFF - 127;

            var tokens = new int[128];
            for (int i = 0; i < 128; i++)
            {
                ushort addr = (ushort)(start + i);
                byte v = nes.PeekCpu(addr);
                bool inHole = addr >= pc && addr < pc + L;
                tokens[i] = inHole ? 256 : (int)v;
            }
            holeStart = pc - start;
            holeEnd = holeStart + L;
            return tokens;
        }

        /// <summary>
        /// Patch predicted bytes into PRG ROM domain if mapping is simple NROM/fixed-32KB.
        /// Returns true if applied; false if mapping could not be determined.
        /// </summary>
        public Task<bool> ApplyImaginePatchAsync(ushort pc, byte[] bytes)
        {
            if (nes == null || bytes == null || bytes.Length == 0) return Task.FromResult(false);
            if (pc < 0x8000 || pc > 0xFFFF) return Task.FromResult(false);
            // Simple mapping assumption: NROM or fixed 32KB PRG => index = addr - 0x8000
            int baseIndex = pc - 0x8000;
            // Quick sanity: verify at least first byte matches PRG snapshot at that index
            try
            {
                byte origCpu = nes.PeekCpu(pc);
                byte origPrg = nes.PeekPrg(baseIndex);
                if (origCpu != origPrg)
                {
                    // We can't guarantee mapping in banked mappers without helper API; abort safely
                    return Task.FromResult(false);
                }
                for (int i = 0; i < bytes.Length; i++)
                {
                    nes.PokePrg(baseIndex + i, bytes[i]);
                }
                // Record a minimal stash entry via Corruptor for audit (name only for now)
                try
                {
                    Corruptor.GhStash.Add(new HarvestEntry
                    {
                        Name = $"Imagine PC={pc:X4} L={bytes.Length} E{ImagineEpoch}",
                        Created = DateTime.UtcNow,
                        Writes = bytes.Select((b, i) => new BlastInstruction { Domain = "PRG", Address = baseIndex + i, Value = b }).ToList()
                    });
                }
                catch { }
                return Task.FromResult(true);
            }
            catch { return Task.FromResult(false); }
        }
    }
}
