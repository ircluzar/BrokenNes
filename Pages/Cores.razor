@page "/cores"
@using NesEmulator
@using NesEmulator.Shaders
@inject IJSRuntime JS
@inject IShaderProvider ShaderProvider
@using BrokenNes.Shared

<div class="options-root">
  <div id="pixelBgHost" class="pixel-bg-host" aria-hidden="true"></div>
  <h2 class="opt-title">UNLOCKED CORES</h2>
  <div class="card-sections">
    <section class="card-section">
      <h3 class="opt-h3">CPU</h3>
      <div class="card-grid">
        @if (CpuMeta.Count > 0)
        {
          foreach (var c in CpuMeta)
          {
            <div class="core-card" @key="c.Id">
              @((MarkupString)CardSvgRenderer.Render(new CoreCardModel {
                  Id = c.Id,
                  ShortName = c.Id,
                  DisplayName = c.Name,
                  Description = c.Description,
                  Rating = Math.Clamp(c.Rating, 0, 5),
                  Performance = c.Performance,
                  FooterNote = c.Description
              }))
            </div>
          }
        }
        else if (Cpu.Count > 0)
        {
          foreach (var id in Cpu)
          {
            <div class="core-card" @key="id">
              @((MarkupString)CardSvgRenderer.Render(new CoreCardModel {
                  Id = id,
                  ShortName = id,
                  DisplayName = id,
                  Rating = 0,
                  Performance = 0
              }))
            </div>
          }
        }
      </div>
    </section>
    <section class="card-section">
      <h3 class="opt-h3">PPU</h3>
      <div class="card-grid">
        @if (PpuMeta.Count > 0)
        {
          foreach (var c in PpuMeta)
          {
            <div class="core-card" @key="c.Id">
              @((MarkupString)CardSvgRenderer.Render(new CoreCardModel {
                  Id = c.Id,
                  ShortName = c.Id,
                  DisplayName = c.Name,
                  Description = c.Description,
                  Rating = Math.Clamp(c.Rating, 0, 5),
                  Performance = c.Performance,
                  FooterNote = c.Description
              }))
            </div>
          }
        }
        else if (Ppu.Count > 0)
        {
          foreach (var id in Ppu)
          {
            <div class="core-card" @key="id">
              @((MarkupString)CardSvgRenderer.Render(new CoreCardModel {
                  Id = id,
                  ShortName = id,
                  DisplayName = id,
                  Rating = 0,
                  Performance = 0
              }))
            </div>
          }
        }
      </div>
    </section>
    <section class="card-section">
      <h3 class="opt-h3">APU</h3>
      <div class="card-grid">
        @if (ApuMeta.Count > 0)
        {
          foreach (var c in ApuMeta)
          {
            <div class="core-card" @key="c.Id">
              @((MarkupString)CardSvgRenderer.Render(new CoreCardModel {
                  Id = c.Id,
                  ShortName = c.Id,
                  DisplayName = c.Name,
                  Description = c.Description,
                  Rating = Math.Clamp(c.Rating, 0, 5),
                  Performance = c.Performance,
                  FooterNote = c.Description
              }))
            </div>
          }
        }
        else if (Apu.Count > 0)
        {
          foreach (var id in Apu)
          {
            <div class="core-card" @key="id">
              @((MarkupString)CardSvgRenderer.Render(new CoreCardModel {
                  Id = id,
                  ShortName = id,
                  DisplayName = id,
                  Rating = 0,
                  Performance = 0
              }))
            </div>
          }
        }
      </div>
    </section>
    <section class="card-section">
      <h3 class="opt-h3">Clock</h3>
      <div class="card-grid">
        @if (ClockInfos.Count > 0)
        {
          foreach (var c in ClockInfos)
          {
            <div class="core-card" @key="c.Id">
              @((MarkupString)CardSvgRenderer.Render(new CoreCardModel {
                  Id = c.Id,
                  ShortName = c.Id,
                  DisplayName = c.Name,
                  Description = c.Description,
                  Rating = 0,
                  Performance = 0,
                  FooterNote = c.Description
              }))
            </div>
          }
        }
        else if (Clock.Count > 0)
        {
          foreach (var id in Clock)
          {
            <div class="core-card" @key="id">
              @((MarkupString)CardSvgRenderer.Render(new CoreCardModel {
                  Id = id,
                  ShortName = id,
                  DisplayName = id,
                  Rating = 0,
                  Performance = 0
              }))
            </div>
          }
        }
      </div>
    </section>
    <section class="card-section">
      <h3 class="opt-h3">Shaders</h3>
      <div class="card-grid">
        @if (ShaderInfos.Count > 0)
        {
          foreach (var s in ShaderInfos)
          {
            <div class="core-card" @key="s.Id">
              @((MarkupString)CardSvgRenderer.Render(new CoreCardModel {
                  Id = s.Id,
                  ShortName = s.Id,
                  DisplayName = s.DisplayName,
                  Description = s.Description,
                  Rating = Math.Clamp(s.Rating, 0, 5),
                  Performance = s.Performance,
                  FooterNote = s.Category
              }))
            </div>
          }
        }
        else if (Shaders.Count > 0)
        {
          foreach (var id in Shaders)
          {
            <div class="core-card" @key="id">
              @((MarkupString)CardSvgRenderer.Render(new CoreCardModel {
                  Id = id,
                  ShortName = id,
                  DisplayName = id,
                  Rating = 0,
                  Performance = 0
              }))
            </div>
          }
        }
      </div>
    </section>
  </div>
  <div class="opt-footer">
    <a href="./deck-builder?skipHW=1" class="opt-link">RETURN</a>
  </div>
</div>

<style>
  .card-sections { display: grid; gap: 24px; }
  .card-section { }
  .card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: 16px;
    align-items: start;
  }
  .core-card svg { width: 100%; height: auto; display: block; }
  .opt-h3 { margin: 8px 0 8px; }
  @@media (min-width: 1200px) {
    .card-sections { gap: 32px; }
    .card-grid { gap: 20px; }
  }
</style>

@code {
  private IReadOnlyList<string> Cpu = Array.Empty<string>();
  private IReadOnlyList<string> Ppu = Array.Empty<string>();
  private IReadOnlyList<string> Apu = Array.Empty<string>();
  private IReadOnlyList<string> Clock = Array.Empty<string>();
  private IReadOnlyList<string> Shaders = Array.Empty<string>();
  private List<ShaderInfo> ShaderInfos = new();

  private List<CoreMeta> CpuMeta = new();
  private List<CoreMeta> PpuMeta = new();
  private List<CoreMeta> ApuMeta = new();
  private List<ClockInfo> ClockInfos = new();

  protected override async Task OnInitializedAsync()
  {
    try { await JS.InvokeVoidAsync("nesInterop.ensureAudioContext"); } catch { }
    try { await JS.InvokeVoidAsync("nesInterop.applySavedAudioVolumes"); } catch { }
    try { await JS.InvokeVoidAsync("eval", "window.homePixelBgEnsure && window.homePixelBgEnsure();"); } catch { }
    // Populate reflection data
    try { Cpu = CoreRegistry.CpuIds; } catch { }
    try { Ppu = CoreRegistry.PpuIds; } catch { }
    try { Apu = CoreRegistry.ApuIds; } catch { }
  try { Clock = ClockRegistry.Ids; } catch { }
  try { Shaders = ShaderProvider.All.Select(s => s.Id).ToArray(); } catch { }
  try {
    var all = ShaderProvider.All;
    var infos = new List<ShaderInfo>(all.Count);
    foreach (var s in all)
    {
      string? cat = null;
      try { cat = s.Defines != null && s.Defines.TryGetValue("Category", out var c) ? c : null; } catch { }
      infos.Add(new ShaderInfo
      {
        Id = s.Id,
        DisplayName = s.DisplayName,
        Description = s.Description,
        Performance = s.Performance,
        Rating = s.Rating,
        Category = cat ?? "Uncategorized"
      });
    }
    ShaderInfos = infos
      .OrderBy(i => i.Category, StringComparer.OrdinalIgnoreCase)
      .ThenBy(i => i.DisplayName, StringComparer.OrdinalIgnoreCase)
      .ToList();
  } catch { }

    // Try to instantiate cores on a minimal bus to read metadata
    try
    {
      // Build a tiny, valid iNES ROM (NROM-128: 1x16KB PRG, 0 CHR)
      var dummy = new byte[16 + 16 * 1024];
      dummy[0] = 0x4E; dummy[1] = 0x45; dummy[2] = 0x53; dummy[3] = 0x1A; // NES\x1A
      dummy[4] = 1; // PRG banks
      dummy[5] = 0; // CHR banks
      dummy[6] = 0; dummy[7] = 0; // flags
      var cart = new Cartridge(dummy);
      var bus = new Bus(cart);

      // CPU/PPU/APU metadata
      var cpuDict = CoreRegistry.CreateInstances<ICPU>(bus, "CPU_");
      CpuMeta = cpuDict.Select(kv => new CoreMeta
      {
        Id = kv.Key,
        Name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
        Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
        Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
        Rating = SafeGetStruct(() => kv.Value.Rating) ?? 0
      }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      var ppuDict = CoreRegistry.CreateInstances<IPPU>(bus, "PPU_");
      PpuMeta = ppuDict.Select(kv => new CoreMeta
      {
        Id = kv.Key,
        Name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
        Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
        Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
        Rating = SafeGetStruct(() => kv.Value.Rating) ?? 0
      }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      var apuDict = CoreRegistry.CreateInstances<IAPU>(bus, "APU_");
      ApuMeta = apuDict.Select(kv => new CoreMeta
      {
        Id = kv.Key,
        Name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
        Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
        Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
        Rating = SafeGetStruct(() => kv.Value.Rating) ?? 0
      }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      // Clock metadata (no perf/rating in IClock)
  ClockInfos = new List<ClockInfo>();
      foreach (var id in Clock)
      {
        try
        {
          var clk = ClockRegistry.Create(id);
          if (clk != null)
          {
    ClockInfos.Add(new ClockInfo { Id = id, Name = clk.DisplayName, Description = clk.Description });
          }
        }
        catch { }
      }
  ClockInfos = ClockInfos.OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();
    }
    catch
    {
      // If anything fails (e.g., environment), fall back to simple ID lists already populated above
    }
  }

  private static T? SafeGet<T>(Func<T> getter)
  {
    try { return getter(); } catch { return default; }
  }

  private static T? SafeGetStruct<T>(Func<T> getter) where T : struct
  {
    try { return getter(); } catch { return null; }
  }

  private sealed class CoreMeta
  {
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public int Performance { get; set; }
    public int Rating { get; set; }
  }

  private sealed class ClockInfo
  {
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
  }

  private sealed class ShaderInfo
  {
    public string Id { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public int Performance { get; set; }
    public int Rating { get; set; }
    public string Category { get; set; } = string.Empty;
  }
}
