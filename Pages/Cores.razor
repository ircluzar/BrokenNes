@page "/cores"
@using NesEmulator
@using NesEmulator.Shaders
@inject IJSRuntime JS
@inject IShaderProvider ShaderProvider
@inject BrokenNes.Services.GameSaveService SaveSvc
@using BrokenNes.Shared

<div class="cores-root">
  <h2 class="cores-title">UNLOCKED CORES</h2>

  <div class="filters-toolbar">
    <div class="filters-row">
      <div class="filter-field">
        <label for="groupBy">Group by</label>
        <select id="groupBy" value="@GroupBy.ToString()" @onchange="OnGroupChange">
          <option value="None">None</option>
          <option value="Type">Type</option>
          <option value="Category">Category</option>
          <option value="Rating">Rating</option>
        </select>
      </div>

      <div class="filter-field">
        <label for="sortBy">Order</label>
        <div class="order-control">
          <select id="sortBy" value="@SortBy.ToString()" @onchange="OnSortChange">
            <option value="None">None</option>
            <option value="Alphabetical">Alphabetical</option>
            <option value="Performance">Performance</option>
            <option value="Rating">Rating</option>
          </select>
          <button type="button" class="order-toggle" title="Flip order" @onclick="FlipOrder">â‡…</button>
        </div>
      </div>
      
      <div class="filter-field">
        <label for="viewMode">View</label>
        <select id="viewMode" value="@View.ToString()" @onchange="OnViewChange">
          <option value="Cards">Cards</option>
          <option value="List">List</option>
        </select>
      </div>
    </div>
  </div>

  @if (View == ViewMode.List)
  {
    @if (GroupBy == GroupMode.Type)
    {
      <div class="list-sections">
        @foreach (var sec in TypeSections)
        {
          if (sec.items.Count == 0) { continue; }
          <section class="list-section">
            <h3 class="opt-h3">@sec.title</h3>
            <div class="list-grid">
              @foreach (var item in GetSorted(sec.items))
              {
                var model = ToCard(item);
                <button type="button" class="core-row" @key="item.Key" @onclick="() => OpenCard(model)">
                  <span class="row-left">
                    <span class="pill pill-@item.Domain.ToLower()">@item.Domain</span>
                  </span>
                  <span class="row-main">@item.DisplayName</span>
                  <span class="row-meta">
                    <span class="meta-badge">@(!string.IsNullOrWhiteSpace(item.Category) ? item.Category : item.Domain)</span>
                    <span class="meta-perf @PerfClass(item.Performance)" title="Performance">@item.Performance</span>
                    <span class="meta-stars" title="Rating">@RenderStars(item.Rating)</span>
                  </span>
                </button>
              }
            </div>
          </section>
        }
      </div>
    }
    else if (GroupBy == GroupMode.Category)
    {
      <div class="list-sections">
        @foreach (var g in CategoryGroups)
        {
          if (g.Value.Count == 0) { continue; }
          <section class="list-section">
            <h3 class="opt-h3">@g.Key</h3>
            <div class="list-grid">
              @foreach (var item in GetSorted(g.Value))
              {
                var model = ToCard(item);
                <button type="button" class="core-row" @key="item.Key" @onclick="() => OpenCard(model)">
                  <span class="row-left">
                    <span class="pill pill-@item.Domain.ToLower()">@item.Domain</span>
                  </span>
                  <span class="row-main">@item.DisplayName</span>
                  <span class="row-meta">
                    <span class="meta-badge">@(!string.IsNullOrWhiteSpace(item.Category) ? item.Category : item.Domain)</span>
                    <span class="meta-perf @PerfClass(item.Performance)" title="Performance">@item.Performance</span>
                    <span class="meta-stars" title="Rating">@RenderStars(item.Rating)</span>
                  </span>
                </button>
              }
            </div>
          </section>
        }
      </div>
    }
    else if (GroupBy == GroupMode.Rating)
    {
      <div class="list-sections">
        @foreach (var bucket in RatingBuckets)
        {
          if (bucket.items.Count == 0) { continue; }
          <section class="list-section">
            <h3 class="opt-h3">@bucket.title</h3>
            <div class="list-grid">
              @foreach (var item in GetSorted(bucket.items))
              {
                var model = ToCard(item);
                <button type="button" class="core-row" @key="item.Key" @onclick="() => OpenCard(model)">
                  <span class="row-left">
                    <span class="pill pill-@item.Domain.ToLower()">@item.Domain</span>
                  </span>
                  <span class="row-main">@item.DisplayName</span>
                  <span class="row-meta">
                    <span class="meta-badge">@(!string.IsNullOrWhiteSpace(item.Category) ? item.Category : item.Domain)</span>
                    <span class="meta-perf @PerfClass(item.Performance)" title="Performance">@item.Performance</span>
                    <span class="meta-stars" title="Rating">@RenderStars(item.Rating)</span>
                  </span>
                </button>
              }
            </div>
          </section>
        }
      </div>
    }
    else
    {
      <section class="list-section">
        <div class="list-grid">
          @foreach (var item in GetSorted(AllItems))
          {
            var model = ToCard(item);
            <button type="button" class="core-row" @key="item.Key" @onclick="() => OpenCard(model)">
              <span class="row-left">
                <span class="pill pill-@item.Domain.ToLower()">@item.Domain</span>
              </span>
              <span class="row-main">@item.DisplayName</span>
              <span class="row-meta">
                <span class="meta-badge">@(!string.IsNullOrWhiteSpace(item.Category) ? item.Category : item.Domain)</span>
                <span class="meta-perf @PerfClass(item.Performance)" title="Performance">@item.Performance</span>
                <span class="meta-stars" title="Rating">@RenderStars(item.Rating)</span>
              </span>
            </button>
          }
        </div>
      </section>
    }
  }
  else
  {
    @if (GroupBy == GroupMode.Type)
    {
      <div class="card-sections">
        @foreach (var sec in TypeSections)
        {
          if (sec.items.Count == 0) { continue; }
          <section class="card-section">
            <h3 class="opt-h3">@sec.title</h3>
            <div class="card-grid">
              @foreach (var item in GetSorted(sec.items))
              {
                var model = ToCard(item);
                <div class="core-card" @key="item.Key" @onclick="() => OpenCard(model)">
                  @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
                </div>
              }
            </div>
          </section>
        }
      </div>
    }
    else if (GroupBy == GroupMode.Category)
    {
      <div class="card-sections">
        @foreach (var g in CategoryGroups)
        {
          if (g.Value.Count == 0) { continue; }
          <section class="card-section">
            <h3 class="opt-h3">@g.Key</h3>
            <div class="card-grid">
              @foreach (var item in GetSorted(g.Value))
              {
                var model = ToCard(item);
                <div class="core-card" @key="item.Key" @onclick="() => OpenCard(model)">
                  @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
                </div>
              }
            </div>
          </section>
        }
      </div>
    }
    else if (GroupBy == GroupMode.Rating)
    {
      <div class="card-sections">
        @foreach (var bucket in RatingBuckets)
        {
          if (bucket.items.Count == 0) { continue; }
          <section class="card-section">
            <h3 class="opt-h3">@bucket.title</h3>
            <div class="card-grid">
              @foreach (var item in GetSorted(bucket.items))
              {
                var model = ToCard(item);
                <div class="core-card" @key="item.Key" @onclick="() => OpenCard(model)">
                  @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
                </div>
              }
            </div>
          </section>
        }
      </div>
    }
    else
    {
      <section class="card-section">
        <div class="card-grid">
          @foreach (var item in GetSorted(AllItems))
          {
            var model = ToCard(item);
            <div class="core-card" @key="item.Key" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        </div>
      </section>
    }
  }

  <div class="cores-footer">
    <a href="./deck-builder?skipHW=1" class="cores-link">RETURN</a>
  </div>
</div>

@if (SelectedCard != null)
{
  <div class="card-modal-backdrop @(ModalClosing ? "closing" : "opening")" @onclick="CloseCard">
    <div class="card-modal-content @(ModalClosing ? "closing" : "opening")" @onclick="CloseCard">
      @((MarkupString)CardSvgRenderer.Render(SelectedCard))
    </div>
  </div>
}

@code {
  // Group/sort state
  private enum GroupMode { None, Type, Category, Rating }
  private enum SortMode { None, Alphabetical, Performance, Rating }
  private enum ViewMode { Cards, List }
  private GroupMode GroupBy = GroupMode.None; // default: no grouping
  private SortMode SortBy = SortMode.None;    // default: no order
  private bool SortDescending = false;        // toggle via button
  private ViewMode View = ViewMode.Cards;     // default view
  private bool _modalZoomInit = false;

  private IReadOnlyList<string> Cpu = Array.Empty<string>();
  private IReadOnlyList<string> Ppu = Array.Empty<string>();
  private IReadOnlyList<string> Apu = Array.Empty<string>();
  private IReadOnlyList<string> Clock = Array.Empty<string>();
  private IReadOnlyList<string> Shaders = Array.Empty<string>();

  private List<ShaderInfo> ShaderInfos = new();
  private CoreCardModel? SelectedCard;
  private bool ModalClosing;

  private List<CoreMeta> CpuMeta = new();
  private List<CoreMeta> PpuMeta = new();
  private List<CoreMeta> ApuMeta = new();
  private List<ClockInfo> ClockInfos = new();

  // Unified items for flexible grouping/sorting
  private readonly List<CoreItem> AllItems = new();

  // Derived views
  private (string title, List<CoreItem> items)[] TypeSections = Array.Empty<(string title, List<CoreItem> items)>();
  private Dictionary<string, List<CoreItem>> CategoryGroups = new(StringComparer.OrdinalIgnoreCase);
  private (string title, List<CoreItem> items)[] RatingBuckets = Array.Empty<(string title, List<CoreItem> items)>();

  protected override async Task OnInitializedAsync()
  {
    try { await JS.InvokeVoidAsync("nesInterop.ensureAudioContext"); } catch { }
    try { await JS.InvokeVoidAsync("nesInterop.applySavedAudioVolumes"); } catch { }
    try { await JS.InvokeVoidAsync("eval", "window.homePixelBgEnsure && window.homePixelBgEnsure();"); } catch { }

    // Register a helper to force modal card SVG to fill viewport
    try { await JS.InvokeVoidAsync("eval", @"(function(){
      window.nesUi = window.nesUi || {};
      window.nesUi.zoomModalSvg = function(){
        try{
          var host = document.querySelector('.card-modal-content');
          if(!host) return;
          var svg = host.querySelector('svg');
          if(!svg) return;
          svg.removeAttribute('width');
          svg.removeAttribute('height');
          svg.style.width = '98vw';
          svg.style.maxWidth = '98vw';
          svg.style.height = 'auto';
          svg.style.maxHeight = '98vh';
          svg.style.display = 'block';
        }catch(e){}
      };
    })();"); } catch { }

    // Populate reflection data
    try { Cpu = CoreRegistry.CpuIds; } catch { }
    try { Ppu = CoreRegistry.PpuIds; } catch { }
    try { Apu = CoreRegistry.ApuIds; } catch { }
    try { Clock = ClockRegistry.Ids; } catch { }
    try { Shaders = ShaderProvider.All.Select(s => s.Id).ToArray(); } catch { }

    // Filter to owned cores per save
    try
    {
      var save = await SaveSvc.LoadAsync();
      var setCpu = new HashSet<string>(save.OwnedCpuIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var setPpu = new HashSet<string>(save.OwnedPpuIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var setApu = new HashSet<string>(save.OwnedApuIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var setClk = new HashSet<string>(save.OwnedClockIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var setShd = new HashSet<string>(save.OwnedShaderIds ?? new(), StringComparer.OrdinalIgnoreCase);
      Cpu = Cpu.Where(id => setCpu.Contains(id)).ToArray();
      Ppu = Ppu.Where(id => setPpu.Contains(id)).ToArray();
      Apu = Apu.Where(id => setApu.Contains(id)).ToArray();
      Clock = Clock.Where(id => setClk.Contains(id)).ToArray();
      Shaders = Shaders.Where(id => setShd.Contains(id)).ToArray();
    }
    catch { }

    // Build shader infos for metadata
    try
    {
      var shaderSet = new HashSet<string>(Shaders, StringComparer.OrdinalIgnoreCase);
    foreach (var s in ShaderProvider.All)
      {
        if (!shaderSet.Contains(s.Id)) continue;
        string? cat = null;
        try { cat = s.Defines != null && s.Defines.TryGetValue("Category", out var c) ? c : null; } catch { }
        ShaderInfos.Add(new ShaderInfo
        {
          Id = s.Id,
      DisplayName = SafeGet(() => s.CoreName) ?? s.DisplayName, // Prefer CoreName for long name
      CoreName = SafeGet(() => s.CoreName) ?? s.DisplayName,
          Description = s.Description,
          Performance = s.Performance,
          Rating = s.Rating,
          Category = cat ?? "Uncategorized"
        });
      }
    }
    catch { }

    // Try to instantiate cores on a minimal bus to read metadata
    try
    {
      // Build a tiny, valid iNES ROM (NROM-128: 1x16KB PRG, 0 CHR)
      var dummy = new byte[16 + 16 * 1024];
      dummy[0] = 0x4E; dummy[1] = 0x45; dummy[2] = 0x53; dummy[3] = 0x1A; // NES\x1A
      dummy[4] = 1; // PRG banks
      dummy[5] = 0; // CHR banks
      dummy[6] = 0; dummy[7] = 0; // flags
      var cart = new Cartridge(dummy);
      var bus = new Bus(cart);

      // CPU/PPU/APU metadata
      var cpuDict = CoreRegistry.CreateInstances<ICPU>(bus, "CPU_");
      CpuMeta = cpuDict
        .Where(kv => Cpu.Contains(kv.Key, StringComparer.OrdinalIgnoreCase))
        .Select(kv => new CoreMeta
        {
          Id = kv.Key,
          Name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
          Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
          Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
          Rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
          Category = SafeGet(() => kv.Value.Category) ?? "Uncategorized"
        }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      var ppuDict = CoreRegistry.CreateInstances<IPPU>(bus, "PPU_");
      PpuMeta = ppuDict
        .Where(kv => Ppu.Contains(kv.Key, StringComparer.OrdinalIgnoreCase))
        .Select(kv => new CoreMeta
        {
          Id = kv.Key,
          Name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
          Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
          Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
          Rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
          Category = SafeGet(() => kv.Value.Category) ?? "Uncategorized"
        }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      var apuDict = CoreRegistry.CreateInstances<IAPU>(bus, "APU_");
      ApuMeta = apuDict
        .Where(kv => Apu.Contains(kv.Key, StringComparer.OrdinalIgnoreCase))
        .Select(kv => new CoreMeta
        {
          Id = kv.Key,
          Name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
          Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
          Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
          Rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
          Category = SafeGet(() => kv.Value.Category) ?? "Uncategorized"
        }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      // Clock metadata
      ClockInfos = new List<ClockInfo>();
      foreach (var id in Clock)
      {
        try
        {
          var clk = ClockRegistry.Create(id);
          if (clk != null)
          {
            ClockInfos.Add(new ClockInfo
            {
              Id = id,
              Name = clk.DisplayName,
              Description = clk.Description,
              Performance = clk.Performance,
              Rating = clk.Rating,
              Category = SafeGet(() => clk.Category) ?? "Uncategorized"
            });
          }
        }
        catch { }
      }
      ClockInfos = ClockInfos.OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();
    }
    catch { }

    // Build unified items list
    BuildItems();
  }

  private void BuildItems()
  {
    AllItems.Clear();
    foreach (var m in CpuMeta) AllItems.Add(CoreItem.From("CPU", m.Id, m.Name, m.Description, m.Performance, m.Rating, m.Category));
    foreach (var m in PpuMeta) AllItems.Add(CoreItem.From("PPU", m.Id, m.Name, m.Description, m.Performance, m.Rating, m.Category));
    foreach (var m in ApuMeta) AllItems.Add(CoreItem.From("APU", m.Id, m.Name, m.Description, m.Performance, m.Rating, m.Category));
    foreach (var m in ClockInfos) AllItems.Add(CoreItem.From("CLOCK", m.Id, m.Name, m.Description, m.Performance, m.Rating, m.Category));
  foreach (var s in ShaderInfos) AllItems.Add(CoreItem.From("SHADER", s.Id, s.CoreName ?? s.DisplayName, s.Description, s.Performance, s.Rating, s.Category));

    // Precompute groupings
    TypeSections = new (string title, List<CoreItem> items)[]
    {
      ("CPU", AllItems.Where(i => i.Domain == "CPU").ToList()),
      ("PPU", AllItems.Where(i => i.Domain == "PPU").ToList()),
      ("APU", AllItems.Where(i => i.Domain == "APU").ToList()),
      ("Clock", AllItems.Where(i => i.Domain == "CLOCK").ToList()),
      ("Shaders", AllItems.Where(i => i.Domain == "SHADER").ToList()),
    };

    CategoryGroups = AllItems
      .GroupBy(i => string.IsNullOrWhiteSpace(i.Category) ? "Uncategorized" : i.Category, StringComparer.OrdinalIgnoreCase)
      .OrderBy(g => g.Key, StringComparer.OrdinalIgnoreCase)
      .ToDictionary(g => g.Key, g => g.ToList(), StringComparer.OrdinalIgnoreCase);

    RatingBuckets = Enumerable.Range(0, 6) // 0..5
      .Reverse()
      .Select(r => (title: r == 1 ? "1 STAR" : $"{r} STARS", items: AllItems.Where(i => Math.Clamp(i.Rating,0,5) == r).ToList()))
      .ToArray();
  }

  private List<CoreItem> GetSorted(IEnumerable<CoreItem> items)
  {
    var list = SortBy switch
    {
      SortMode.Alphabetical => items.OrderBy(i => i.DisplayName, StringComparer.OrdinalIgnoreCase).ToList(),
      SortMode.Performance => items.OrderBy(i => i.Performance).ThenBy(i => i.DisplayName, StringComparer.OrdinalIgnoreCase).ToList(),
      SortMode.Rating => items.OrderBy(i => i.Rating).ThenBy(i => i.DisplayName, StringComparer.OrdinalIgnoreCase).ToList(),
      _ => items.ToList(),
    };
    if (SortBy != SortMode.None && SortDescending)
    {
      list.Reverse();
    }
    else if (SortBy == SortMode.None && SortDescending)
    {
      // With no explicit sort, allow a simple reverse of current order as a convenience
      list.Reverse();
    }
    return list;
  }

  private CoreCardModel ToCard(CoreItem i)
  {
    return new CoreCardModel
    {
      Id = i.Id,
      ShortName = i.ShortName,
      DisplayName = i.DisplayName,
      Description = i.Description,
      Rating = Math.Clamp(i.Rating, 0, 5),
      Performance = i.Performance,
      FooterNote = string.IsNullOrWhiteSpace(i.Category) ? i.Domain : i.Category,
      Domain = i.Domain
    };
  }

  private void OnGroupChange(ChangeEventArgs e)
  {
    if (e?.Value is null) return;
    if (Enum.TryParse<GroupMode>(e.Value.ToString(), out var v))
    {
      GroupBy = v;
      StateHasChanged();
    }
  }

  private void OnSortChange(ChangeEventArgs e)
  {
    if (e?.Value is null) return;
    if (Enum.TryParse<SortMode>(e.Value.ToString(), out var v))
    {
      SortBy = v;
      // Set a sensible default direction per sort type
      SortDescending = v == SortMode.Performance || v == SortMode.Rating;
      StateHasChanged();
    }
  }

  private void OnViewChange(ChangeEventArgs e)
  {
    if (e?.Value is null) return;
    if (Enum.TryParse<ViewMode>(e.Value.ToString(), out var v))
    {
      View = v;
      StateHasChanged();
    }
  }

  private void FlipOrder()
  {
    SortDescending = !SortDescending;
  }

  private static string RenderStars(int rating)
  {
    var r = Math.Clamp(rating, 0, 5);
    return new string('\u2605', r) + new string('\u2606', 5 - r);
  }

  private static string PerfClass(int perf)
  {
    if (perf > 0) return "perf-pos";
    if (perf < 0) return "perf-neg";
    return string.Empty;
  }

  private void OpenCard(CoreCardModel m)
  {
    ModalClosing = false;
    SelectedCard = m;
  _modalZoomInit = false;
  }

  private async Task CloseCard()
  {
    if (SelectedCard == null) return;
    ModalClosing = true;
    StateHasChanged();
    try { await Task.Delay(180); } catch { }
    SelectedCard = null;
    ModalClosing = false;
    _modalZoomInit = false;
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (SelectedCard != null && !_modalZoomInit)
    {
      _modalZoomInit = true;
      try { await JS.InvokeVoidAsync("nesUi.zoomModalSvg"); } catch { }
    }
  }

  private static T? SafeGet<T>(Func<T> getter)
  {
    try { return getter(); } catch { return default; }
  }

  private static T? SafeGetStruct<T>(Func<T> getter) where T : struct
  {
    try { return getter(); } catch { return null; }
  }

  private sealed class CoreMeta
  {
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public int Performance { get; set; }
    public int Rating { get; set; }
    public string Category { get; set; } = string.Empty;
  }

  private sealed class ClockInfo
  {
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public int Performance { get; set; }
    public int Rating { get; set; }
    public string Category { get; set; } = string.Empty;
  }

  private sealed class ShaderInfo
  {
    public string Id { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
  public string? CoreName { get; set; }
    public string Description { get; set; } = string.Empty;
    public int Performance { get; set; }
    public int Rating { get; set; }
    public string Category { get; set; } = string.Empty;
  }

  private sealed class CoreItem
  {
    public string Domain { get; set; } = string.Empty; // CPU/PPU/APU/CLOCK/SHADER
    public string Id { get; set; } = string.Empty;
    public string ShortName => Id;
    public string DisplayName { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public int Performance { get; set; }
    public int Rating { get; set; }
    public string Category { get; set; } = string.Empty;
    public string Key => Domain + ":" + Id;

    public static CoreItem From(string domain, string id, string name, string description, int perf, int rating, string category)
      => new CoreItem { Domain = domain, Id = id, DisplayName = name, Description = description, Performance = perf, Rating = rating, Category = category };
  }
}
