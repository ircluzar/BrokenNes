@page "/nes"
@using System.Timers
@using System.Linq
@using Microsoft.Extensions.Logging
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.WebAssembly.Services
@using BrokenNes.Models
@using BrokenNes.CorruptorModels
@using NesEmulator
@using NesEmulator.Shaders
@using BrokenNes.Shared
@inject ILogger<Nes> Logger
@inject IJSRuntime JS
@inject HttpClient Http
@inject StatusService Status
@inject NesEmulator.Shaders.IShaderProvider ShaderProvider
@inject NavigationManager Nav
@inject BrokenNes.Services.InputSettingsService InputSettingsService
@inject BrokenNes.Services.GameSaveService GameSaveService


@if (!string.IsNullOrEmpty(emu!.Controller.ErrorMessage))
{
    <div class="alert alert-danger" role="alert">
        <strong>⚠️ SYSTEM ERROR:</strong> @emu!.Controller.ErrorMessage
    </div>
}



<div class="nes-grid @(DisplayOnlyMode ? "display-only" : (StageMode ? "stage-mode" : string.Empty))">
    <section class="play-area">
        @if (!DisplayOnlyMode)
        {
        <div class="quick-controls btn-toolbar gap-2 flex-wrap justify-content-center mb-3" role="toolbar">
            <div class="btn-group">
                <button class="btn btn-success ctrl-btn" @onclick="(()=>emu!.StartAsync())" disabled="@(emu!.Controller.IsRunning || emu!.Controller.nes == null)" title="Start (Play)" aria-label="Start">
                    <svg viewBox="0 0 100 100" class="ctrl-ico play" role="img" focusable="false"><polygon points="28,18 82,50 28,82" /></svg>
                </button>
                <button class="btn btn-warning ctrl-btn" @onclick="(()=>emu!.PauseAsync())" disabled="@(!emu!.Controller.IsRunning)" title="Pause" aria-label="Pause">
                    <svg viewBox="0 0 100 100" class="ctrl-ico pause" role="img" focusable="false"><rect x="24" y="18" width="20" height="64" rx="6" /><rect x="56" y="18" width="20" height="64" rx="6" /></svg>
                </button>
                <button class="btn btn-danger ctrl-btn" @onclick="(()=>emu!.ResetAsyncFacade())" disabled="@(emu!.Controller.nes == null)" title="Reset" aria-label="Reset">
                    <svg viewBox="0 0 100 100" class="ctrl-ico reset" role="img" focusable="false"><path d="M50 18a32 32 0 1 1-22.63 9.37" fill="none" stroke="currentColor" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/><path d="M23 13 30 40 5 34" fill="currentColor" /></svg>
                </button>
            </div>
            @if (!HideCoreSelectors)
            {
                <div class="btn-group">
                    @if (ShowShaderPicker)
                    {
                        <div class="qc-select-stack">
                            <label for="shaderSelect" class="mini-label" title="Select video shader pass">Shader</label>
                            <button id="shaderSelect" type="button" class="btn btn-rf btn-select" title="Video shader" aria-label="Video Shader" @onclick="OpenShaderPicker">
                                @GetCurrentShaderLabel()
                            </button>
                        </div>
                    }
                    @if (ShowApuPicker)
                    {
                        <div class="qc-select-stack">
                            <label for="apuCoreSelect" class="mini-label" title="Select audio processing core">APU Core</label>
                            <button id="apuCoreSelect" type="button" class="btn btn-fmc btn-select" title="Audio core" aria-label="Audio Core" @onclick="OpenApuPicker">
                                @emu!.Controller.ApuCoreSel
                            </button>
                        </div>
                    }
                    @if (ShowCpuPicker)
                    {
                        <div class="qc-select-stack">
                            <label for="cpuCoreSelect" class="mini-label" title="Select CPU core implementation">CPU Core</label>
                            <button id="cpuCoreSelect" type="button" class="btn btn-rf btn-select" title="CPU core" aria-label="CPU Core" @onclick="OpenCpuPicker">
                                @emu!.Controller.CpuCoreSel
                            </button>
                        </div>
                    }
                    @if (ShowPpuPicker)
                    {
                        <div class="qc-select-stack">
                            <label for="ppuCoreSelect" class="mini-label" title="Select PPU core implementation">PPU Core</label>
                            <button id="ppuCoreSelect" type="button" class="btn btn-rf btn-select" title="PPU core" aria-label="PPU Core" @onclick="OpenPpuPicker">
                                @emu!.Controller.PpuCoreSel
                            </button>
                        </div>
                    }
                    @if (ShowClockPicker)
                    {
                        <div class="qc-select-stack">
                            <label for="clockCoreSelect" class="mini-label" title="Select frame loop owner">Clock</label>
                            <button id="clockCoreSelect" type="button" class="btn btn-rf btn-select" title="Clock core (loop owner)" aria-label="Clock Core" @onclick="OpenClockPicker">
                                @emu!.Controller.ClockCoreSel
                            </button>
                        </div>
                    }
                </div>
            }
            @if (ShowSavestates)
            {
                <div class="btn-group">
                    <button class="btn btn-load-state" @onclick="(()=>emu!.LoadStateAsyncPublic())" disabled="@(emu!.Controller.nes==null)" title="Load state">Load</button>
                    <button class="btn btn-save-state" @onclick="(()=>emu!.SaveStateAsyncPublic())" disabled="@(emu!.Controller.nes==null)" title="Save state">Save</button>
                </div>
            }
        </div>
        }
    <div class="screen-shell @(emu!.Controller.EmuScale == 0.5 ? "scale-50" : "scale-100")" id="screen-shell">
            @if (!DisplayOnlyMode)
            {
            <div class="overlay-status small">
                <div class="badges d-flex flex-wrap">
                    <span class="badge bg-dark-subtle text-dark me-1">FPS: @emu!.Controller.Fps.ToString("F1")</span>
                    <span class="badge bg-dark-subtle text-dark me-1">State: @(emu!.Controller.IsRunning ? "Running" : "Paused")</span>
                    <span class="badge bg-dark-subtle text-dark me-1">ROM: <strong>@emu!.Controller.CurrentRomName</strong></span>
                    <span class="badge bg-dark-subtle text-dark">Size: @NesController.FormatSize(emu!.Controller.LastLoadedRomSize)</span>
                    <span class="badge bg-dark-subtle text-dark ms-1">SF Core: @emu!.ActiveSfCoreDisplay</span>
                    @if (emu!.SoundFontLayering == true)
                    {
                        <span class="badge bg-warning text-dark ms-1" title="Layering enabled: both cores may receive note events">Layering</span>
                    }
                </div>
                <div class="overlay-actions">
                    <button type="button" class="ov-btn @(emu!.Controller.EmuScale==0.5 ? "active" : string.Empty) desktop-only" title="Scale 50%" @onclick="(()=>emu!.SetScalePublic(0.5))">½×</button>
                    <button type="button" class="ov-btn @(emu!.Controller.EmuScale==1 ? "active" : string.Empty) desktop-only" title="Scale 100%" @onclick="(()=>emu!.SetScalePublic(1))">1×</button>
                    <button type="button" class="ov-btn" title="Toggle Fullscreen" @onclick="(()=>emu!.ToggleFullscreenPublic())">⛶</button>
                </div>
            </div>
            }
            <div class="screen-aspect">
                <canvas id="nes-canvas" width="512" height="480" class="pixel-perfect responsive-canvas" tabindex="0" aria-label="NES Emulator"></canvas>
            </div>
            @if (!DisplayOnlyMode)
            {
            <div id="mobile-fs-view-bar">
                <button data-view="controller" class="view-btn @(emu!.UI.MobileFullscreenView=="controller"?"active":string.Empty)" @onclick="(()=>emu!.UI.ViewController())">Controller</button>
                @if (emu!.RtcUnlocked && !HideRtcGhImagine)
                {
                    <button data-view="rtc" class="view-btn @(emu!.UI.MobileFullscreenView=="rtc"?"active":string.Empty)" @onclick="(()=>emu!.UI.ViewRtc())">RTC</button>
                }
                @if (emu!.GhUnlocked && !HideRtcGhImagine)
                {
                    <button data-view="gh" class="view-btn @(emu!.UI.MobileFullscreenView=="gh"?"active":string.Empty)" @onclick="(()=>emu!.UI.ViewGh())">Glitch Harvester</button>
                }
            </div>
            <div class="mobile-fs-extra-views">
                @if (emu!.UI.MobileFullscreenView == "controller")
                {
                    <div class="mobile-view controller-view" id="touch-controller">
                        <div class="controller-grid">
                            <div class="upper-row">
                                <div class="dpad">
                                    <div class="pad-btn" data-btn="up">▲</div>
                                    <div class="pad-btn" data-btn="left">◀</div>
                                    <div class="pad-btn" data-btn="right">▶</div>
                                    <div class="pad-btn" data-btn="down">▼</div>
                                    <div class="center-dot"></div>
                                </div>
                                <div class="actions">
                                    <div class="ab-cluster">
                                        <div class="btn-b" data-btn="b">B</div>
                                        <div class="btn-a" data-btn="a">A</div>
                                    </div>
                                </div>
                            </div>
                            <div class="start-select-row">
                                <div class="small-btn" data-btn="select">SELECT</div>
                                <div class="small-btn" data-btn="start">START</div>
                            </div>
                            <div class="system-row">
                                <button class="sys-btn" data-act="exit">Exit Fullscreen</button>
                                @if (ShowSavestates)
                                {
                                    <button class="sys-btn" data-act="load">Load State</button>
                                    <button class="sys-btn" data-act="save">Save State</button>
                                }
                            </div>
                        </div>
                    </div>
                }
                else if (emu!.UI.MobileFullscreenView == "rtc" && emu!.RtcUnlocked && !HideRtcGhImagine)
                {
                    <div class="mobile-view rtc-view small">
                        <div class="d-flex align-items-center justify-content-between mb-2">
                            <strong class="small mb-0">Real-Time Corruptor</strong>
                            <span class="text-muted small">@emu!.Corruptor.LastBlastInfo</span>
                        </div>
                        <div class="row g-3 flex-wrap">
                            <div class="col-12">
                                <label class="form-label small mb-1">Memory Domains</label>
                                <select multiple size="5" class="form-select form-select-sm">
                                    @foreach (var d in emu!.Corruptor.MemoryDomains)
                                    {
                                        <option value="@d.Key" selected="@d.Selected">@d.Label (@d.Size)</option>
                                    }
                                </select>
                            </div>
                            <div class="col-12">
                                <label class="form-label mb-1 small">Intensity (@emu!.Corruptor.CorruptIntensity)</label>
                                <input type="range" min="1" max="4096" step="1" class="form-range" value="@emu!.Corruptor.CorruptIntensity" @oninput="(e)=>{if(int.TryParse(e.Value?.ToString(),out var v)) emu!.Corruptor.CorruptIntensity = Math.Clamp(v,1,65535);}" />
                                <div class="d-flex gap-2 align-items-center mb-2 flex-wrap">
                                    <input type="number" min="1" max="4096" class="form-control form-control-sm intensity-box" value="@emu!.Corruptor.CorruptIntensity" @onchange="(e)=>{if(int.TryParse(e.Value?.ToString(),out var v)) emu!.Corruptor.CorruptIntensity = Math.Clamp(v,1,65535);}" />
                                    <button class="btn btn-sm btn-outline-danger" @onclick="(()=>emu!.BlastAsync())" disabled="@(emu!.Controller.nes==null || emu!.AutoCorrupt)" title="Apply one-time corruption now">Blast</button>
                                    <button class="btn btn-sm @(emu!.AutoCorrupt ? "btn-success" : "btn-outline-success")" @onclick="(()=>emu!.ToggleAutoCorrupt())" title="Toggle auto-corruption each frame">Auto: @(emu!.AutoCorrupt ? "ON" : "OFF")</button>
                                    @if (!emu!.Corruptor.LetItRipUsed)
                                    {
                                        <button class="btn btn-sm" style="background-color:#6f42c1;color:#fff;border-color:#6f42c1" @onclick="(()=>emu!.LetItRipPublic())" title="Intensity=1; select PRG ROM + System RAM; enable auto-corrupt; then hide button">Let it rip</button>
                                    }
                                </div>
                                <div class="row g-2 small">
                                    <div class="col-6">
                                        <label class="form-label mb-1 small">Blast Type</label>
                                        <select class="form-select form-select-sm" value="@emu!.BlastType" @onchange="(e)=>emu!.SetBlastTypePublic(e.Value?.ToString()??string.Empty)">
                                            <option value="RANDOM">RANDOM</option>
                                            <option value="TILT">TILT</option>
                                            <option value="RANDOMTILT">RANDOMTILT</option>
                                            <option value="NOP">NOP</option>
                                            <option value="BITFLIP">BITFLIP</option>
                                            @if (emu!.ImagineUnlocked)
                                            {
                                                <option value="IMAGINENEXT">IMAGINE_NEXT</option>
                                                <option value="IMAGINERANDOM">IMAGINE_RANDOM</option>
                                            }
                                        </select>
                                    </div>
                                    <div class="col-6 small text-muted d-flex align-items-end">Random writes across selected domains.</div>
                                </div>
                                <div class="mt-2 small text-muted fst-italic">Last: @emu!.Corruptor.LastBlastInfo</div>
                            </div>
                        </div>
                    </div>
                }
                else if (emu!.UI.MobileFullscreenView == "gh" && emu!.GhUnlocked && !HideRtcGhImagine)
                {
                    <div class="mobile-view gh-view small">
                        <div class="gh-section mb-3">
                            <div class="d-flex flex-wrap gap-2 align-items-end">
                                <div class="flex-grow-1" style="min-width:140px;">
                                    <label class="form-label mb-1 small">New Base Name</label>
                                    <input class="form-control form-control-sm" placeholder="e.g. TitleScreen" @bind="emu!.Corruptor.GhNewBaseName" />
                                </div>
                                <button class="btn btn-sm btn-primary mt-3" @onclick="(()=>emu!.GhAddBase())" disabled="@(emu!.Controller.nes==null)">Add Base</button>
                            </div>
                            <div class="mt-2">
                                <label class="form-label mb-1 small">Base States</label>
                                <select class="form-select form-select-sm" size="4" @onchange="(e)=>emu!.GhOnBaseChangedPublic(e)" value="@emu!.Corruptor.GhSelectedBaseId">
                                    @foreach (var b in emu!.Corruptor.GhBaseStates)
                                    {
                                        <option value="@b.Id">@b.Name</option>
                                    }
                                </select>
                                <div class="d-flex gap-1 mt-2 flex-wrap">
                                    <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.GhLoadSelected())" disabled="@(!emu!.GhHasSelectedBase)">Load</button>
                                    <button class="btn btn-sm btn-outline-danger" @onclick="(()=>emu!.GhDeleteSelected())" disabled="@(!emu!.GhHasSelectedBase)">Delete</button>
                                </div>
                            </div>
                        </div>
                        <div class="gh-section mb-3">
                            <label class="form-label mb-1 small">Actions (uses RTC settings)</label>
                            <div class="d-flex gap-2 flex-wrap">
                                <button class="btn btn-sm btn-warning" @onclick="(()=>emu!.GhCorruptAndStashAsync())" disabled="@(!emu!.GhHasSelectedBase || emu!.Controller.nes==null)">Corrupt &amp; Stash</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.GhClearStashPublic())" disabled="@(emu!.Corruptor.GhStash.Count==0)">Clear Stash</button>
                            </div>
                        </div>
                        <div class="gh-section mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <strong class="small mb-0">Stash (@emu!.Corruptor.GhStash.Count)</strong>
                            </div>
                            @if (emu!.Corruptor.GhStash.Count==0)
                            {
                                <div class="text-muted small fst-italic">(empty)</div>
                            }
                            else
                            {
                                <div class="gh-list">
                                    @foreach (var e in emu!.Corruptor.GhStash.OrderByDescending(e=>e.Created).Take(20))
                                    {
                                        <div class="gh-item">
                                            <div class="gh-item-main">
                                                <span class="gh-name" title="@e.Name">@e.Name</span>
                                                <span class="gh-meta">@e.Writes.Count w @e.Created.ToLocalTime().ToString("HH:mm:ss")</span>
                                            </div>
                                            <div class="gh-actions btn-group btn-group-sm">
                                                <button class="btn btn-outline-light" title="Replay" @onclick="(()=>emu!.GhReplayEntryAsync(e, false))">▶</button>
                                                <button class="btn btn-outline-success" title="Keep" @onclick="(()=>emu!.GhPromote(e))">Keep</button>
                                                <button class="btn btn-outline-danger" title="Discard" @onclick="(()=>emu!.GhDeleteStash(e.Id))">✕</button>
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                        <div class="gh-section">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <strong class="small mb-0">Stockpile (@emu!.Corruptor.GhStockpile.Count)</strong>
                            </div>
                            @if (emu!.Corruptor.GhStockpile.Count==0)
                            {
                                <div class="text-muted small fst-italic">(empty)</div>
                            }
                            else
                            {
                                <div class="gh-list">
                                    @foreach (var e in emu!.Corruptor.GhStockpile.OrderByDescending(e=>e.Created).Take(20))
                                    {
                                        <div class="gh-item">
                                            <div class="gh-item-main">
                                                @if (emu!.GhIsRenaming(e.Id))
                                                {
                                                    <input class="form-control form-control-sm" style="min-width:120px" value="@emu!.Corruptor.GhRenameText" @onchange="emu!.GhRenameChange" />
                                                }
                                                else
                                                {
                                                    <span class="gh-name" title="@e.Name">@e.Name</span>
                                                }
                                                <span class="gh-meta">@e.Writes.Count w • @emu!.GhFindBaseName(e.BaseStateId)</span>
                                            </div>
                                            <div class="gh-actions btn-group btn-group-sm">
                                                <button class="btn btn-outline-light" title="Replay" @onclick="(()=>emu!.GhReplayEntryAsync(e, true))">▶</button>
                                                @if (emu!.GhIsRenaming(e.Id))
                                                {
                                                    <button class="btn btn-outline-success" title="Save" @onclick="(()=>emu!.GhCommitRename(e.Id))">✔</button>
                                                    <button class="btn btn-outline-warning" title="Cancel" @onclick="emu!.GhCancelRename">↺</button>
                                                }
                                                else
                                                {
                                                    <button class="btn btn-outline-info" title="Rename" @onclick="(()=>emu!.GhBeginRename(e))">✎</button>
                                                }
                                                <button class="btn btn-outline-danger" title="Delete" @onclick="(()=>emu!.GhDeleteStock(e.Id))">✕</button>
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    </div>
                }
            </div>
            }
        </div>
    </section>
    @if (!DisplayOnlyMode)
    {
    <aside class="side-panels">
    <details id="rom-manager-panel" class="panel-block" open>
        <summary>ROM Manager</summary>
        <div class="panel-content">
            <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                <input id="rom-search" type="text" class="form-control form-control-sm" placeholder="Search ROMs..." style="max-width:180px" @bind="emu!.RomSearch" @bind:event="oninput" />
                <button class="btn btn-sm btn-success" @onclick="(()=>emu!.TriggerRomImportDialogPublic())">Import</button>
                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.ReloadCurrentRomPublic())" disabled="@(string.IsNullOrEmpty(emu!.Controller.CurrentRomName))">Reload</button>
            </div>
            <div class="mb-2 small text-muted">Built-in + cached uploaded ROMs (persisted in browser storage). Click a row to load. Drag .nes files onto this list to import.</div>
            <div class="table-responsive" style="max-height:260px; overflow:auto;">
                <table id="rom-table" class="table table-sm table-dark align-middle mb-0 rom-table">
                    <thead class="table-secondary text-dark" style="position:sticky;top:0;">
                        <tr>
                            <th style="width:1%;"></th>
                            <th>Name</th>
                            <th style="width:90px;">Size</th>
                            <th style="width:80px;">Source</th>
                            <th style="width:70px;">Delete</th>
                        </tr>
                    </thead>
                    <tbody>
                        @if (!emu!.FilteredRomOptionsPublic.Any())
                        {
                            <tr><td colspan="5" class="text-center text-muted small">No ROMs match filter.</td></tr>
                        }
                        else
                        {
                            @foreach (var opt in emu!.FilteredRomOptionsPublic)
                            {
                                var isCurrent = opt.Key == emu!.Controller.CurrentRomName;
                                var sizeDisplay = emu!.Controller.GetRomSizeDisplay(opt.Key);
                                <tr class="@(isCurrent ? "table-primary" : "")" @onclick="(()=>emu!.OnRomRowClickedPublic(opt))">
                                    <td>@(isCurrent ? "▶" : "")</td>
                                    <td class="text-truncate" style="max-width:200px;" title="@opt.Key">@opt.Label</td>
                                    <td>@sizeDisplay</td>
                                    <td>@(opt.BuiltIn ? "Built-in" : "Uploaded")</td>
                                    <td><button class="btn btn-sm btn-outline-danger" @onclick:stopPropagation="true" @onclick="(()=>emu!.DeleteRomPublic(opt.Key))" disabled="@opt.BuiltIn">Del</button></td>
                                </tr>
                            }
                        }
                    </tbody>
                </table>
            </div>
            <div class="mt-2 small d-flex flex-wrap gap-3 text-muted">
                <div>Total: @emu!.FilteredRomOptionsPublic.Count() ROM(s)</div>
                <div>Uploaded: @emu!.Controller.UploadedRoms.Count</div>
                <div>Selected: @emu!.Controller.CurrentRomName</div>
            </div>
            <input @ref="fileInput" id="rom-upload" type="file" accept=".nes" class="d-none" @onchange="(()=>emu!.ImportRomsFromInputAsync(fileInput))" multiple />
        </div>
    </details>

    @if (emu!.RtcUnlocked && !HideRtcGhImagine)
    {
    <details id="corruptor-panel" class="panel-block corruptor-panel">
        <summary>Real-Time Corruptor</summary>
        <div class="panel-content corruptor-content">
            <div class="row g-3 flex-wrap">
                <div class="col-12 col-sm-5">
                    <label class="form-label small mb-1">Memory Domains</label>
                    <select multiple size="5" class="form-select form-select-sm">
                        @foreach (var d in emu!.Corruptor.MemoryDomains)
                        {
                            <option value="@d.Key" selected="@d.Selected">@d.Label (@d.Size)</option>
                        }
                    </select>
                    <div class="mt-2 small text-secondary">
                        Crash Mode:
                        <select class="form-select form-select-sm mt-1" @onchange="(e)=>emu!.SetCrashBehavior(e.Value?.ToString()??string.Empty)" value="@emu!.Corruptor.CrashBehavior">
                            <option value="RedScreen">Red Screen</option>
                            <option value="IgnoreErrors">Ignore Errors</option>
                            @if (emu!.ImagineUnlocked)
                            {
                                <option value="ImagineFix">Imagine Fix</option>
                            }
                        </select>
                        @if (emu!.ImagineUnlocked)
                        {
                            <div class="form-check form-switch mt-2">
                                <input class="form-check-input" type="checkbox" id="stubbornToggle" @onchange="(e)=>{ var val = (e.Value is bool b && b) || (e.Value is string sv && bool.TryParse(sv, out var p) && p); if (emu!.Corruptor.StubbornMode != val) emu!.SetStubbornMode(val); }" checked="@emu!.Corruptor.StubbornMode" />
                                <label class="form-check-label" for="stubbornToggle" title="When Imagine Fix is selected, keep retrying predictions periodically during freezes">Stubborn mode</label>
                            </div>
                        }
                    </div>
                </div>
                <div class="col-12 col-sm-7">
                    <div class="d-flex align-items-center justify-content-between mb-1">
                        <label class="form-label mb-0 small">Intensity</label>
                        <code class="small">@emu!.Corruptor.CorruptIntensity</code>
                    </div>
                    <input type="range" min="1" max="4096" step="1" class="form-range" value="@emu!.Corruptor.CorruptIntensity" @oninput="(e)=>{if(int.TryParse(e.Value?.ToString(),out var v)) emu!.Corruptor.CorruptIntensity = Math.Clamp(v,1,65535);}" />
                    <div class="d-flex gap-2 align-items-center mb-2 flex-wrap">
                        <input type="number" min="1" max="4096" class="form-control form-control-sm intensity-box" value="@emu!.Corruptor.CorruptIntensity" @onchange="(e)=>{if(int.TryParse(e.Value?.ToString(),out var v)) emu!.Corruptor.CorruptIntensity = Math.Clamp(v,1,65535);}" />
                        <button class="btn btn-sm btn-outline-danger" @onclick="(()=>emu!.BlastAsync())" disabled="@(emu!.Controller.nes==null || emu!.AutoCorrupt)" title="Apply one-time corruption now">Blast</button>
                        <button class="btn btn-sm @(emu!.AutoCorrupt ? "btn-success" : "btn-outline-success")" @onclick="(()=>emu!.ToggleAutoCorrupt())" title="Toggle auto-corruption each frame">Auto: @(emu!.AutoCorrupt ? "ON" : "OFF")</button>
                        @if (!emu!.Corruptor.LetItRipUsed)
                        {
                            <button class="btn btn-sm" style="background-color:#6f42c1;color:#fff;border-color:#6f42c1" @onclick="(()=>emu!.LetItRipPublic())" title="Intensity=1; select PRG ROM + System RAM; enable auto-corrupt; then hide button">Let it rip</button>
                        }
                    </div>
                    <div class="row g-2 small">
                        <div class="col-6">
                            <label class="form-label mb-1 small">Blast Type</label>
                            <select class="form-select form-select-sm" value="@emu!.BlastType" @onchange="(e)=>emu!.SetBlastTypePublic(e.Value?.ToString()??string.Empty)">
                                <option value="RANDOM">RANDOM</option>
                                <option value="TILT">TILT</option>
                                <option value="RANDOMTILT">RANDOMTILT</option>
                                <option value="NOP">NOP</option>
                                <option value="BITFLIP">BITFLIP</option>
                                @if (emu!.ImagineUnlocked)
                                {
                                    <option value="IMAGINENEXT">IMAGINE_NEXT</option>
                                    <option value="IMAGINERANDOM">IMAGINE_RANDOM</option>
                                }
                            </select>
                        </div>
                        <div class="col-6 small text-muted d-flex align-items-end">Random writes across selected domains.</div>
                    </div>
                    <div class="mt-2 small text-muted fst-italic">Last: @emu!.Corruptor.LastBlastInfo</div>
                </div>
            </div>
        </div>
    </details>
    }

    @if (emu!.GhUnlocked && !HideRtcGhImagine)
    {
    <details class="panel-block glitch-harvester-panel">
        <summary>Glitch Harvester</summary>
        <div class="panel-content glitch-harvester-content small">
            <div class="gh-section mb-3">
                <div class="d-flex flex-wrap gap-2 align-items-end">
                    <div class="flex-grow-1" style="min-width:140px;">
                        <label class="form-label mb-1 small">New Base Name</label>
                        <input class="form-control form-control-sm" placeholder="e.g. TitleScreen" @bind="emu!.Corruptor.GhNewBaseName" />
                    </div>
                    <button class="btn btn-sm btn-primary mt-3" @onclick="(()=>emu!.GhAddBase())" disabled="@(emu!.Controller.nes==null)">Add Base</button>
                </div>
                <div class="mt-2">
                    <label class="form-label mb-1 small">Base States</label>
                    <select class="form-select form-select-sm" size="4" @onchange="(e)=>emu!.GhOnBaseChangedPublic(e)" value="@emu!.Corruptor.GhSelectedBaseId">
                        @foreach (var b in emu!.Corruptor.GhBaseStates)
                        {
                            <option value="@b.Id">@b.Name</option>
                        }
                    </select>
                    <div class="d-flex gap-1 mt-2 flex-wrap">
                        <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.GhLoadSelected())" disabled="@(!emu!.GhHasSelectedBase)">Load</button>
                        <button class="btn btn-sm btn-outline-danger" @onclick="(()=>emu!.GhDeleteSelected())" disabled="@(!emu!.GhHasSelectedBase)">Delete</button>
                    </div>
                </div>
            </div>
            <div class="gh-section mb-3">
                <label class="form-label mb-1 small">Actions (uses Real-Time Corruptor settings)</label>
                <div class="d-flex gap-2 flex-wrap">
                    <button class="btn btn-sm btn-warning" @onclick="(()=>emu!.GhCorruptAndStashAsync())" disabled="@(!emu!.GhHasSelectedBase || emu!.Controller.nes==null)">Corrupt &amp; Stash</button>
                    <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.GhClearStashPublic())" disabled="@(emu!.Corruptor.GhStash.Count==0)">Clear Stash</button>
                </div>
            </div>
            <div class="gh-section mb-3">
                <div class="d-flex justify-content-between align-items-center mb-1">
                    <strong class="small mb-0">Stash History (@emu!.Corruptor.GhStash.Count)</strong>
                </div>
                @if (emu!.Corruptor.GhStash.Count==0)
                {
                    <div class="text-muted small fst-italic">(empty)</div>
                }
                else
                {
                    <div class="gh-list">
                        @foreach (var e in emu!.Corruptor.GhStash.OrderByDescending(e=>e.Created).Take(25))
                        {
                            <div class="gh-item">
                                <div class="gh-item-main">
                                    <span class="gh-name" title="@e.Name">@e.Name</span>
                                    <span class="gh-meta">@e.Writes.Count w @e.Created.ToLocalTime().ToString("HH:mm:ss")</span>
                                </div>
                                <div class="gh-actions btn-group btn-group-sm">
                                    <button class="btn btn-outline-light" title="Replay" @onclick="(()=>emu!.GhReplayEntryAsync(e, false))">▶</button>
                                    <button class="btn btn-outline-success" title="Keep (move to stockpile)" @onclick="(()=>emu!.GhPromote(e))">Keep</button>
                                    <button class="btn btn-outline-danger" title="Discard" @onclick="(()=>emu!.GhDeleteStash(e.Id))">✕</button>
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
            <div class="gh-section">
                <div class="d-flex justify-content-between align-items-center mb-1">
                    <strong class="small mb-0">Stockpile (@emu!.Corruptor.GhStockpile.Count)</strong>
                    <div class="d-flex gap-1">
                        <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.GhExportStockpileAsync())" disabled="@(emu!.Corruptor.GhStockpile.Count==0)">Export</button>
                        <label class="btn btn-sm btn-outline-secondary mb-0">
                            Import<input type="file" class="d-none" accept="application/json" @onchange="emu!.GhImportStockpile" />
                        </label>
                    </div>
                </div>
                @if (emu!.Corruptor.GhStockpile.Count==0)
                {
                    <div class="text-muted small fst-italic">(empty)</div>
                }
                else
                {
                    <div class="gh-list">
                        @foreach (var e in emu!.Corruptor.GhStockpile.OrderByDescending(e=>e.Created))
                        {
                            <div class="gh-item">
                                <div class="gh-item-main">
                                    @if (emu!.GhIsRenaming(e.Id))
                                    {
                                        <input class="form-control form-control-sm" style="min-width:120px" value="@emu!.Corruptor.GhRenameText" @onchange="emu!.GhRenameChange" />
                                    }
                                    else
                                    {
                                        <span class="gh-name" title="@e.Name">@e.Name</span>
                                    }
                                    <span class="gh-meta">@e.Writes.Count w • @emu!.GhFindBaseName(e.BaseStateId)</span>
                                </div>
                                <div class="gh-actions btn-group btn-group-sm">
                                    <button class="btn btn-outline-light" title="Replay" @onclick="(()=>emu!.GhReplayEntryAsync(e, true))">▶</button>
                                    @if (emu!.GhIsRenaming(e.Id))
                                    {
                                        <button class="btn btn-outline-success" title="Save name" @onclick="(()=>emu!.GhCommitRename(e.Id))">✔</button>
                                        <button class="btn btn-outline-warning" title="Cancel" @onclick="emu!.GhCancelRename">↺</button>
                                    }
                                    else
                                    {
                                        <button class="btn btn-outline-info" title="Rename" @onclick="(()=>emu!.GhBeginRename(e))">✎</button>
                                    }
                                    <button class="btn btn-outline-danger" title="Delete" @onclick="(()=>emu!.GhDeleteStock(e.Id))">✕</button>
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
        </div>
    </details>
    }

    @if (emu!.ImagineUnlocked && !HideRtcGhImagine)
    {
    <details class="panel-block imagine-panel">
        <summary>Imagine</summary>
        <div class="panel-content small">
            <div class="d-flex align-items-end gap-2 flex-wrap mb-2">
                <div>
                    <label class="form-label mb-1 small" for="imagine-epoch">Model epoch</label>
                    <input id="imagine-epoch" type="number" min="1" max="40" class="form-control form-control-sm" style="width:90px" @bind="emu!.ImagineEpoch" />
                </div>
                <button class="btn btn-sm btn-primary mt-3" @onclick="(()=>emu!.ImagineLoadModelAsyncPublic())">Load model</button>
            </div>
            <div class="small mb-2">
                @if (emu!.ImagineModelLoaded)
                {
                    <span class="badge bg-success">Loaded epoch @emu!.ImagineEpoch (@emu!.ImagineEpLabel)</span>
                }
                else if (!string.IsNullOrEmpty(emu!.ImagineLastError))
                {
                    <span class="badge bg-danger" title="@emu!.ImagineLastError">Load failed</span>
                }
                else
                {
                    <span class="text-muted">Model not loaded</span>
                }
            </div>
            <div class="row g-2 small mb-2">
                <div class="col-4 col-sm-4 col-md-3">
                    <label class="form-label mb-1">Bytes</label>
                    <input type="number" min="1" max="32" class="form-control form-control-sm" @bind="emu!.ImagineBytesToGenerate" />
                </div>
                <div class="col-4 col-sm-4 col-md-3">
                    <label class="form-label mb-1">Temp</label>
                    <input type="number" step="0.05" min="0" max="1.5" class="form-control form-control-sm" @bind="emu!.ImagineTemperature" />
                </div>
                <div class="col-4 col-sm-4 col-md-3">
                    <label class="form-label mb-1">TopK</label>
                    <input type="number" min="0" max="256" class="form-control form-control-sm" @bind-value="emu!.ImagineTopK" @bind-value:event="onchange" />
                    <div class="form-text">0 or empty = off</div>
                </div>
            </div>
            <div class="d-flex gap-2 flex-wrap">
                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.OpenImagineModal())" disabled="@(!emu!.ImagineModelLoaded)">Debug</button>
                <button class="btn btn-sm btn-outline-warning" @onclick="(()=>emu!.ImagineBugAsync())" disabled="@(!emu!.ImagineModelLoaded || emu!.ImagineBusy)">@(emu!.ImagineBusy?"Working…":"Imagine a bug")</button>
            </div>
            @if (emu!.ImagineModalOpen)
            {
                <div class="modal-backdrop" style="position:fixed;inset:0;background:#000b;display:flex;align-items:flex-start;justify-content:center;z-index:5000;">
                    <div class="card shadow-lg" style="max-width:720px;width:95%;margin-top:2.5rem;">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong class="small mb-0">Imagine Debug</strong>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-outline-primary" @onclick="(()=>emu!.FreezeAndFetchNextInstructionAsync())" disabled="@emu!.ImagineBusy">Freeze and fetch next instruction</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.CloseImagineModal())">Close</button>
                            </div>
                        </div>
                        <div class="card-body small" style="max-height:80vh;overflow:auto;">
                            @if (emu!.ImagineSnapshot == null)
                            {
                                <div class="text-muted fst-italic">Click "Freeze and fetch next instruction" to capture CPU state.</div>
                            }
                            else
                            {
                                var s = emu!.ImagineSnapshot;
                                <div class="mb-2 d-flex flex-wrap gap-3">
                                    <div>CPU: @s!.CpuCoreId</div>
                                    <div>PC: @($"0x{s.PC:X4}")</div>
                                    <div>A: @($"0x{s.A:X2}")</div>
                                    <div>X: @($"0x{s.X:X2}")</div>
                                    <div>Y: @($"0x{s.Y:X2}")</div>
                                    <div>P: @($"0x{s.P:X2}")</div>
                                    <div>SP: @($"0x{s.SP:X4}")</div>
                                    <div>IRQ: @(s.IRQ?"1":"0")</div>
                                    <div>NMI: @(s.NMI?"1":"0")</div>
                                    <div>PRG ROM: @(s.InPrgRom?"YES":"NO")</div>
                                </div>
                                @if (!s!.InPrgRom)
                                {
                                    <div class="alert alert-warning py-1 px-2 small">PC is not in PRG ROM ($8000-$FFFF); address is invalid for PRG fetch.</div>
                                }
                                else
                                {
                                    <div class="mb-2">
                                        <div class="text-muted">8 bytes before target (PC-8 .. PC-1)</div>
                                        <code>@(string.Join(" ", s.Prev8.Select(b=>b.ToString("X2"))))</code>
                                    </div>
                                    <div class="mb-2">
                                        <div class="text-muted">Next 16 bytes (PC .. PC+15)</div>
                                        <code>@(string.Join(" ", s.Next16.Select(b=>b.ToString("X2"))))</code>
                                    </div>
                                    <div class="row g-2 mb-2">
                                        <div class="col-4 col-sm-4 col-md-3">
                                            <label class="form-label mb-1">Bytes</label>
                                            <input type="number" min="1" max="32" class="form-control form-control-sm" @bind="emu!.ImagineBytesToGenerate" />
                                        </div>
                                        <div class="col-4 col-sm-4 col-md-3">
                                            <label class="form-label mb-1">Temp</label>
                                            <input type="number" step="0.05" min="0" max="1.5" class="form-control form-control-sm" @bind="emu!.ImagineTemperature" />
                                        </div>
                                        <div class="col-4 col-sm-4 col-md-3">
                                            <label class="form-label mb-1">TopK</label>
                                            <input type="number" min="0" max="256" class="form-control form-control-sm" @bind-value="emu!.ImagineTopK" @bind-value:event="onchange" />
                                        </div>
                                    </div>
                                    <div class="d-flex gap-2 mb-2">
                                        <button class="btn btn-sm btn-warning" @onclick="(()=>emu!.ImagineRunPredictionTestAsync())" disabled="@(!emu!.ImagineModelLoaded || emu!.ImagineBusy)">Run prediction (test)</button>
                                        <button class="btn btn-sm btn-success" @onclick="(()=>emu!.ImagineApplyPatchHereAsync())" disabled="@((emu!.ImaginePredictedBytes==null||emu!.ImaginePredictedBytes.Length==0)|| !emu!.ImagineModelLoaded || emu!.ImagineBusy)">Apply patch here</button>
                                    </div>
                                    @if (emu!.ImaginePredictedBytes != null && emu!.ImaginePredictedBytes.Length > 0)
                                    {
                                        <div class="mb-1">Predicted bytes (@emu!.ImaginePredictedBytes.Length):</div>
                                        <code>@(string.Join(" ", emu!.ImaginePredictedBytes.Select(b=>b.ToString("X2"))))</code>
                                    }
                                }
                            }
                        </div>
                    </div>
                </div>
            }
        </div>
    </details>
    }

    <details class="panel-block">
        <summary>Controls</summary>
        <div class="panel-content small">
            @if (emu!.InputSettingsPublic == null)
            {
                <div class="text-muted">Loading input settings…</div>
            }
            else
            {
                var s = emu!.InputSettingsPublic;
                <div class="mb-1"><strong>Player 1</strong> (@s!.Player1.Device)</div>
                @if (s!.Player1.Device == InputDeviceType.Keyboard)
                {
                    <div class="key-grid">
                        <div>@s.Player1.Keyboard.Up: Up</div>
                        <div>@s.Player1.Keyboard.Down: Down</div>
                        <div>@s.Player1.Keyboard.Left: Left</div>
                        <div>@s.Player1.Keyboard.Right: Right</div>
                        <div>@s.Player1.Keyboard.B: B</div>
                        <div>@s.Player1.Keyboard.A: A</div>
                        <div>@s.Player1.Keyboard.Select: Select</div>
                        <div>@s.Player1.Keyboard.Start: Start</div>
                    </div>
                }
                else if (s.Player1.Device == InputDeviceType.Gamepad)
                {
                    <div>Gamepad [@s.Player1.GamepadIndex]: A=@s.Player1.Gamepad.A, B=@s.Player1.Gamepad.B, Select=@s.Player1.Gamepad.Select, Start=@s.Player1.Gamepad.Start</div>
                }
                else
                {
                    <div>Touch controller (mobile fullscreen)</div>
                }
                <hr />
                <div class="mb-1"><strong>Player 2</strong> (@s.Player2.Device)</div>
                @if (s.Player2.Device == InputDeviceType.Keyboard)
                {
                    <div class="key-grid">
                        <div>@s.Player2.Keyboard.Up: Up</div>
                        <div>@s.Player2.Keyboard.Down: Down</div>
                        <div>@s.Player2.Keyboard.Left: Left</div>
                        <div>@s.Player2.Keyboard.Right: Right</div>
                        <div>@s.Player2.Keyboard.B: B</div>
                        <div>@s.Player2.Keyboard.A: A</div>
                        <div>@s.Player2.Keyboard.Select: Select</div>
                        <div>@s.Player2.Keyboard.Start: Start</div>
                    </div>
                }
                else if (s.Player2.Device == InputDeviceType.Gamepad)
                {
                    <div>Gamepad [@s.Player2.GamepadIndex]: A=@s.Player2.Gamepad.A, B=@s.Player2.Gamepad.B, Select=@s.Player2.Gamepad.Select, Start=@s.Player2.Gamepad.Start</div>
                }
                else
                {
                    <div>Touch controller (mobile fullscreen)</div>
                }
            }
            <div class="mt-2"><a class="opt-link" href="./input">Configure Input…</a></div>
        </div>
    </details>

    @if (emu!.DebugUnlocked)
    {
        <details class="panel-block">
        <summary>Debug</summary>
        <div class="panel-content debug-mini">
            <div>Frames: @emu!.Controller.FrameCount</div>
            <div>ROM Loaded: @(emu!.Controller.nes != null ? "Yes" : "No")</div>
            <div><button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.DumpStateAsyncPublic())" disabled="@(emu!.Controller.nes==null)">Dump State</button></div>
            <div class="mt-2">
                <button class="btn btn-sm btn-outline-primary" @onclick="(()=>emu!.OpenBenchmarks())" disabled="@(emu!.Controller.nes==null)">@(emu!.BenchRunning?"Running...":"Run Benchmarks")</button>
                <button class="btn btn-sm btn-outline-info ms-1" @onclick="(()=>emu!.OpenComparison())" disabled="@(emu!.BenchHistory.Count()<2)">Compare Results</button>
                <div class="form-check form-switch mt-2 small">
                    <input class="form-check-input" type="checkbox" id="evtSchedToggle" @bind="emu!.EventSchedulerOn" disabled="@(emu!.Controller.nes==null)" />
                    <label class="form-check-label" for="evtSchedToggle" title="Experimental: event-driven CPU->PPU/APU scheduling (scanline prototype)">Event Scheduler</label>
                </div>
                <div class="form-check form-switch mt-2 small">
                    <input class="form-check-input" type="checkbox" id="sfToggle" @onchange="(e)=>{if(emu!.SoundFontMode != (e.Value is bool b && b || (e.Value is string sv && bool.TryParse(sv,out var p) && p))) emu!.ToggleSoundFontModePublic();}" checked="@emu!.SoundFontMode" disabled="@(emu!.Controller.nes==null)" />
                    <label class="form-check-label" for="sfToggle" title="Play APU via WebAudio SoundFont/oscillators instead of raw PCM">SoundFont Mode</label>
                </div>
                @if (emu!.SoundFontMode == true)
                {
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfSampleToggle" @onchange="(e)=>{if(emu!.SampleFont != (e.Value is bool b && b || (e.Value is string sv && bool.TryParse(sv,out var p) && p))) emu!.ToggleSampleFontPublic();}" checked="@emu!.SampleFont" />
                        <label class="form-check-label" for="sfSampleToggle" title="Use external sampled SoundFont library (falls back to oscillators if unavailable)">Sampled Instruments</label>
                    </div>
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfLayerToggle" @onchange="async (e)=>{ if(emu!.SoundFontLayering != (e.Value is bool b && b || (e.Value is string sv && bool.TryParse(sv,out var p) && p))) await emu!.ToggleSoundFontLayeringPublic(); }" checked="@emu!.SoundFontLayering" />
                        <label class="form-check-label" for="sfLayerToggle" title="Experimental: allow both MNES & WF SoundFont cores to process notes simultaneously (debug/compare)">Layering</label>
                    </div>
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfDevLogToggle" @onchange="(e)=>{if(emu!.SfDevLogging != (e.Value is bool b && b || (e.Value is string sv && bool.TryParse(sv,out var p) && p))) emu!.ToggleSfDevLoggingPublic();}" checked="@emu!.SfDevLogging" />
                        <label class="form-check-label" for="sfDevLogToggle" title="Verbose console logs for SoundFont core routing & throttling">SF Dev Logging</label>
                    </div>
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfOverlayToggle" @onchange="(e)=>{if(emu!.SfOverlay != (e.Value is bool b && b || (e.Value is string sv && bool.TryParse(sv,out var p) && p))) emu!.ToggleSfOverlayPublic();}" checked="@emu!.SfOverlay" />
                        <label class="form-check-label" for="sfOverlayToggle" title="Display on-screen SoundFont diagnostics overlay (lead ms, counters)">SF Overlay</label>
                    </div>
                    <div class="mt-2 d-flex flex-wrap gap-2">
                        <button class="btn btn-sm btn-outline-warning" @onclick="(()=>emu!.FlushSoundFontPublic())" title="Force immediate silence of inactive/active SoundFont synths">SF Flush</button>
                            <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.ShowSfDebugPublic())" title="Log SoundFont routing counters to console">SF Debug</button>
                    </div>
                }
            </div>
            @if (emu!.BenchModalOpen)
            {
                <div class="modal-backdrop" style="position:fixed;inset:0;background:#000b;display:flex;align-items:flex-start;justify-content:center;z-index:5000;">
                    <div class="card shadow-lg" style="max-width:960px;width:95%;margin-top:2.5rem;">
                        <div class="card-header d-flex flex-wrap gap-2 justify-content-between align-items-center">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <strong class="small mb-0">Benchmarks</strong>
                                <span class="badge rounded-pill bg-dark text-light small">@emu!.BenchHistory.Count() saved</span>
                                <div class="input-group input-group-sm" style="width:60px;">
                                    <span class="input-group-text">W</span>
                                    <input type="number" min="1" max="9" class="form-control" style="padding-left:2px;padding-right:2px;font-size:.65rem;" @bind="emu!.BenchWeight" />
                                </div>
                                <div class="btn-group btn-group-sm" role="group" aria-label="Benchmark options" style="gap:2px;">
                                    <button type="button" class="btn @(emu!.BenchAutoLoadState?"btn-primary":"btn-outline-primary")" style="font-size:.60rem;padding:2px 4px;line-height:1.1;" @onclick="(()=>emu!.ToggleBenchAutoLoadState())" title="Load baseline savestate before each run">Auto</button>
                                    <button type="button" class="btn @(emu!.BenchSimple5x?"btn-primary":"btn-outline-primary")" style="font-size:.60rem;padding:2px 4px;line-height:1.1;" @onclick="(()=>emu!.ToggleBenchSimpleMode())" title="5× shows only averaged results">5×Avg</button>
                                </div>
                                @if (emu!.BenchRunning)
                                {
                                    <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
                                }
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-outline-primary" @onclick="(()=>emu!.RunBenchmarks5xAsync())" disabled="@(emu!.Controller.nes==null || emu!.BenchRunning)" title="Run 5 benchmark passes (reloads baseline each)" aria-label="Run five benchmark passes">@(emu!.BenchRunning?"Running...":"Run 5×")</button>
                                <button class="btn btn-sm btn-outline-primary" @onclick="(()=>emu!.RunBenchmarksAsync())" disabled="@(emu!.Controller.nes==null || emu!.BenchRunning)">@(emu!.BenchRunning?"Running...":$"Run {emu!.BenchWeight}x")</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.CloseBenchmarks())" aria-label="Close">Close</button>
                            </div>
                        </div>
                        <div class="card-body" style="max-height:80vh;overflow:auto;">
                            <div class="mb-4">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <h6 class="small text-uppercase text-muted mb-0">Current Run</h6>
                                    @if (!string.IsNullOrEmpty(emu!.BenchResultsText))
                                    {
                                        <button class="btn btn-sm btn-outline-success" title="Copy results" @onclick="(()=>emu!.CopyBenchResultsAsync())">Copy</button>
                                    }
                                </div>
                                @if (string.IsNullOrEmpty(emu!.BenchResultsText))
                                {
                                    <div class="small fst-italic text-muted">@(emu!.BenchRunning?"Running benchmarks...":"No run yet this session. Click 'Run Again'.")</div>
                                }
                                else
                                {
                                    <pre class="small mb-0" style="white-space:pre;">@emu!.BenchResultsText</pre>
                                }
                            </div>
                            <div class="d-flex justify-content-between align-items-center mb-2 mt-2">
                                <h6 class="small text-uppercase text-muted mb-0">History</h6>
                                <div class="btn-group btn-group-sm">
                                    <button class="btn btn-outline-danger" title="Clear all benchmark history" @onclick="(()=>emu!.ClearBenchHistoryAsync())" disabled="@(emu!.BenchHistory.Count()==0)">Clear</button>
                                </div>
                            </div>
                            @if (emu!.BenchHistory.Count()==0)
                            {
                                <div class="small text-muted fst-italic">(no previous runs saved)</div>
                            }
                            else
                            {
                                <table class="table table-sm table-dark align-middle small mb-0" style="--bs-table-bg:#1e1e1e;">
                                    <thead class="table-secondary text-dark">
                                        <tr>
                                            <th style="width:1%;">#</th>
                                            <th style="min-width:130px;">When</th>
                                            <th style="min-width:160px;">ROM</th>
                                            <th style="width:140px;">Cores</th>
                                            <th style="width:1%;">View</th>
                                            <th style="width:1%;">Del</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                    @foreach (var (entry,idx) in emu!.BenchHistory.Select((e,i)=>(e,i)))
                                    {
                                        <tr class="@(emu!.CurrentBenchHistoryId==entry.Id?"table-primary":"")">
                                            <td>@(idx+1)</td>
                                            <td title="UTC: @entry.TimestampUtc.ToString("u")">@entry.TimestampUtc.ToLocalTime().ToString("HH:mm:ss")</td>
                                            <td class="text-truncate" style="max-width:220px;" title="@entry.Rom">
                                                @if (emu!.EditingBenchRomId == entry.Id)
                                                {
                                                    <input class="form-control form-control-sm" style="min-width:160px;font-size:.65rem;padding:.15rem .25rem;" @bind="emu!.EditingBenchRomValue" @onkeydown="(e)=>emu!.HandleBenchRomEditKeyPublic(e, entry.Id)" @onblur="(()=>emu!.CommitBenchRomEditPublic(entry.Id))" />
                                                }
                                                else
                                                {
                                                    <span class="d-inline-block text-truncate" style="max-width:220px; cursor:text;" @onclick="(()=>emu!.StartBenchRomEditPublic(entry.Id))" title="Click to edit note">@entry.Rom</span>
                                                }
                                            </td>
                                            <td class="text-nowrap" title="CPU @entry.CpuCore / PPU @entry.PpuCore / APU @entry.ApuCore">@entry.CpuCore/@entry.PpuCore/@entry.ApuCore</td>
                                            <td><button class="btn btn-sm btn-outline-light" @onclick="(()=>emu!.ShowHistoryEntryToggle(entry.Id))" title="View results">@(emu!.CurrentBenchHistoryId==entry.Id?"▾":"▶")</button></td>
                                            <td><button class="btn btn-sm btn-outline-danger" @onclick="(()=>emu!.DeleteBenchEntryAsync(entry.Id))" title="Delete this entry">✕</button></td>
                                        </tr>
                                        @if (emu!.CurrentBenchHistoryId==entry.Id)
                                        {
                                            <tr class="table-secondary text-dark"><td colspan="6"><pre class="small mb-0" style="white-space:pre-wrap;max-height:320px;overflow:auto;">@entry.Display</pre></td></tr>
                                        }
                                    }
                                    </tbody>
                                </table>
                            }
                        </div>
                    </div>
                </div>
            }
            @if (emu!.CompareModalOpen)
            {
                <div class="modal-backdrop" style="position:fixed;inset:0;background:#000b;display:flex;align-items:flex-start;justify-content:center;z-index:5000;">
                    <div class="card shadow-lg" style="max-width:1100px;width:98%;margin-top:2rem;">
                        <div class="card-header d-flex flex-wrap gap-2 justify-content-between align-items-center">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <strong class="small mb-0">Benchmark Comparison</strong>
                                <span class="badge bg-dark small">@emu!.BenchHistory.Count() total</span>
                                <span class="small text-muted">(oldest on left in charts)</span>
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.PlayDiffAnimationAsync())" disabled="@(emu!.DiffAnimating || emu!.RecentDiffRows.Count()==0)">@((emu!.DiffAnimating?"Playing...":"Play Diff"))</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.CloseComparison())">Close</button>
                            </div>
                        </div>
                        <div class="card-body" style="max-height:85vh;overflow:auto;">
                            @if (emu!.RecentDiffRows.Count()==0)
                            {
                                <div class="small text-muted fst-italic">Need at least two benchmark entries with structured metrics.</div>
                            }
                            else
                            {
                                <h6 class="small text-uppercase text-muted">Latest vs Previous</h6>
                                <div class="mb-2 small text-muted">Below: numeric diff table. A future update will render a side-by-side frame playback of the two benchmark runs for visual comparison.</div>
                                <div class="table-responsive mb-3">
                                    <table class="table table-sm table-dark align-middle small mb-0" style="--bs-table-bg:#1e1e1e;">
                                        <thead class="table-secondary text-dark">
                                            <tr>
                                                <th>Target</th>
                                                <th title="Current ms per iteration">Cur ms/iter</th>
                                                <th title="Prev ms per iteration">Prev ms/iter</th>
                                                <th title="Delta ms (negative is faster)">Δ ms</th>
                                                <th title="Percent change (negative is faster)">Δ %</th>
                                                <th title="CPU Reads delta">Reads Δ</th>
                                                <th title="CPU Writes delta">Writes Δ</th>
                                                <th title="APU Cycles delta">APU Δ</th>
                                                <th title="OAM DMA Writes delta">OAM Δ</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                        @foreach (var row in emu!.RecentDiffRows)
                                        {
                                            var cls = emu!.HighlightMetricName==row.Name?"table-primary":"";
                                            <tr class="@cls">
                                                <td>@row.Name</td>
                                                <td>@row.CurMs.ToString("F3")</td>
                                                <td>@row.PrevMs.ToString("F3")</td>
                                                <td class="@(row.DeltaMs<0?"text-success":row.DeltaMs>0?"text-danger":"")">@row.DeltaMs.ToString("F3")</td>
                                                <td class="@(row.DeltaPct<0?"text-success":row.DeltaPct>0?"text-danger":"")">@row.DeltaPct.ToString("F2")%</td>
                                                <td class="@(row.ReadsDelta<0?"text-success":row.ReadsDelta>0?"text-danger":"")">@row.ReadsDelta</td>
                                                <td class="@(row.WritesDelta<0?"text-success":row.WritesDelta>0?"text-danger":"")">@row.WritesDelta</td>
                                                <td class="@(row.ApuDelta<0?"text-success":row.ApuDelta>0?"text-danger":"")">@row.ApuDelta</td>
                                                <td class="@(row.OamDelta<0?"text-success":row.OamDelta>0?"text-danger":"")">@row.OamDelta</td>
                                            </tr>
                                        }
                                        </tbody>
                                    </table>
                                </div>
                            }
                            <div class="d-flex justify-content-between align-items-center mt-4 mb-1">
                                <h6 class="small text-uppercase text-muted mb-0">Timeline (@(emu!.CompareNormalize?"% of range":"ms/iter"))</h6>
                                <div class="form-check form-switch small">
                                    <input class="form-check-input" type="checkbox" id="cmpNorm" @bind="emu!.CompareNormalize" />
                                    <label class="form-check-label" for="cmpNorm">Normalize</label>
                                </div>
                            </div>
                            @if (emu!.TimelineSeries.Count==0)
                            {
                                <div class="small text-muted fst-italic">No timeline data.</div>
                            }
                            else
                            {
                                <div class="d-flex flex-wrap gap-3 mb-2">
                                    @foreach (var s in emu!.AllTargets)
                                    {
                                        <label class="form-check-label small me-2">
                                            <input type="checkbox" class="form-check-input me-1" @onchange="(()=>emu!.ToggleTargetVisibility(s))" checked="@emu!.VisibleTargets.Contains(s)" /> @s
                                        </label>
                                    }
                                </div>
                                <div style="overflow:auto; position:relative;" @onmouseleave="(()=>emu!.OnTimelineMouseLeave())">
                                    <svg width="1000" height="240" style="background:#111;border:1px solid #333;" @onmousemove="emu!.OnTimelineMouseMove">
                                        @if (emu!.VisibleTargets.Count()>0)
                                        {
                                            double globalMax = 0;
                                            foreach (var t in emu!.VisibleTargets)
                                                foreach (var v in emu!.TimelineSeries[t])
                                                    if (!double.IsNaN(v.MsPerIter) && v.MsPerIter > globalMax) globalMax = v.MsPerIter;
                                            if (globalMax<=0) { globalMax = 1; }
                                            var count = emu!.TimelineOrder.Count;
                                            var plotW = 960.0; var plotH = 200.0; var left=30; var top=20;
                                            // axes
                                            <line x1="@left" y1="@(top)" x2="@left" y2="@(top+plotH)" stroke="#555" stroke-width="1" />
                                            <line x1="@left" y1="@(top+plotH)" x2="@(left+plotW)" y2="@(top+plotH)" stroke="#555" stroke-width="1" />
                                            // y labels
                                            @if (!emu!.CompareNormalize) {
                                                for (int i=0;i<=4;i++){
                                                    var yVal = globalMax*i/4.0; var y = top+plotH - (yVal/globalMax)*plotH;
                                                    @:<text x="5" y="@(y+4)" font-size="9" fill="#888">@yVal.ToString("F2")</text>
                                                    <line x1="@left" y1="@y" x2="@(left+plotW)" y2="@y" stroke="#222" stroke-width="1" />
                                                }
                                            } else {
                                                for (int i=0;i<=4;i++){
                                                    var yPct = i*25; var y = top+plotH - (i/4.0)*plotH;
                                                    @:<text x="5" y="@(y+4)" font-size="9" fill="#888">@yPct%</text>
                                                    <line x1="@left" y1="@y" x2="@(left+plotW)" y2="@y" stroke="#222" stroke-width="1" />
                                                }
                                            }
                                            // x labels
                                            @for (int i=0;i<count;i++){
                                                var x = left + plotW*(i/(double)Math.Max(1,count-1)); var label = emu!.TimelineOrder[i].ToLocalTime().ToString("HH:mm:ss");
                                                @:<text x="@x" y="@(top+plotH+12)" font-size="8" fill="#666" text-anchor="middle">@label</text>
                                                <line x1="@x" y1="@(top+plotH)" x2="@x" y2="@(top+plotH+4)" stroke="#444" stroke-width="1" />
                                            }
                                            // series lines
                                            @foreach (var t in emu!.VisibleTargets)
                                            {
                                                var color = emu!.GetColorForTarget(t);
                                                double minT = double.MaxValue; double maxT = double.MinValue;
                                                if (emu!.CompareNormalize){
                                                    foreach (var v in emu!.TimelineSeries[t]){ if (!double.IsNaN(v.MsPerIter)){ if (v.MsPerIter<minT) minT=v.MsPerIter; if (v.MsPerIter>maxT) maxT=v.MsPerIter; } }
                                                    if (minT==double.MaxValue){ minT=0; maxT=1; }
                                                    if (Math.Abs(maxT-minT) < 1e-9) { maxT = minT + 1; }
                                                }
                                                var pts = string.Join(' ', emu!.TimelineSeries[t].Select((v,idx)=>{
                                                    var x = left + plotW*(idx/(double)Math.Max(1,count-1));
                                                    double normVal;
                                                    if (emu!.CompareNormalize){
                                                        if (double.IsNaN(v.MsPerIter)) normVal = 0; else normVal = (v.MsPerIter - minT)/(maxT-minT); // 0..1
                                                        var y = top+plotH - normVal*plotH; return $"{x:F1},{y:F1}";
                                                    } else {
                                                        var y = top+plotH - (v.MsPerIter/globalMax)*plotH; return $"{x:F1},{y:F1}";
                                                    }
                                                }));
                                                <polyline points="@pts" fill="none" stroke="@color" stroke-width="2" />
                                            }
                                            @if (emu!.HoverIndex.HasValue && emu!.HoverIndex.Value>=0 && emu!.HoverIndex.Value < count && emu!.HoverPointTooltipData != null)
                                            {
                                                var idx = emu!.HoverIndex.Value;
                                                var hoverX = left + plotW*(idx/(double)Math.Max(1,count-1));
                                                <line x1="@hoverX" y1="@top" x2="@hoverX" y2="@(top+plotH)" stroke="#666" stroke-dasharray="3 3" stroke-width="1" />
                                                foreach (var t in emu!.VisibleTargets)
                                                {
                                                    var pt = emu!.TimelineSeries[t][idx]; if (double.IsNaN(pt.MsPerIter)) continue;
                                                    double minT = double.MaxValue; double maxT = double.MinValue;
                                                    if (emu!.CompareNormalize){
                                                        foreach (var v in emu!.TimelineSeries[t]){ if(!double.IsNaN(v.MsPerIter)){ if (v.MsPerIter<minT) minT=v.MsPerIter; if (v.MsPerIter>maxT) maxT=v.MsPerIter; } }
                                                        if (minT==double.MaxValue){ minT=0; maxT=1; }
                                                        if (Math.Abs(maxT-minT) < 1e-9) { maxT = minT + 1; }
                                                    }
                                                    double y;
                                                    if (emu!.CompareNormalize){
                                                        var normVal = (pt.MsPerIter - minT)/(maxT-minT);
                                                        y = top+plotH - normVal*plotH;
                                                    } else {
                                                        y = top+plotH - (pt.MsPerIter/globalMax)*plotH;
                                                    }
                                                    var color = emu!.GetColorForTarget(t);
                                                    var r = emu!.HoverTarget == t ? 5 : 3;
                                                    <circle cx="@hoverX" cy="@y" r="@r" fill="@color" stroke="#000" stroke-width="1" />
                                                }
                                                // Inline tooltip box (fixed near top-left of plot)
                                                var tooltipData = emu!.HoverPointTooltipData;
                                                var boxX = left + 5; var boxY = top + 5; var lineH = 11; var lines = new List<string>{ $"{tooltipData?.TimeLabel}", $"ROM: {tooltipData?.Rom}", $"CPU {tooltipData?.CpuCore} | PPU {tooltipData?.PpuCore} | APU {tooltipData?.ApuCore}", $"{tooltipData?.Target}: {tooltipData?.MsPerIter:F3} ms/iter", $"R {tooltipData?.Reads} W {tooltipData?.Writes}", $"APU {tooltipData?.ApuCycles} OAM {tooltipData?.OamWrites}"};
                                                var boxW = 160.0; foreach(var l in lines){ boxW = Math.Max(boxW, 12 + l.Length * 6.0); }
                                                var boxH = lines.Count * lineH + 6;
                                                <rect x="@boxX" y="@boxY" width="@boxW" height="@boxH" fill="#222" stroke="#555" stroke-width="1" rx="4" />
                                                {
                                                    // Razor reserves <text>; build SVG text elements manually
                                                    var sbTxt = new System.Text.StringBuilder();
                                                    for (int i=0;i<lines.Count;i++)
                                                    {
                                                        var txt = lines[i]; var ty = boxY + 4 + (i+1)*lineH - 3; string fill; if (i==0) fill="#fff"; else if (i==1) fill="#9cf"; else if (i==2) fill="#bbb"; else fill="#ddd";
                                                        sbTxt.Append($"<text x='{boxX+4}' y='{ty}' font-size='10' fill='{fill}'>{txt}</text>");
                                                    }
                                                    @((MarkupString)sbTxt.ToString())
                                                }
                                            }
                                        }
                                    </svg>
                                </div>
                            }
                        </div>
                    </div>
                </div>
            }
            @if (!string.IsNullOrEmpty(emu!.DebugDumpText))
            {
                <div class="small text-monospace" style="white-space:pre-wrap;max-width:260px">@emu!.DebugDumpText</div>
            }
        </div>
    </details>
    }
    </aside>
    }
</div>

@* Core Picker Modal *@
@if (CorePickerOpen)
{
    <div class="cp-modal-backdrop" @onclick="CloseCorePicker">
        <div class="cp-modal" @onclick:stopPropagation>
            <div class="cp-header">
                <strong class="small mb-0">Select @CorePickerTitle</strong>
                <button class="btn btn-sm btn-outline-secondary" @onclick="CloseCorePicker">Close</button>
            </div>
            <div class="cp-body">
                @if (CorePickerItems.Count == 0)
                {
                    <div class="text-muted small fst-italic">No options available.</div>
                }
                else
                {
                    <div class="list-grid">
                        @foreach (var it in CorePickerItems)
                        {
                            <div class="core-row-wrap">
                                <button type="button" class="core-row" title="Select" @onclick="(()=>OnCorePicked(it.Id))">
                                    <span class="row-left">
                                        <span class="pill pill-id @PillRateClass(it.Rating)">@it.Id</span>
                                    </span>
                                    <span class="row-main">@it.DisplayName</span>
                                    <span class="row-meta">
                                        <span class="meta-badge @CategoryClass(it.Category)">@(!string.IsNullOrWhiteSpace(it.Category)?it.Category:CorePickerDomain)</span>
                                        <span class="meta-perf @PerfClass(it.Performance)" title="Performance">@it.Performance</span>
                                        <span class="meta-stars" title="Rating">@RenderStars(it.Rating)</span>
                                    </span>
                                </button>
                                <button type="button" class="btn btn-sm view-btn" title="View" @onclick:stopPropagation="true" @onclick="(()=>OpenPreviewCard(it))">View</button>
                            </div>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
}

@* Card preview overlay on top of the picker *@
@if (PickerPreviewCard != null)
{
    <div class="card-modal-backdrop" style="z-index:11000;" @onclick="ClosePreviewCard">
        <div class="card-modal-content" @onclick="ClosePreviewCard">
            @((MarkupString)CardSvgRenderer.Render(PickerPreviewCard))
        </div>
    </div>
}

@code {
    private Emulator? emu;
    private ElementReference fileInput;
    // Stage/Display modes & query overrides
    private bool StageMode = false;
    private bool DisplayOnlyMode = false;
    private bool HideRtcGhImagine => StageMode || DisplayOnlyMode;
    private bool HideCoreSelectors => StageMode || DisplayOnlyMode;
    private bool? SavestatesAllowedOverride = null; // null = no override
    private bool ShowSavestates => emu != null && emu.SavestatesUnlocked && (SavestatesAllowedOverride ?? true);
    private string? QRom;
    private string? QShader;
    private string? QCpu;
    private string? QPpu;
    private string? QApu;
    private string? QClock;
    private string? QCoresAll;
    private string? QScript; // optional JS to run post-load (stage mode only)
    private string? QScriptFile; // optional JS file to load & execute (stage mode only)
    private string? QScriptUrl;  // optional JS URL to load & execute (stage mode only)
    
    // Core picker modal state
    private bool CorePickerOpen = false;
    private string CorePickerDomain = string.Empty; // CPU/PPU/APU/CLOCK/SHADER
    private readonly List<PickerItem> CorePickerItems = new();
    private string CorePickerTitle => CorePickerDomain switch { "CPU" => "CPU Core", "PPU" => "PPU Core", "APU" => "APU Core", "CLOCK" => "Clock", "SHADER" => "Shader", _ => "Core" };

    // Cached metadata
    private bool _coreMetaReady = false;
    private CoreCardModel? PickerPreviewCard;
    private List<PickerItem> _cpuMeta = new();
    private List<PickerItem> _ppuMeta = new();
    private List<PickerItem> _apuMeta = new();
    private List<PickerItem> _clockMeta = new();
    private List<PickerItem> _shaderMeta = new();

    protected override void OnInitialized()
    {
        if (emu == null)
        {
            emu = new Emulator(Logger, JS, Http, Status, ShaderProvider, Nav, InputSettingsService, GameSaveService)
            {
                OnStateChanged = () => InvokeAsync(StateHasChanged)
            };
            emu.Initialize();
        }
        // Parse query params for stage/display and overrides
        try
        {
            var uri = new Uri(Nav.Uri);
            // Manual, WASM-safe query parser
            var q = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            var query = uri.Query;
            if (!string.IsNullOrEmpty(query))
            {
                var span = query.AsSpan();
                if (span.Length > 0 && span[0] == '?') span = span[1..];
                foreach (var part in span.ToString().Split('&', StringSplitOptions.RemoveEmptyEntries))
                {
                    var kv = part.Split('=', 2);
                    if (kv.Length > 0 && kv[0].Length > 0)
                    {
                        var key = Uri.UnescapeDataString(kv[0]);
                        var val = kv.Length > 1 ? Uri.UnescapeDataString(kv[1]) : string.Empty;
                        q[key] = val;
                    }
                }
            }
            bool GetBool(string key)
            {
                if (!q.TryGetValue(key, out var v) || string.IsNullOrWhiteSpace(v)) return false;
                return v == "1" || v.Equals("true", StringComparison.OrdinalIgnoreCase) || v.Equals("yes", StringComparison.OrdinalIgnoreCase);
            }
            string? GetStr(string key) => q.TryGetValue(key, out var v) ? v : null;
            StageMode = GetBool("stage") || string.Equals(GetStr("mode"), "stage", StringComparison.OrdinalIgnoreCase);
            DisplayOnlyMode = GetBool("displayOnly") || string.Equals(GetStr("mode"), "displayonly", StringComparison.OrdinalIgnoreCase);
            var ss = GetStr("savestates");
            if (!string.IsNullOrWhiteSpace(ss)) SavestatesAllowedOverride = (ss == "1" || ss.Equals("true", StringComparison.OrdinalIgnoreCase));
            QRom = GetStr("rom");
            QShader = GetStr("shader");
            QCpu = GetStr("cpu");
            QPpu = GetStr("ppu");
            QApu = GetStr("apu");
            QClock = GetStr("clock");
            QCoresAll = GetStr("cores");
            QScript = GetStr("script");
            QScriptFile = GetStr("scriptFile");
            QScriptUrl = GetStr("scriptUrl");
            // If cores=* provided, apply to all 3 unless specific overrides also provided
            if (!string.IsNullOrWhiteSpace(QCoresAll))
            {
                if (string.IsNullOrWhiteSpace(QCpu)) QCpu = QCoresAll;
                if (string.IsNullOrWhiteSpace(QPpu)) QPpu = QCoresAll;
                if (string.IsNullOrWhiteSpace(QApu)) QApu = QCoresAll;
            }
            // Pre-set ROM if provided so initial load uses it
            if (!string.IsNullOrWhiteSpace(QRom))
            {
                emu.Controller.RomFileName = QRom!;
            }
        }
        catch { }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Fully unload the global animated background while in emulator view
            try { await JS.InvokeVoidAsync("eval", @"(function(){
                if(window.homePixelBg && window.homePixelBg.stop) window.homePixelBg.stop();
                var host = document.getElementById('pixelBgHost');
                if(host) { host.innerHTML=''; }
            })();"); } catch { }
            if (emu != null)
            {
                try { await JS.InvokeVoidAsync("nesInterop.ensureAudioContext"); } catch { }
                try { await JS.InvokeVoidAsync("nesInterop.applySavedAudioVolumes"); } catch { }
                                // Register a helper to force modal card SVG to fill viewport (used by picker preview)
                                try { await JS.InvokeVoidAsync("eval", @"(function(){
                                    window.nesUi = window.nesUi || {};
                                    window.nesUi.zoomModalSvg = function(){
                                        try{
                                            var host = document.querySelector('.card-modal-content');
                                            if(!host) return;
                                            var svg = host.querySelector('svg');
                                            if(!svg) return;
                                            svg.removeAttribute('width');
                                            svg.removeAttribute('height');
                                            svg.style.width = '100vw';
                                            svg.style.maxWidth = '100vw';
                                            svg.style.height = 'auto';
                                            svg.style.maxHeight = (window.visualViewport ? window.visualViewport.height : window.innerHeight) + 'px';
                                            svg.style.display = 'block';
                                        }catch(e){}
                                    };
                                })();"); } catch { }
                await emu.EnsureInitialRenderAsync(true);
                // Mark options as ready so pickers can render if eligible
                _pickerOptionsReady = true;
                try { await InvokeAsync(StateHasChanged); } catch { }
            }
        }

                // When the preview card is shown, ensure the SVG is zoomed to viewport once
                if (PickerPreviewCard != null && !_pickerZoomInit)
                {
                        _pickerZoomInit = true;
                        try { await JS.InvokeVoidAsync("nesUi.zoomModalSvg"); } catch { }
                }
        // After initial emulator init, apply any query overrides (shader/cores)
                if (firstRender && emu != null)
        {
            try
            {
                if (!string.IsNullOrWhiteSpace(QShader)) await emu.SetShaderPublic(QShader!);
                if (!string.IsNullOrWhiteSpace(QCpu)) await emu.SetCpuCorePublic(QCpu!);
                if (!string.IsNullOrWhiteSpace(QPpu)) await emu.SetPpuCorePublic(QPpu!);
                if (!string.IsNullOrWhiteSpace(QApu)) await emu.SetApuCorePublic(QApu!);
                if (!string.IsNullOrWhiteSpace(QClock)) await emu.SetClockCorePublic(QClock!);
                if (!string.IsNullOrWhiteSpace(QRom))
                {
                    await emu.LoadSelectedRomPublic();
                }
                // Execute optional stage script after emulator/ROM init
                if (StageMode)
                {
                    // Prefer external file/url if provided; fallback to inline script
                    var src = !string.IsNullOrWhiteSpace(QScriptUrl) ? QScriptUrl : QScriptFile;
                    if (!string.IsNullOrWhiteSpace(src))
                    {
                        try
                        {
                            var code = await Http.GetStringAsync(src);
                            if (!string.IsNullOrWhiteSpace(code))
                            {
                                try { await JS.InvokeVoidAsync("eval", code); } catch { }
                            }
                        }
                        catch { }
                    }
                    else if (!string.IsNullOrWhiteSpace(QScript))
                    {
                        try { await JS.InvokeVoidAsync("eval", QScript); } catch { }
                    }
                }
                                // Gently reveal the emulator: fade-out and remove Story blackout overlay
                                try { await JS.InvokeVoidAsync("eval", @"(function(){
                                        try{
                                            var ov = document.getElementById('storyFadeOverlay');
                                            if(ov){
                                                // ensure it sits above just for the fade, then disappear
                                                if(!ov.style.transition || ov.style.transition.indexOf('opacity')<0){ ov.style.transition='opacity .9s ease'; }
                                                ov.style.opacity = '0';
                                                setTimeout(function(){ try{ ov.parentNode && ov.parentNode.removeChild(ov); }catch(e){} }, 980);
                                            }
                                        }catch(e){}
                                })();"); } catch { }
            }
            catch { }
        }
    }

    public void Dispose()
    {
        try
        {
            emu?.Dispose();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error disposing NES emulator");
        }
    }

    private void OpenCorePicker(string domain)
    {
        if (emu == null) return;
        CorePickerDomain = domain;
        CorePickerItems.Clear();
        EnsureCoreMeta();
        switch (domain)
        {
            case "CPU":
                {
                    var allowed = new HashSet<string>(emu.Controller.CpuCoreOptions, StringComparer.OrdinalIgnoreCase);
                    CorePickerItems.AddRange(_cpuMeta.Where(m => allowed.Contains(m.Id)));
                }
                break;
            case "PPU":
                {
                    var allowed = new HashSet<string>(emu.Controller.PpuCoreOptions, StringComparer.OrdinalIgnoreCase);
                    CorePickerItems.AddRange(_ppuMeta.Where(m => allowed.Contains(m.Id)));
                }
                break;
            case "APU":
                {
                    var allowed = new HashSet<string>(emu.Controller.ApuCoreOptions, StringComparer.OrdinalIgnoreCase);
                    CorePickerItems.AddRange(_apuMeta.Where(m => allowed.Contains(m.Id)));
                }
                break;
            case "CLOCK":
                {
                    var allowed = new HashSet<string>(emu.Controller.ClockCoreOptions, StringComparer.OrdinalIgnoreCase);
                    CorePickerItems.AddRange(_clockMeta.Where(m => allowed.Contains(m.Id)));
                }
                break;
            case "SHADER":
                {
                    var allowed = new HashSet<string>(emu.Controller.ShaderOptions.Select(s=>s.Key), StringComparer.OrdinalIgnoreCase);
                    CorePickerItems.AddRange(_shaderMeta.Where(m => allowed.Contains(m.Id)));
                }
                break;
        }
        ApplyPickerSort();
        CorePickerOpen = true;
    }

    private void CloseCorePicker()
    {
        CorePickerOpen = false;
        CorePickerDomain = string.Empty;
        CorePickerItems.Clear();
    }

    // Wrapper methods for Razor
    private void OpenShaderPicker() => OpenCorePicker("SHADER");
    private void OpenCpuPicker() => OpenCorePicker("CPU");
    private void OpenPpuPicker() => OpenCorePicker("PPU");
    private void OpenApuPicker() => OpenCorePicker("APU");
    private void OpenClockPicker() => OpenCorePicker("CLOCK");

    private async Task OnCorePicked(string id)
    {
        if (emu == null) return;
        try
        {
            switch (CorePickerDomain)
            {
                case "CPU":
                    emu.SetCpuCorePublic(id);
                    break;
                case "PPU":
                    emu.SetPpuCorePublic(id);
                    break;
                case "APU":
                    emu.SetApuCorePublic(id);
                    break;
                case "CLOCK":
                    emu.SetClockCorePublic(id);
                    break;
                case "SHADER":
                    emu.SetShaderPublic(id);
                    break;
            }
        }
        catch { }
        finally
        {
            CloseCorePicker();
            await InvokeAsync(StateHasChanged);
        }
    }

    private void OpenPreviewCard(PickerItem it)
    {
        // Build a CoreCardModel from metadata
        PickerPreviewCard = new CoreCardModel
        {
            Id = it.Id,
            ShortName = it.Id,
            DisplayName = it.DisplayName,
            Description = it.Description,
            Rating = Math.Clamp(it.Rating, 0, 5),
            Performance = it.Performance,
            FooterNote = string.IsNullOrWhiteSpace(it.Category) ? it.Domain : it.Category,
            Domain = it.Domain
        };
    _pickerZoomInit = false; // allow zoom on next render
    }

    private void ClosePreviewCard()
    {
        PickerPreviewCard = null;
    _pickerZoomInit = false;
    }

    private string GetCurrentShaderLabel()
    {
        try
        {
            var cur = emu!.Controller.ActiveShaderKey;
            var match = emu!.Controller.ShaderOptions.FirstOrDefault(s => s.Key == cur);
            return match?.Label ?? cur;
        }
        catch { return emu?.Controller.ActiveShaderKey ?? ""; }
    }

    private void EnsureCoreMeta()
    {
        if (_coreMetaReady) return;
        try
        {
            // Minimal valid iNES ROM (NROM-128: 1x16KB PRG, 0 CHR)
            var dummy = new byte[16 + 16 * 1024];
            dummy[0] = 0x4E; dummy[1] = 0x45; dummy[2] = 0x53; dummy[3] = 0x1A;
            dummy[4] = 1; dummy[5] = 0; dummy[6] = 0; dummy[7] = 0;
            var cart = new Cartridge(dummy);
            var bus = new Bus(cart);

            var cpuDict = CoreRegistry.CreateInstances<ICPU>(bus, "CPU_");
            _cpuMeta = cpuDict.Select(kv => new PickerItem
            {
                Domain = "CPU",
                Id = kv.Key,
                DisplayName = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
                Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
                Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
                Rating = Math.Clamp(SafeGetStruct(() => kv.Value.Rating) ?? 0, 0, 5),
                Category = SafeGet(() => kv.Value.Category) ?? ""
            }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

            var ppuDict = CoreRegistry.CreateInstances<IPPU>(bus, "PPU_");
            _ppuMeta = ppuDict.Select(kv => new PickerItem
            {
                Domain = "PPU",
                Id = kv.Key,
                DisplayName = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
                Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
                Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
                Rating = Math.Clamp(SafeGetStruct(() => kv.Value.Rating) ?? 0, 0, 5),
                Category = SafeGet(() => kv.Value.Category) ?? ""
            }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

            var apuDict = CoreRegistry.CreateInstances<IAPU>(bus, "APU_");
            _apuMeta = apuDict.Select(kv => new PickerItem
            {
                Domain = "APU",
                Id = kv.Key,
                DisplayName = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
                Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
                Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
                Rating = Math.Clamp(SafeGetStruct(() => kv.Value.Rating) ?? 0, 0, 5),
                Category = SafeGet(() => kv.Value.Category) ?? ""
            }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

            _clockMeta = new List<PickerItem>();
            foreach (var id in ClockRegistry.Ids)
            {
                try
                {
                    var clk = ClockRegistry.Create(id);
                    if (clk != null)
                    {
                        _clockMeta.Add(new PickerItem
                        {
                            Domain = "CLOCK",
                            Id = id,
                            DisplayName = clk.DisplayName,
                            Description = clk.Description,
                            Performance = clk.Performance,
                            Rating = Math.Clamp(clk.Rating, 0, 5),
                            Category = SafeGet(() => clk.Category) ?? ""
                        });
                    }
                }
                catch { }
            }
            _clockMeta = _clockMeta.OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

            _shaderMeta = new List<PickerItem>();
            try
            {
                // Build provider lookup for metadata (by IShader)
                var prov = new Dictionary<string, IShader>(StringComparer.OrdinalIgnoreCase);
                try { foreach (var s in ShaderProvider.All) prov[s.Id] = s; } catch { }

                // Prefer labels from controller options (user-facing Core Name)
                foreach (var opt in emu!.Controller.ShaderOptions)
                {
                    var id = opt.Key;
                    var label = opt.Label ?? id;
                    prov.TryGetValue(id, out var meta);
                    string? cat = null;
                    try { if (meta?.Defines != null && meta.Defines.TryGetValue("Category", out var c)) cat = c; } catch { }
                    _shaderMeta.Add(new PickerItem
                    {
                        Domain = "SHADER",
                        Id = id,
                        // Prefer CoreName from provider for the card long name; fallback to controller label
                        DisplayName = (meta != null ? (SafeGet(() => meta.CoreName) ?? meta.DisplayName) : null) ?? label,
                        Description = meta?.Description ?? string.Empty,
                        Performance = meta?.Performance ?? 0,
                        Rating = Math.Clamp(meta?.Rating ?? 0, 0, 5),
                        Category = cat ?? string.Empty
                    });
                }
                // Fallback: include any provider shaders not present in options (defensive)
                foreach (var s in prov.Values)
                {
                    if (_shaderMeta.Any(m => string.Equals(m.Id, s.Id, StringComparison.OrdinalIgnoreCase))) continue;
                    string? cat = null;
                    try { if (s.Defines != null && s.Defines.TryGetValue("Category", out var c)) cat = c; } catch { }
                    _shaderMeta.Add(new PickerItem
                    {
                        Domain = "SHADER",
                        Id = s.Id,
                        DisplayName = s.DisplayName ?? s.Id,
                        Description = s.Description ?? string.Empty,
                        Performance = s.Performance,
                        Rating = Math.Clamp(s.Rating, 0, 5),
                        Category = cat ?? string.Empty
                    });
                }
                _shaderMeta = _shaderMeta.OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();
            }
            catch { }
        }
        catch { }
        _coreMetaReady = true;
    }

    private void ApplyPickerSort()
    {
        if (CorePickerItems.Count <= 1) return;
        if (string.Equals(CorePickerDomain, "SHADER", StringComparison.OrdinalIgnoreCase))
        {
            CorePickerItems.Sort((a,b)=>
            {
                int ap = string.Equals(a.Id, "PX", StringComparison.OrdinalIgnoreCase) ? 0 : 1;
                int bp = string.Equals(b.Id, "PX", StringComparison.OrdinalIgnoreCase) ? 0 : 1;
                int cmp = ap.CompareTo(bp);
                if (cmp != 0) return cmp;
                return string.Compare(a.DisplayName, b.DisplayName, StringComparison.OrdinalIgnoreCase);
            });
        }
        else
        {
            CorePickerItems.Sort((a,b)=>
            {
                int ap = string.Equals(a.Id, "FMC", StringComparison.OrdinalIgnoreCase) ? 0 : 1;
                int bp = string.Equals(b.Id, "FMC", StringComparison.OrdinalIgnoreCase) ? 0 : 1;
                int cmp = ap.CompareTo(bp);
                if (cmp != 0) return cmp;
                return string.Compare(a.DisplayName, b.DisplayName, StringComparison.OrdinalIgnoreCase);
            });
        }
    }

    private static string PillRateClass(int rating)
    {
        var r = Math.Clamp(rating, 0, 5);
        return $"pill-rate-{r}";
    }

    private static string CategoryClass(string? category)
    {
        if (string.IsNullOrWhiteSpace(category)) return "cat-col-0";
        unchecked
        {
            int hash = 0;
            foreach (var ch in category)
            {
                hash = (hash * 31) + char.ToLowerInvariant(ch);
            }
            int idx = Math.Abs(hash) % 8; // 8 color buckets
            return $"cat-col-{idx}";
        }
    }

    private static string RenderStars(int rating)
    {
        var r = Math.Clamp(rating, 0, 5);
        return new string('\u2605', r) + new string('\u2606', 5 - r);
    }

    private static string PerfClass(int perf)
    {
        if (perf > 0) return "perf-pos";
        if (perf < 0) return "perf-neg";
        return string.Empty;
    }

    private static T? SafeGet<T>(Func<T> getter)
    {
        try { return getter(); } catch { return default; }
    }

    private static T? SafeGetStruct<T>(Func<T> getter) where T : struct
    {
        try { return getter(); } catch { return null; }
    }

    private sealed class PickerItem
    {
        public string Domain { get; set; } = string.Empty;
        public string Id { get; set; } = string.Empty;
        public string DisplayName { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public int Performance { get; set; }
        public int Rating { get; set; }
        public string Category { get; set; } = string.Empty;
    }

    // One-shot guard to run zoom script when preview opens
    private bool _pickerZoomInit = false;

    // Visibility helpers: show pickers only when >1 option is available
    private bool _pickerOptionsReady = false;
    private bool ShowCpuPicker => _pickerOptionsReady && (emu?.Controller.CpuCoreOptions?.Count ?? 0) > 1;
    private bool ShowPpuPicker => _pickerOptionsReady && (emu?.Controller.PpuCoreOptions?.Count ?? 0) > 1;
    private bool ShowApuPicker => _pickerOptionsReady && (emu?.Controller.ApuCoreOptions?.Count ?? 0) > 1;
    private bool ShowClockPicker => _pickerOptionsReady && (emu?.Controller.ClockCoreOptions?.Count ?? 0) > 1;
    private bool ShowShaderPicker => _pickerOptionsReady && (emu?.Controller.ShaderOptions?.Count() ?? 0) > 1;
}

