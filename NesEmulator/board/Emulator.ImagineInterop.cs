using System;
using System.Linq;
using System.Collections.Generic;
using BrokenNes.CorruptorModels;
using System.Threading.Tasks;

namespace BrokenNes
{
    public partial class Emulator
    {
        private sealed class JsPredictRequest
        {
            public int[] window { get; set; } = Array.Empty<int>();
            public int holeStart { get; set; }
            public int holeEnd { get; set; }
            public double temperature { get; set; }
            public int? topK { get; set; }
        }

        private sealed class JsPredictResponse
        {
            public int[] bytes { get; set; } = Array.Empty<int>();
        }

        /// <summary>
        /// Core API: Load imagine model for an epoch. Returns true on success and records EP label.
        /// </summary>
        public async Task<bool> ImagineLoadModelAsync(int epoch)
        {
            try
            {
                ImagineLastError = string.Empty;
                var res = await JS.InvokeAsync<JsLoadModelResult>("imagine.loadModel", new object?[] { epoch });
                if (res != null && res.ok)
                {
                    ImagineEpoch = epoch;
                    ImagineModelLoaded = true;
                    ImagineEpLabel = res.info ?? string.Empty;
                    return true;
                }
                ImagineModelLoaded = false; ImagineEpLabel = string.Empty;
                ImagineLastError = res?.error ?? "Unknown error";
                return false;
            }
            catch (Exception ex)
            {
                ImagineModelLoaded = false; ImagineEpLabel = string.Empty; ImagineLastError = ex.Message;
                return false;
            }
            finally { StateHasChanged(); }
        }

        /// <summary>
        /// Core API: Call JS predictor with a prepared 128-token window and hole span. Returns generated bytes.
        /// </summary>
        public async Task<byte[]> ImaginePredictSpanAsync(int[] tokens128, int holeStart, int holeEnd, float temperature, int? topK)
        {
            if (tokens128 == null || tokens128.Length != 128) throw new ArgumentException("tokens128 must be length 128");
            if (holeStart < 0 || holeStart >= 128) throw new ArgumentOutOfRangeException(nameof(holeStart));
            if (holeEnd <= holeStart || holeEnd > 128) throw new ArgumentOutOfRangeException(nameof(holeEnd));
            if (!ImagineModelLoaded) throw new InvalidOperationException("Imagine model not loaded");

            var req = new JsPredictRequest
            {
                window = tokens128.ToArray(),
                holeStart = holeStart,
                holeEnd = holeEnd,
                temperature = Math.Clamp(temperature, 0.0, 1.5),
                topK = (topK.HasValue && topK.Value <= 0) ? null : topK
            };
            try
            {
                var res = await JS.InvokeAsync<JsPredictResponse>("imagine.predictSpan", new object?[]{ req });
                var arr = res?.bytes ?? Array.Empty<int>();
                var bytes = new byte[arr.Length];
                for (int i = 0; i < arr.Length; i++) bytes[i] = (byte)Math.Clamp(arr[i], 0, 255);
                return bytes;
            }
            catch (Exception ex)
            {
                ImagineLastError = ex.Message; StateHasChanged();
                throw;
            }
        }

        /// <summary>
        /// Build a 128-length token window centered around PC where possible; mask [PC..PC+holeLen) with 256.
        /// Returns tokens and outputs holeStart/holeEnd indices into the window.
        /// </summary>
        public int[] BuildTokens128AroundPc(ushort pc, int holeLen, out int holeStart, out int holeEnd)
        {
            holeStart = 0; holeEnd = 0;
            if (nes == null) throw new InvalidOperationException("NES not initialized");
            if (pc < 0x8000 || pc > 0xFFFF) throw new InvalidOperationException("PC not in PRG ROM ($8000..$FFFF)");
            int L = Math.Clamp(holeLen, 1, 32);
            // Clamp to end-of-address-space safety
            int remain = 0x10000 - pc; if (L > remain) L = remain;
            // Choose a base so that PC is near the middle but ensure full [PC..PC+L) within window
            int start = pc - 64;
            if (start < 0x8000) start = 0x8000;
            // Ensure hole fits fully
            if (pc + L - start > 128) start = pc + L - 128;
            if (start < 0x8000) start = 0x8000;
            if (start > 0xFFFF - 127) start = 0xFFFF - 127;

            var tokens = new int[128];
            for (int i = 0; i < 128; i++)
            {
                ushort addr = (ushort)(start + i);
                byte v = nes.PeekCpu(addr);
                bool inHole = addr >= pc && addr < pc + L;
                tokens[i] = inHole ? 256 : (int)v;
            }
            holeStart = pc - start;
            holeEnd = holeStart + L;
            return tokens;
        }

        /// <summary>
        /// Best-effort translation of a CPU address ($8000-$FFFF) to a PRG ROM index by content matching.
        /// 1) Fast-path NROM/fixed mapping check.
        /// 2) Fallback: scan PRG ROM for the longest forward match starting at the same byte value.
        /// Returns true if a unique/best candidate is found.
        /// </summary>
    private bool TryCpuToPrgIndexByContent(ushort addr, out int prgIndex)
        {
            prgIndex = -1;
            if (nes == null) return false;
            if (addr < 0x8000 || addr > 0xFFFF) return false;

            int prgSize = nes.GetPrgRomSize();
            if (prgSize <= 0) return false;

            // Fast path: simple mapping (NROM-style) where PRG is fixed at $8000..$FFFF
            int simpleIdx = addr - 0x8000;
            if (simpleIdx >= 0 && simpleIdx < prgSize)
            {
                byte cpuB = nes.PeekCpu(addr);
                byte prgB = nes.PeekPrg(simpleIdx);
                if (cpuB == prgB)
                {
                    // Validate a short lookahead to reduce false positives
                    int look = Math.Min(16, Math.Min(0x10000 - addr, prgSize - simpleIdx));
                    int ok = 0;
                    for (int i = 1; i < look; i++)
                    {
                        if (nes.PeekCpu((ushort)(addr + i)) != nes.PeekPrg(simpleIdx + i)) break;
                        ok++;
                    }
                    if (ok >= 3) { prgIndex = simpleIdx; return true; }
                }
            }

            // Fallback: content-based search. Anchor on current byte, then extend greedily.
            byte anchor = nes.PeekCpu(addr);
            var candidates = new List<int>(16);

            // Gather candidate offsets where PRG byte equals anchor
            for (int i = 0; i < prgSize; i++)
            {
                if (nes.PeekPrg(i) == anchor) candidates.Add(i);
            }
            if (candidates.Count == 0) return false;

            // Score candidates by forward match length (up to 32 bytes cap)
            int bestIdx = -1; int bestScore = -1;
            int cap = Math.Min(32, 0x10000 - addr);
            foreach (var c in candidates)
            {
                int maxForward = Math.Min(cap, prgSize - c);
                if (maxForward <= 0) continue;
                int score = 0;
                for (int k = 1; k < maxForward; k++)
                {
                    if (nes.PeekCpu((ushort)(addr + k)) != nes.PeekPrg(c + k)) break;
                    score++;
                }
                if (score > bestScore)
                {
                    bestScore = score; bestIdx = c;
                    if (bestScore >= 16) break; // good enough, stop early
                }
            }
            if (bestIdx >= 0)
            {
                prgIndex = bestIdx; return true;
            }
            return false;
        }

        /// <summary>
        /// Patch predicted bytes into PRG ROM domain using mapper-agnostic content-based CPUâ†’PRG translation.
        /// Returns true if applied; false if any address in the span cannot be mapped.
        /// </summary>
        public Task<bool> ApplyImaginePatchAsync(ushort pc, byte[] bytes)
        {
            if (nes == null || bytes == null || bytes.Length == 0) return Task.FromResult(false);
            if (pc < 0x8000 || pc > 0xFFFF) return Task.FromResult(false);
        try
            {
                var writes = new List<BlastInstruction>(bytes.Length);
                for (int i = 0; i < bytes.Length; i++)
                {
                    ushort addr = (ushort)(pc + i);
            // Prefer mapper-aware mapping when available.
            if (!(nes.TryCpuToPrgIndex(addr, out int prgIdx) || TryCpuToPrgIndexByContent(addr, out prgIdx)))
                    {
                        // Abort if any byte can't be mapped confidently
                        return Task.FromResult(false);
                    }
                    writes.Add(new BlastInstruction { Domain = "PRG", Address = prgIdx, Value = bytes[i] });
                }

                // Apply writes
                foreach (var w in writes)
                {
                    nes.PokePrg(w.Address, (byte)w.Value);
                }

                // Record stash entry with richer metadata
                try
                {
                    string name = $"Imagine PC={pc:X4} L={bytes.Length} E{ImagineEpoch} T={ImagineTemperature:0.00} K={(ImagineTopK.HasValue?ImagineTopK.Value:0)}";
                    Corruptor.GhStash.Add(new HarvestEntry
                    {
                        Name = name,
                        Created = DateTime.UtcNow,
                        Writes = writes
                    });
                }
                catch { }

                return Task.FromResult(true);
            }
            catch { return Task.FromResult(false); }
        }
    }
}
