using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace BrokenNes.Tools.Shaders.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class ShaderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var additional = context.AdditionalTextsProvider
            .Where(a => a.Path.Replace('\\','/').Contains("/Shaders/") && a.Path.EndsWith(".glsl", StringComparison.OrdinalIgnoreCase));

        var compile = additional.Collect();
        context.RegisterSourceOutput(compile, (spc, files) => Emit(spc, files));
    }

    private static void Emit(SourceProductionContext spc, ImmutableArray<AdditionalText> files)
    {
        if (files.IsDefaultOrEmpty) return;
        // Group by base name (strip .vert/.frag suffix)
        var groups = new Dictionary<string, ShaderParts>(StringComparer.OrdinalIgnoreCase);
        foreach (var f in files)
        {
            var path = f.Path.Replace('\\','/');
            var name = System.IO.Path.GetFileName(path);
            var text = f.GetText();
            if (text is null) continue;
            var src = text.ToString();
            var (key, kind) = Classify(name);
            if (!groups.TryGetValue(key, out var parts)) { parts = new ShaderParts(key); groups[key] = parts; }
            if (kind == Part.Fragment)
            {
                parts.FragmentFilesCount++;
                if (parts.Fragment is null)
                {
                    // Parse metadata from the first fragment encountered
                    ParseMetadata(src,
                        out var displayName,
                        out var category,
                        out var coreName,
                        out var description,
                        out var performance,
                        out var rating);
                    parts.DisplayName = displayName;
                    parts.Category = category;
                    parts.CoreName = coreName;
                    parts.Description = description;
                    parts.Performance = performance;
                    parts.Rating = rating;
                    parts.Fragment = src;
                }
            }
            else if (kind == Part.Vertex)
            {
                parts.VertexFilesCount++;
                if (parts.Vertex is null)
                {
                    parts.Vertex = src;
                }
            }
        }

    var ns = "NesEmulator.Shaders.Generated";
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine($"namespace {ns};");
    sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
    var idsSb = new StringBuilder();
    idsSb.AppendLine("public static class ShaderIds {");
    foreach (var kv in groups.OrderBy(k => k.Key, StringComparer.Ordinal))
        {
            var id = kv.Key;
            var cls = ToClassName(id) + "Shader";
            var parts = kv.Value;
            // Duplicate detection
            if (parts.FragmentFilesCount > 1)
            {
                spc.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                    id: "BNES002",
                    title: "Duplicate fragment shader id",
                    messageFormat: "Shader '{0}' has multiple .frag.glsl files; ensure unique filenames or directories",
                    category: "Shaders",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true), Location.None, id));
                continue;
            }
            if (parts.VertexFilesCount > 1)
            {
                spc.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                    id: "BNES003",
                    title: "Duplicate vertex shader id",
                    messageFormat: "Shader '{0}' has multiple .vert.glsl files; ensure unique filenames or directories",
                    category: "Shaders",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true), Location.None, id));
                continue;
            }
            if (string.IsNullOrWhiteSpace(parts.Fragment))
            {
                spc.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                    id: "BNES001",
                    title: "Missing fragment shader",
                    messageFormat: "Shader '{0}' is missing a .frag.glsl file",
                    category: "Shaders",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true), Location.None, id));
                continue;
            }
            var constName = ToConstName(id);
            idsSb.AppendLine($"    public const string {constName} = \"{id}\";");
            sb.AppendLine($"[global::NesEmulator.Shaders.ShaderDefinition]");
            sb.AppendLine($"public sealed class {cls} : global::NesEmulator.Shaders.IShader {{");
            sb.AppendLine($"    public string Id => \"{id}\";");
            var displayName = string.IsNullOrWhiteSpace(parts.DisplayName) ? id : parts.DisplayName!;
            sb.AppendLine($"    public string DisplayName => \"{Verbatim(displayName)}\";");
            // Core metadata from parsed header with safe defaults
            var coreName = string.IsNullOrWhiteSpace(parts.CoreName) ? "UNIMPLEMENTED" : parts.CoreName!;
            var description = string.IsNullOrWhiteSpace(parts.Description) ? "UNIMPLEMENTED" : parts.Description!;
            var perf = parts.Performance ?? 0;
            var rating = parts.Rating ?? 1;
            sb.AppendLine($"    public string CoreName => \"{Verbatim(coreName)}\";");
            sb.AppendLine($"    public string Description => \"{Verbatim(description)}\";");
            sb.AppendLine($"    public int Performance => {perf};");
            sb.AppendLine($"    public int Rating => {rating};");
            if (parts.Vertex is null) sb.AppendLine("    public string? VertexSource => null;");
            else sb.AppendLine($"    public string? VertexSource => @\"{Verbatim(parts.Vertex)}\";");
            sb.AppendLine($"    public string FragmentSource => @\"{Verbatim(parts.Fragment!)}\";");
            if (!string.IsNullOrWhiteSpace(parts.Category))
            {
                sb.AppendLine("    public System.Collections.Generic.IReadOnlyDictionary<string,string>? Defines => new System.Collections.Generic.Dictionary<string,string> { { \"Category\", \"" + Verbatim(parts.Category!) + "\" } };");
            }
            else
            {
                sb.AppendLine("    public System.Collections.Generic.IReadOnlyDictionary<string,string>? Defines => null;");
            }
            sb.AppendLine("}");
        }
    idsSb.AppendLine("}");
    spc.AddSource("Shaders.g.cs", SourceText.From(sb.ToString() + idsSb.ToString(), Encoding.UTF8));
    }

    private static (string key, Part part) Classify(string filename)
    {
        var name = System.IO.Path.GetFileNameWithoutExtension(filename);
        var part = Part.Fragment;
        if (name.EndsWith(".vert", StringComparison.OrdinalIgnoreCase))
        {
            part = Part.Vertex;
            name = name.Substring(0, name.Length - 5);
        }
        else if (name.EndsWith(".frag", StringComparison.OrdinalIgnoreCase))
        {
            part = Part.Fragment;
            name = name.Substring(0, name.Length - 5);
        }
        return (name, part);
    }

    private enum Part { Vertex, Fragment }

    private sealed class ShaderParts
    {
        public ShaderParts(string id) { Id = id; }
        public string Id { get; }
        public string? Vertex { get; set; }
        public string? Fragment { get; set; }
        public int VertexFilesCount { get; set; }
        public int FragmentFilesCount { get; set; }
    public string? DisplayName { get; set; }
    public string? CoreName { get; set; }
    public string? Description { get; set; }
    public int? Performance { get; set; }
    public int? Rating { get; set; }
        public string? Category { get; set; }
    }

    private static string Verbatim(string s)
        => s.Replace("\"", "\"\"");

    private static string ToClassName(string id)
    {
        var sb = new StringBuilder(id.Length + 8);
        // Prefix if first char isn't a letter or underscore
        if (id.Length == 0 || !(char.IsLetter(id[0]) || id[0] == '_')) sb.Append('S');
        foreach (var ch in id)
        {
            if (char.IsLetterOrDigit(ch)) sb.Append(ch);
            else sb.Append('_');
        }
        return sb.ToString();
    }

    private static string ToConstName(string id)
    {
        var sb = new StringBuilder(id.Length + 8);
        sb.Append("SHADER_");
        foreach (var ch in id)
        {
            if (char.IsLetterOrDigit(ch)) sb.Append(char.ToUpperInvariant(ch));
            else sb.Append('_');
        }
        return sb.ToString();
    }

    private static void ParseMetadata(
        string source,
        out string? displayName,
        out string? category,
        out string? coreName,
        out string? description,
        out int? performance,
        out int? rating)
    {
        displayName = null;
        category = null;
        coreName = null;
        description = null;
        performance = null;
        rating = null;

        // Parse only the leading comment block(s)
        using var reader = new System.IO.StringReader(source);
        string? line;
        bool inBlock = false;
        while ((line = reader.ReadLine()) is not null)
        {
            var trimmed = line.TrimStart();
            if (!inBlock && trimmed.StartsWith("/*"))
            {
                inBlock = true;
            }
            if (!(trimmed.StartsWith("//") || inBlock))
            {
                // Stop at first non-comment line when not in a block comment
                break;
            }

            // Normalize block comment lines by stripping leading /*, */, and *
            string work = trimmed;
            if (inBlock)
            {
                if (work.StartsWith("/*")) work = work.Substring(2);
                if (work.StartsWith("*")) work = work.Substring(1);
                if (work.Contains("*/"))
                {
                    var endIdx = work.IndexOf("*/", StringComparison.Ordinal);
                    work = work.Substring(0, endIdx);
                    inBlock = false;
                }
            }
            else if (work.StartsWith("//"))
            {
                work = work.Substring(2);
            }

            var idx = work.IndexOf(':');
            if (idx > 0)
            {
                var key = work.Substring(0, idx).Trim();
                var value = work.Substring(idx + 1).Trim();
                if (key.Equals("DisplayName", StringComparison.OrdinalIgnoreCase)) displayName = value;
                else if (key.Equals("Category", StringComparison.OrdinalIgnoreCase)) category = value;
                else if (key.Equals("CoreName", StringComparison.OrdinalIgnoreCase)) coreName = value;
                else if (key.Equals("Description", StringComparison.OrdinalIgnoreCase)) description = value;
                else if (key.Equals("Performance", StringComparison.OrdinalIgnoreCase))
                {
                    if (int.TryParse(value, out var p)) performance = p;
                }
                else if (key.Equals("Rating", StringComparison.OrdinalIgnoreCase))
                {
                    if (int.TryParse(value, out var r)) rating = r;
                }
            }
        }
    }
}
