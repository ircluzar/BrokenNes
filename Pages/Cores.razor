@page "/cores"
@using NesEmulator
@using NesEmulator.Shaders
@inject IJSRuntime JS
@inject IShaderProvider ShaderProvider
@inject BrokenNes.Services.GameSaveService SaveSvc
@using BrokenNes.Shared

<div class="options-root">
  <div id="pixelBgHost" class="pixel-bg-host" aria-hidden="true"></div>
  <h2 class="opt-title">UNLOCKED CORES</h2>
  <div class="card-sections">
    <section class="card-section">
      <h3 class="opt-h3">CPU</h3>
      <div class="card-grid">
        @if (CpuMeta.Count > 0)
        {
          foreach (var c in CpuMeta)
          {
    var model = new CoreCardModel {
                  Id = c.Id,
                  ShortName = c.Id,
                  DisplayName = c.Name,
                  Description = c.Description,
                  Rating = Math.Clamp(c.Rating, 0, 5),
                  Performance = c.Performance,
      FooterNote = c.Category,
      Domain = "CPU"
              };
            <div class="core-card" @key="c.Id" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        }
        else if (Cpu.Count > 0)
        {
          foreach (var id in Cpu)
          {
    var model = new CoreCardModel {
                  Id = id,
                  ShortName = id,
                  DisplayName = id,
                  Rating = 0,
                  Performance = 0,
      FooterNote = "UNIMPLEMENTED",
      Domain = "CPU"
              };
            <div class="core-card" @key="id" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        }
      </div>
    </section>
    <section class="card-section">
      <h3 class="opt-h3">PPU</h3>
      <div class="card-grid">
        @if (PpuMeta.Count > 0)
        {
          foreach (var c in PpuMeta)
          {
    var model = new CoreCardModel {
                  Id = c.Id,
                  ShortName = c.Id,
                  DisplayName = c.Name,
                  Description = c.Description,
                  Rating = Math.Clamp(c.Rating, 0, 5),
                  Performance = c.Performance,
      FooterNote = c.Category,
      Domain = "PPU"
              };
            <div class="core-card" @key="c.Id" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        }
        else if (Ppu.Count > 0)
        {
          foreach (var id in Ppu)
          {
    var model = new CoreCardModel {
                  Id = id,
                  ShortName = id,
                  DisplayName = id,
                  Rating = 0,
                  Performance = 0,
      FooterNote = "UNIMPLEMENTED",
      Domain = "PPU"
              };
            <div class="core-card" @key="id" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        }
      </div>
    </section>
    <section class="card-section">
      <h3 class="opt-h3">APU</h3>
      <div class="card-grid">
        @if (ApuMeta.Count > 0)
        {
          foreach (var c in ApuMeta)
          {
    var model = new CoreCardModel {
                  Id = c.Id,
                  ShortName = c.Id,
                  DisplayName = c.Name,
                  Description = c.Description,
                  Rating = Math.Clamp(c.Rating, 0, 5),
                  Performance = c.Performance,
      FooterNote = c.Category,
      Domain = "APU"
              };
            <div class="core-card" @key="c.Id" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        }
        else if (Apu.Count > 0)
        {
          foreach (var id in Apu)
          {
    var model = new CoreCardModel {
                  Id = id,
                  ShortName = id,
                  DisplayName = id,
                  Rating = 0,
                  Performance = 0,
      FooterNote = "UNIMPLEMENTED",
      Domain = "APU"
              };
            <div class="core-card" @key="id" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        }
      </div>
    </section>
    <section class="card-section">
      <h3 class="opt-h3">Clock</h3>
      <div class="card-grid">
        @if (ClockInfos.Count > 0)
        {
      foreach (var c in ClockInfos)
          {
  var model = new CoreCardModel {
                  Id = c.Id,
                  ShortName = c.Id,
                  DisplayName = c.Name,
                  Description = c.Description,
    Rating = Math.Clamp(c.Rating, 0, 5),
    Performance = c.Performance,
          FooterNote = c.Category,
          Domain = "CLOCK"
              };
            <div class="core-card" @key="c.Id" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        }
        else if (Clock.Count > 0)
        {
          foreach (var id in Clock)
          {
  var model = new CoreCardModel {
                  Id = id,
                  ShortName = id,
                  DisplayName = id,
      Rating = 0,
      Performance = 0,
          FooterNote = "UNIMPLEMENTED",
          Domain = "CLOCK"
              };
            <div class="core-card" @key="id" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        }
      </div>
    </section>
    <section class="card-section">
      <h3 class="opt-h3">Shaders</h3>
      <div class="card-grid">
        @if (ShaderInfos.Count > 0)
        {
          foreach (var s in ShaderInfos)
          {
    var model = new CoreCardModel {
                  Id = s.Id,
                  ShortName = s.Id,
                  DisplayName = s.DisplayName,
                  Description = s.Description,
                  Rating = Math.Clamp(s.Rating, 0, 5),
                  Performance = s.Performance,
      FooterNote = s.Category,
      Domain = "SHADER"
              };
            <div class="core-card" @key="s.Id" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        }
        else if (Shaders.Count > 0)
        {
          foreach (var id in Shaders)
          {
    var model = new CoreCardModel {
                  Id = id,
                  ShortName = id,
                  DisplayName = id,
                  Rating = 0,
      Performance = 0,
      Domain = "SHADER"
              };
            <div class="core-card" @key="id" @onclick="() => OpenCard(model)">
              @((MarkupString)CardSvgRenderer.Render(model, 166, 235))
            </div>
          }
        }
      </div>
    </section>
  </div>
  <div class="opt-footer">
    <a href="./deck-builder?skipHW=1" class="opt-link">RETURN</a>
  </div>
</div>

<style>
  .card-sections { display: grid; gap: 24px; }
  .card-section { }
  .card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(166px, 1fr));
    gap: 16px;
    align-items: start;
  }
  .core-card { cursor: pointer; }
  .core-card svg { width: 100%; height: auto; display: block; }
  .opt-h3 { margin: 8px 0 8px; }
  @@media (min-width: 1200px) {
    .card-sections { gap: 32px; }
    .card-grid { gap: 20px; }
  }

  /* Modal zoom styles */
  .card-modal-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 16px;
  }
  .card-modal-content { cursor: pointer; }
  /* Make zoomed card fill most of the viewport, maintain aspect */
  .card-modal-content svg {
    width: min(96vw, calc(96vh * 0.7059));
    height: auto;
    max-height: 96vh;
    aspect-ratio: 240 / 340;
  }

  /* Animations */
  .card-modal-backdrop.opening { animation: fadeIn 160ms ease-out forwards; }
  .card-modal-backdrop.closing { animation: fadeOut 160ms ease-in forwards; }
  .card-modal-content.opening { animation: zoomIn 180ms ease-out forwards; }
  .card-modal-content.closing { animation: zoomOut 160ms ease-in forwards; }

  @@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  @@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
  @@keyframes zoomIn { from { opacity: 0; transform: scale(0.7); } to { opacity: 1; transform: scale(1); } }
  @@keyframes zoomOut { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.7); } }
</style>

@if (SelectedCard != null)
{
  <div class="card-modal-backdrop @(ModalClosing ? "closing" : "opening")" @onclick="CloseCard">
    <div class="card-modal-content @(ModalClosing ? "closing" : "opening")" @onclick="CloseCard">
      @((MarkupString)CardSvgRenderer.Render(SelectedCard))
    </div>
  </div>
}

@code {
  private IReadOnlyList<string> Cpu = Array.Empty<string>();
  private IReadOnlyList<string> Ppu = Array.Empty<string>();
  private IReadOnlyList<string> Apu = Array.Empty<string>();
  private IReadOnlyList<string> Clock = Array.Empty<string>();
  private IReadOnlyList<string> Shaders = Array.Empty<string>();
  private List<ShaderInfo> ShaderInfos = new();
  private CoreCardModel? SelectedCard;
  private bool ModalClosing;

  private List<CoreMeta> CpuMeta = new();
  private List<CoreMeta> PpuMeta = new();
  private List<CoreMeta> ApuMeta = new();
  private List<ClockInfo> ClockInfos = new();

  protected override async Task OnInitializedAsync()
  {
    try { await JS.InvokeVoidAsync("nesInterop.ensureAudioContext"); } catch { }
    try { await JS.InvokeVoidAsync("nesInterop.applySavedAudioVolumes"); } catch { }
    try { await JS.InvokeVoidAsync("eval", "window.homePixelBgEnsure && window.homePixelBgEnsure();"); } catch { }
    // Populate reflection data
    try { Cpu = CoreRegistry.CpuIds; } catch { }
    try { Ppu = CoreRegistry.PpuIds; } catch { }
    try { Apu = CoreRegistry.ApuIds; } catch { }
    try { Clock = ClockRegistry.Ids; } catch { }
    try { Shaders = ShaderProvider.All.Select(s => s.Id).ToArray(); } catch { }

    // Filter to owned cores per save and build shader infos accordingly
    HashSet<string> setShd = new(StringComparer.OrdinalIgnoreCase);
    try
    {
      var save = await SaveSvc.LoadAsync();
      var setCpu = new HashSet<string>(save.OwnedCpuIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var setPpu = new HashSet<string>(save.OwnedPpuIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var setApu = new HashSet<string>(save.OwnedApuIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var setClk = new HashSet<string>(save.OwnedClockIds ?? new(), StringComparer.OrdinalIgnoreCase);
      setShd = new HashSet<string>(save.OwnedShaderIds ?? new(), StringComparer.OrdinalIgnoreCase);
      Cpu = Cpu.Where(id => setCpu.Contains(id)).ToArray();
      Ppu = Ppu.Where(id => setPpu.Contains(id)).ToArray();
      Apu = Apu.Where(id => setApu.Contains(id)).ToArray();
      Clock = Clock.Where(id => setClk.Contains(id)).ToArray();
      Shaders = Shaders.Where(id => setShd.Contains(id)).ToArray();
    }
    catch { }

    try
    {
      var all = ShaderProvider.All;
      var infos = new List<ShaderInfo>();
      var shaderSet = new HashSet<string>(Shaders, StringComparer.OrdinalIgnoreCase);
      foreach (var s in all)
      {
        if (!shaderSet.Contains(s.Id)) continue;
        string? cat = null;
        try { cat = s.Defines != null && s.Defines.TryGetValue("Category", out var c) ? c : null; } catch { }
        infos.Add(new ShaderInfo
        {
          Id = s.Id,
          DisplayName = s.DisplayName,
          Description = s.Description,
          Performance = s.Performance,
          Rating = s.Rating,
          Category = cat ?? "Uncategorized"
        });
      }
      ShaderInfos = infos
        .OrderBy(i => i.Category, StringComparer.OrdinalIgnoreCase)
        .ThenBy(i => i.DisplayName, StringComparer.OrdinalIgnoreCase)
        .ToList();
    }
    catch { }

    // Try to instantiate cores on a minimal bus to read metadata
    try
    {
      // Build a tiny, valid iNES ROM (NROM-128: 1x16KB PRG, 0 CHR)
      var dummy = new byte[16 + 16 * 1024];
      dummy[0] = 0x4E; dummy[1] = 0x45; dummy[2] = 0x53; dummy[3] = 0x1A; // NES\x1A
      dummy[4] = 1; // PRG banks
      dummy[5] = 0; // CHR banks
      dummy[6] = 0; dummy[7] = 0; // flags
      var cart = new Cartridge(dummy);
      var bus = new Bus(cart);

      // CPU/PPU/APU metadata
      var cpuDict = CoreRegistry.CreateInstances<ICPU>(bus, "CPU_");
      CpuMeta = cpuDict
        .Where(kv => Cpu.Contains(kv.Key, StringComparer.OrdinalIgnoreCase))
        .Select(kv => new CoreMeta
      {
        Id = kv.Key,
        Name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
        Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
        Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
        Rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
        Category = SafeGet(() => kv.Value.Category) ?? "Uncategorized"
      }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      var ppuDict = CoreRegistry.CreateInstances<IPPU>(bus, "PPU_");
      PpuMeta = ppuDict
        .Where(kv => Ppu.Contains(kv.Key, StringComparer.OrdinalIgnoreCase))
        .Select(kv => new CoreMeta
      {
        Id = kv.Key,
        Name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
        Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
        Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
        Rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
        Category = SafeGet(() => kv.Value.Category) ?? "Uncategorized"
      }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      var apuDict = CoreRegistry.CreateInstances<IAPU>(bus, "APU_");
      ApuMeta = apuDict
        .Where(kv => Apu.Contains(kv.Key, StringComparer.OrdinalIgnoreCase))
        .Select(kv => new CoreMeta
      {
        Id = kv.Key,
        Name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
        Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
        Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
        Rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
        Category = SafeGet(() => kv.Value.Category) ?? "Uncategorized"
      }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      // Clock metadata (now implements Performance & Rating)
  ClockInfos = new List<ClockInfo>();
  foreach (var id in Clock)
      {
        try
        {
          var clk = ClockRegistry.Create(id);
          if (clk != null)
          {
    ClockInfos.Add(new ClockInfo {
      Id = id,
      Name = clk.DisplayName,
      Description = clk.Description,
      Performance = clk.Performance,
      Rating = clk.Rating,
      Category = SafeGet(() => clk.Category) ?? "Uncategorized"
    });
          }
        }
        catch { }
      }
  ClockInfos = ClockInfos.OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();
    }
    catch
    {
      // If anything fails (e.g., environment), fall back to simple ID lists already populated above
    }

  }

  private void OpenCard(CoreCardModel m)
  {
    ModalClosing = false;
    SelectedCard = m;
  }

  private async Task CloseCard()
  {
    if (SelectedCard == null) return;
    ModalClosing = true;
    StateHasChanged();
    try { await Task.Delay(180); } catch { }
    SelectedCard = null;
    ModalClosing = false;
  }

  private static T? SafeGet<T>(Func<T> getter)
  {
    try { return getter(); } catch { return default; }
  }

  private static T? SafeGetStruct<T>(Func<T> getter) where T : struct
  {
    try { return getter(); } catch { return null; }
  }

  private sealed class CoreMeta
  {
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public int Performance { get; set; }
    public int Rating { get; set; }
    public string Category { get; set; } = string.Empty;
  }

  private sealed class ClockInfo
  {
    public string Id { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
  public int Performance { get; set; }
  public int Rating { get; set; }
    public string Category { get; set; } = string.Empty;
  }

  private sealed class ShaderInfo
  {
    public string Id { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public int Performance { get; set; }
    public int Rating { get; set; }
    public string Category { get; set; } = string.Empty;
  }
}
