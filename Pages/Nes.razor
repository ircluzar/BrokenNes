@page "/nes"
@using System.Timers
@using System.Linq
@using Microsoft.Extensions.Logging
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.WebAssembly.Services
@using BrokenNes.Models
@using BrokenNes.CorruptorModels
@inject ILogger<Nes> Logger
@inject IJSRuntime JS
@inject HttpClient Http
@inject StatusService Status
@inject NesEmulator.Shaders.IShaderProvider ShaderProvider
@inject NavigationManager Nav


@if (!string.IsNullOrEmpty(nesController.ErrorMessage))
{
    <div class="alert alert-danger" role="alert">
        <strong>⚠️ SYSTEM ERROR:</strong> @nesController.ErrorMessage
    </div>
}

@* Status moved to global StatusBar component *@

@* Boot overlay removed: auto-boot enabled (audio context primed on Home page) *@

<div class="nes-grid">
    <section class="play-area">
        <div class="quick-controls btn-toolbar gap-2 flex-wrap justify-content-center mb-3" role="toolbar">
            <div class="btn-group">
                <button class="btn btn-success ctrl-btn" @onclick="(()=>emu!.StartAsync())" disabled="@(nesController.IsRunning || nes == null)" title="Start (Play)" aria-label="Start">
                    <svg viewBox="0 0 100 100" class="ctrl-ico play" role="img" focusable="false"><polygon points="28,18 82,50 28,82" /></svg>
                </button>
                <button class="btn btn-warning ctrl-btn" @onclick="(()=>emu!.PauseAsync())" disabled="@(!nesController.IsRunning)" title="Pause" aria-label="Pause">
                    <svg viewBox="0 0 100 100" class="ctrl-ico pause" role="img" focusable="false"><rect x="24" y="18" width="20" height="64" rx="6" /><rect x="56" y="18" width="20" height="64" rx="6" /></svg>
                </button>
                <button class="btn btn-danger ctrl-btn" @onclick="(()=>emu!.ResetAsyncFacade())" disabled="@(nes == null)" title="Reset" aria-label="Reset">
                    <svg viewBox="0 0 100 100" class="ctrl-ico reset" role="img" focusable="false"><path d="M50 18a32 32 0 1 1-22.63 9.37" fill="none" stroke="currentColor" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/><path d="M23 13 30 40 5 34" fill="currentColor" /></svg>
                </button>
            </div>
            <div class="btn-group">
                <div class="qc-select-stack">
                    <label for="shaderSelect" class="mini-label" title="Select video shader pass">Shader</label>
                    <select id="shaderSelect" class="btn btn-rf btn-select" title="Video shader" @onchange="(e)=>emu!.SetShaderPublic(e.Value?.ToString()??string.Empty)" value="@nesController.ActiveShaderKey" aria-label="Video Shader">
                        @foreach(var sh in nesController.ShaderOptions){
                            <option value="@sh.Key">@sh.Label</option>
                        }
                    </select>
                </div>
                <div class="qc-select-stack">
                    <label for="apuCoreSelect" class="mini-label" title="Select audio processing core">APU Core</label>
                    <select id="apuCoreSelect" class="btn btn-fmc btn-select" title="Audio core mode" @onchange="(e)=>emu!.SetApuCorePublic(e.Value?.ToString()??string.Empty)" value="@nesController.ApuCoreSel" aria-label="Audio Core">
                        @foreach(var opt in nesController.ApuCoreOptions){ <option value="@opt">@opt</option> }
                    </select>
                </div>
                <div class="qc-select-stack">
                    <label for="cpuCoreSelect" class="mini-label" title="Select CPU core implementation">CPU Core</label>
                    <select id="cpuCoreSelect" class="btn btn-rf btn-select" title="CPU core" @onchange="(e)=>emu!.SetCpuCorePublic(e.Value?.ToString()??string.Empty)" value="@nesController.CpuCoreSel" aria-label="CPU Core">
                        @foreach(var opt in nesController.CpuCoreOptions){ <option value="@opt">@opt</option> }
                    </select>
                </div>
                <div class="qc-select-stack">
                    <label for="ppuCoreSelect" class="mini-label" title="Select PPU core implementation">PPU Core</label>
                    <select id="ppuCoreSelect" class="btn btn-rf btn-select" title="PPU core" @onchange="(e)=>emu!.SetPpuCorePublic(e.Value?.ToString()??string.Empty)" value="@nesController.PpuCoreSel" aria-label="PPU Core">
                        @foreach(var opt in nesController.PpuCoreOptions){ <option value="@opt">@opt</option> }
                    </select>
                </div>
            </div>
            <div class="btn-group">
                <button class="btn btn-load-state" @onclick="(()=>emu!.LoadStateAsyncPublic())" disabled="@(nes==null)" title="Load state">Load</button>
                <button class="btn btn-save-state" @onclick="(()=>emu!.SaveStateAsyncPublic())" disabled="@(nes==null)" title="Save state">Save</button>
            </div>
        </div>
    <div class="screen-shell @(nesController.EmuScale == 0.5 ? "scale-50" : "scale-100")" id="screen-shell">
            <div class="overlay-status small">
                <div class="badges d-flex flex-wrap">
                    <span class="badge bg-dark-subtle text-dark me-1">FPS: @nesController.Fps.ToString("F1")</span>
                    <span class="badge bg-dark-subtle text-dark me-1">State: @(nesController.IsRunning ? "Running" : "Paused")</span>
                    <span class="badge bg-dark-subtle text-dark me-1">ROM: <strong>@nesController.CurrentRomName</strong></span>
                    <span class="badge bg-dark-subtle text-dark">Size: @NesController.FormatSize(nesController.LastLoadedRomSize)</span>
                    <span class="badge bg-dark-subtle text-dark ms-1">SF Core: @emu?.ActiveSfCoreDisplay</span>
                    @if (emu?.SoundFontLayering == true)
                    {
                        <span class="badge bg-warning text-dark ms-1" title="Layering enabled: both cores may receive note events">Layering</span>
                    }
                </div>
                <div class="overlay-actions">
                    <button type="button" class="ov-btn @(nesController.EmuScale==0.5 ? "active" : string.Empty) desktop-only" title="Scale 50%" @onclick="(()=>SetScale(0.5))">½×</button>
                    <button type="button" class="ov-btn @(nesController.EmuScale==1 ? "active" : string.Empty) desktop-only" title="Scale 100%" @onclick="(()=>SetScale(1))">1×</button>
                    <button type="button" class="ov-btn" title="Toggle Fullscreen" @onclick="ToggleFullscreen">⛶</button>
                </div>
            </div>
            <div class="screen-aspect">
                <canvas id="nes-canvas" width="512" height="480" class="pixel-perfect responsive-canvas"></canvas>
            </div>
            @* Inline mobile fullscreen portrait tab bar (only shown via CSS when .mobile-fs-active & portrait) *@
            <div id="mobile-fs-view-bar">
                <button data-view="controller" class="view-btn @(emu!.UI.MobileFullscreenView=="controller"?"active":string.Empty)" @onclick="(()=>emu!.UI.ViewController())">Controller</button>
                <button data-view="rtc" class="view-btn @(emu!.UI.MobileFullscreenView=="rtc"?"active":string.Empty)" @onclick="(()=>emu!.UI.ViewRtc())">RTC</button>
                <button data-view="gh" class="view-btn @(emu!.UI.MobileFullscreenView=="gh"?"active":string.Empty)" @onclick="(()=>emu!.UI.ViewGh())">Glitch Harvester</button>
            </div>
            @* Mobile fullscreen (portrait) views container: always present in fullscreen portrait; controller now lives inside instead of toggling container visibility *@
            <div class="mobile-fs-extra-views">
                @if (emu!.UI.MobileFullscreenView == "controller")
                {
                    <div class="mobile-view controller-view" id="touch-controller">
                        <div class="controller-grid">
                            <div class="upper-row">
                                <div class="dpad">
                                    <div class="pad-btn" data-btn="up">▲</div>
                                    <div class="pad-btn" data-btn="left">◀</div>
                                    <div class="pad-btn" data-btn="right">▶</div>
                                    <div class="pad-btn" data-btn="down">▼</div>
                                    <div class="center-dot"></div>
                                </div>
                                <div class="actions">
                                    <div class="ab-cluster">
                                        <div class="btn-b" data-btn="b">B</div>
                                        <div class="btn-a" data-btn="a">A</div>
                                    </div>
                                </div>
                            </div>
                            <div class="start-select-row">
                                <div class="small-btn" data-btn="select">SELECT</div>
                                <div class="small-btn" data-btn="start">START</div>
                            </div>
                            <div class="system-row">
                                <button class="sys-btn" data-act="exit">Exit Fullscreen</button>
                                <button class="sys-btn" data-act="load">Load State</button>
                                <button class="sys-btn" data-act="save">Save State</button>
                            </div>
                        </div>
                    </div>
                }
                else if (emu!.UI.MobileFullscreenView == "rtc")
                {
                    <div class="mobile-view rtc-view small">
                        <div class="d-flex align-items-center justify-content-between mb-2">
                            <strong class="small mb-0">Real-Time Corruptor</strong>
                            <span class="text-muted small">@corruptor.LastBlastInfo</span>
                        </div>
                        <div class="row g-3 flex-wrap">
                            <div class="col-12">
                                <label class="form-label small mb-1">Memory Domains</label>
                                <select multiple size="5" class="form-select form-select-sm" @onchange="DomainsChanged">
                                    @foreach (var d in corruptor.MemoryDomains)
                                    {
                                        <option value="@d.Key" selected="@d.Selected">@d.Label (@d.Size)</option>
                                    }
                                </select>
                            </div>
                            <div class="col-12">
                                <label class="form-label mb-1 small">Intensity (@corruptor.CorruptIntensity)</label>
                                <input type="range" min="1" max="4096" step="1" class="form-range" value="@corruptor.CorruptIntensity" @oninput="OnIntensityChange" />
                                <div class="d-flex gap-2 align-items-center mb-2 flex-wrap">
                                    <input type="number" min="1" max="4096" class="form-control form-control-sm intensity-box" value="@corruptor.CorruptIntensity" @onchange="OnIntensityBoxChange" />
                                    <button class="btn btn-sm btn-outline-danger" @onclick="(()=>emu!.BlastAsync())" disabled="@(nes==null || emu!.AutoCorrupt)" title="Apply one-time corruption now">Blast</button>
                                    <button class="btn btn-sm @(emu!.AutoCorrupt ? "btn-success" : "btn-outline-success")" @onclick="(()=>emu!.ToggleAutoCorrupt())" title="Toggle auto-corruption each frame">Auto: @(emu!.AutoCorrupt ? "ON" : "OFF")</button>
                                    @if (!corruptor.LetItRipUsed)
                                    {
                                        <button class="btn btn-sm" style="background-color:#6f42c1;color:#fff;border-color:#6f42c1" @onclick="(()=>emu!.LetItRipPublic())" title="Intensity=1; select PRG ROM + System RAM; enable auto-corrupt; then hide button">Let it rip</button>
                                    }
                                </div>
                                <div class="row g-2 small">
                                    <div class="col-6">
                                        <label class="form-label mb-1 small">Blast Type</label>
                                        <select class="form-select form-select-sm" value="@emu!.BlastType" @onchange="(e)=>emu!.SetBlastTypePublic(e.Value?.ToString()??string.Empty)">
                                            <option value="RANDOM">RANDOM</option>
                                            <option value="TILT">TILT</option>
                                            <option value="RANDOMTILT">RANDOMTILT</option>
                                            <option value="NOP">NOP</option>
                                            <option value="BITFLIP">BITFLIP</option>
                                        </select>
                                    </div>
                                    <div class="col-6 small text-muted d-flex align-items-end">Random writes across selected domains.</div>
                                </div>
                                <div class="mt-2 small text-muted fst-italic">Last: @corruptor.LastBlastInfo</div>
                            </div>
                        </div>
                    </div>
                }
                else if (emu!.UI.MobileFullscreenView == "gh")
                {
                    <div class="mobile-view gh-view small">
                        <div class="gh-section mb-3">
                            <div class="d-flex flex-wrap gap-2 align-items-end">
                                <div class="flex-grow-1" style="min-width:140px;">
                                    <label class="form-label mb-1 small">New Base Name</label>
                                    <input class="form-control form-control-sm" placeholder="e.g. TitleScreen" @bind="corruptor.GhNewBaseName" />
                                </div>
                                <button class="btn btn-sm btn-primary mt-3" @onclick="(()=>emu!.GhAddBase())" disabled="@(nes==null)">Add Base</button>
                            </div>
                            <div class="mt-2">
                                <label class="form-label mb-1 small">Base States</label>
                                <select class="form-select form-select-sm" size="4" @onchange="(e)=>emu!.GhOnBaseChangedPublic(e)" value="@corruptor.GhSelectedBaseId">
                                    @foreach (var b in corruptor.GhBaseStates)
                                    {
                                        <option value="@b.Id">@b.Name</option>
                                    }
                                </select>
                                <div class="d-flex gap-1 mt-2 flex-wrap">
                                    <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.GhLoadSelected())" disabled="@(!emu!.GhHasSelectedBase)">Load</button>
                                    <button class="btn btn-sm btn-outline-danger" @onclick="(()=>emu!.GhDeleteSelected())" disabled="@(!emu!.GhHasSelectedBase)">Delete</button>
                                </div>
                            </div>
                        </div>
                        <div class="gh-section mb-3">
                            <label class="form-label mb-1 small">Actions (uses RTC settings)</label>
                            <div class="d-flex gap-2 flex-wrap">
                                <button class="btn btn-sm btn-warning" @onclick="(()=>emu!.GhCorruptAndStashAsync())" disabled="@(!emu!.GhHasSelectedBase || nes==null)">Corrupt &amp; Stash</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.GhClearStashPublic())" disabled="@(corruptor.GhStash.Count==0)">Clear Stash</button>
                            </div>
                        </div>
                        <div class="gh-section mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <strong class="small mb-0">Stash (@corruptor.GhStash.Count)</strong>
                            </div>
                            @if (corruptor.GhStash.Count==0)
                            {
                                <div class="text-muted small fst-italic">(empty)</div>
                            }
                            else
                            {
                                <div class="gh-list">
                                    @foreach (var e in corruptor.GhStash.OrderByDescending(e=>e.Created).Take(20))
                                    {
                                        <div class="gh-item">
                                            <div class="gh-item-main">
                                                <span class="gh-name" title="@e.Name">@e.Name</span>
                                                <span class="gh-meta">@e.Writes.Count w @e.Created.ToLocalTime().ToString("HH:mm:ss")</span>
                                            </div>
                                            <div class="gh-actions btn-group btn-group-sm">
                                                <button class="btn btn-outline-light" title="Replay" @onclick="(()=>emu!.GhReplayEntryAsync(e, false))">▶</button>
                                                <button class="btn btn-outline-success" title="Keep" @onclick="(()=>emu!.GhPromote(e))">Keep</button>
                                                <button class="btn btn-outline-danger" title="Discard" @onclick="(()=>emu!.GhDeleteStash(e.Id))">✕</button>
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                        <div class="gh-section">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <strong class="small mb-0">Stockpile (@corruptor.GhStockpile.Count)</strong>
                            </div>
                            @if (corruptor.GhStockpile.Count==0)
                            {
                                <div class="text-muted small fst-italic">(empty)</div>
                            }
                            else
                            {
                                <div class="gh-list">
                                    @foreach (var e in corruptor.GhStockpile.OrderByDescending(e=>e.Created).Take(20))
                                    {
                                        <div class="gh-item">
                                            <div class="gh-item-main">
                                                @if (emu!.GhIsRenaming(e.Id))
                                                {
                                                    <input class="form-control form-control-sm" style="min-width:120px" value="@corruptor.GhRenameText" @onchange="emu!.GhRenameChange" />
                                                }
                                                else
                                                {
                                                    <span class="gh-name" title="@e.Name">@e.Name</span>
                                                }
                                                <span class="gh-meta">@e.Writes.Count w • @emu!.GhFindBaseName(e.BaseStateId)</span>
                                            </div>
                                            <div class="gh-actions btn-group btn-group-sm">
                                                <button class="btn btn-outline-light" title="Replay" @onclick="(()=>emu!.GhReplayEntryAsync(e, true))">▶</button>
                                                @if (emu!.GhIsRenaming(e.Id))
                                                {
                                                    <button class="btn btn-outline-success" title="Save" @onclick="(()=>emu!.GhCommitRename(e.Id))">✔</button>
                                                    <button class="btn btn-outline-warning" title="Cancel" @onclick="emu!.GhCancelRename">↺</button>
                                                }
                                                else
                                                {
                                                    <button class="btn btn-outline-info" title="Rename" @onclick="(()=>emu!.GhBeginRename(e))">✎</button>
                                                }
                                                <button class="btn btn-outline-danger" title="Delete" @onclick="(()=>emu!.GhDeleteStock(e.Id))">✕</button>
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    </div>
                }
            </div>
        </div>
    </section>
    <aside class="side-panels">
    <details id="rom-manager-panel" class="panel-block" open>
        <summary>ROM Manager</summary>
        <div class="panel-content">
            <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                <input id="rom-search" type="text" class="form-control form-control-sm" placeholder="Search ROMs..." style="max-width:180px" @oninput="OnRomSearchChanged" value="@nesController.RomSearch" />
                <button class="btn btn-sm btn-success" @onclick="(()=>emu!.TriggerRomImportDialogPublic())">Import</button>
                <button class="btn btn-sm btn-outline-secondary" @onclick="ReloadCurrentRom" disabled="@(string.IsNullOrEmpty(nesController.CurrentRomName))">Reload</button>
                @* Removed standalone Delete and Clear Uploaded buttons (row deletion + per-ROM Del button sufficient) *@
            </div>
            <div class="mb-2 small text-muted">Built-in + cached uploaded ROMs (persisted in browser storage). Click a row to load. Drag .nes files onto this list to import.</div>
            <div class="table-responsive" style="max-height:260px; overflow:auto;">
                <table id="rom-table" class="table table-sm table-dark align-middle mb-0 rom-table">
                    <thead class="table-secondary text-dark" style="position:sticky;top:0;">
                        <tr>
                            <th style="width:1%;"></th>
                            <th>Name</th>
                            <th style="width:90px;">Size</th>
                            <th style="width:80px;">Source</th>
                            <th style="width:70px;">Delete</th>
                        </tr>
                    </thead>
                    <tbody>
                        @if (!FilteredRomOptions.Any())
                        {
                            <tr><td colspan="5" class="text-center text-muted small">No ROMs match filter.</td></tr>
                        }
                        else
                        {
                            @foreach (var opt in FilteredRomOptions)
                            {
                                var isCurrent = opt.Key == nesController.CurrentRomName;
                                var sizeDisplay = nesController.GetRomSizeDisplay(opt.Key);
                                <tr class="@(isCurrent ? "table-primary" : "")" @onclick="(()=>OnRomRowClicked(opt))">
                                    <td>@(isCurrent ? "▶" : "")</td>
                                    <td class="text-truncate" style="max-width:200px;" title="@opt.Key">@opt.Label</td>
                                    <td>@sizeDisplay</td>
                                    <td>@(opt.BuiltIn ? "Built-in" : "Uploaded")</td>
                                    <td><button class="btn btn-sm btn-outline-danger" @onclick:stopPropagation="true" @onclick="(()=>emu!.DeleteRomPublic(opt.Key))" disabled="@opt.BuiltIn">Del</button></td>
                                </tr>
                            }
                        }
                    </tbody>
                </table>
            </div>
            <div class="mt-2 small d-flex flex-wrap gap-3 text-muted">
                <div>Total: @FilteredRomOptions.Count() ROM(s)</div>
                <div>Uploaded: @nesController.UploadedRoms.Count</div>
                <div>Selected: @nesController.CurrentRomName</div>
            </div>
            <input @ref="fileInput" id="rom-upload" type="file" accept=".nes" class="d-none" @onchange="(()=>emu!.ImportRomsFromInputAsync(fileInput))" multiple />
        </div>
    </details>

    <details id="corruptor-panel" class="panel-block corruptor-panel">
        <summary>Real-Time Corruptor</summary>
        <div class="panel-content corruptor-content">
            <div class="row g-3 flex-wrap">
                <div class="col-12 col-sm-5">
                    <label class="form-label small mb-1">Memory Domains</label>
                    <select multiple size="5" class="form-select form-select-sm" @onchange="DomainsChanged">
                        @foreach (var d in corruptor.MemoryDomains)
                        {
                            <option value="@d.Key" selected="@d.Selected">@d.Label (@d.Size)</option>
                        }
                    </select>
                    <div class="mt-2 small text-secondary">
                        Crash Mode:
                        <select class="form-select form-select-sm mt-1" @onchange="OnCrashBehaviorChanged" value="@corruptor.CrashBehavior">
                            <option value="RedScreen">Red Screen</option>
                            <option value="IgnoreErrors">Ignore Errors</option>
                        </select>
                    </div>
                </div>
                <div class="col-12 col-sm-7">
                    <div class="d-flex align-items-center justify-content-between mb-1">
                        <label class="form-label mb-0 small">Intensity</label>
                        <code class="small">@corruptor.CorruptIntensity</code>
                    </div>
                    <input type="range" min="1" max="4096" step="1" class="form-range" value="@corruptor.CorruptIntensity" @oninput="OnIntensityChange" />
                    <div class="d-flex gap-2 align-items-center mb-2 flex-wrap">
                        <input type="number" min="1" max="4096" class="form-control form-control-sm intensity-box" value="@corruptor.CorruptIntensity" @onchange="OnIntensityBoxChange" />
                        <button class="btn btn-sm btn-outline-danger" @onclick="(()=>emu!.BlastAsync())" disabled="@(nes==null || emu!.AutoCorrupt)" title="Apply one-time corruption now">Blast</button>
                        <button class="btn btn-sm @(emu!.AutoCorrupt ? "btn-success" : "btn-outline-success")" @onclick="(()=>emu!.ToggleAutoCorrupt())" title="Toggle auto-corruption each frame">Auto: @(emu!.AutoCorrupt ? "ON" : "OFF")</button>
                        @if (!corruptor.LetItRipUsed)
                        {
                            <button class="btn btn-sm" style="background-color:#6f42c1;color:#fff;border-color:#6f42c1" @onclick="(()=>emu!.LetItRipPublic())" title="Intensity=1; select PRG ROM + System RAM; enable auto-corrupt; then hide button">Let it rip</button>
                        }
                    </div>
                    <div class="row g-2 small">
                        <div class="col-6">
                            <label class="form-label mb-1 small">Blast Type</label>
                            <select class="form-select form-select-sm" value="@emu!.BlastType" @onchange="(e)=>emu!.SetBlastTypePublic(e.Value?.ToString()??string.Empty)">
                                <option value="RANDOM">RANDOM</option>
                                <option value="TILT">TILT</option>
                                <option value="RANDOMTILT">RANDOMTILT</option>
                                <option value="NOP">NOP</option>
                                <option value="BITFLIP">BITFLIP</option>
                            </select>
                        </div>
                        <div class="col-6 small text-muted d-flex align-items-end">Random writes across selected domains.</div>
                    </div>
                    <div class="mt-2 small text-muted fst-italic">Last: @corruptor.LastBlastInfo</div>
                </div>
            </div>
        </div>
    </details>

    <details class="panel-block glitch-harvester-panel">
        <summary>Glitch Harvester</summary>
        <div class="panel-content glitch-harvester-content small">
            <div class="gh-section mb-3">
                <div class="d-flex flex-wrap gap-2 align-items-end">
                    <div class="flex-grow-1" style="min-width:140px;">
                        <label class="form-label mb-1 small">New Base Name</label>
                        <input class="form-control form-control-sm" placeholder="e.g. TitleScreen" @bind="corruptor.GhNewBaseName" />
                    </div>
                    <button class="btn btn-sm btn-primary mt-3" @onclick="(()=>emu!.GhAddBase())" disabled="@(nes==null)">Add Base</button>
                </div>
                <div class="mt-2">
                    <label class="form-label mb-1 small">Base States</label>
                    <select class="form-select form-select-sm" size="4" @onchange="(e)=>emu!.GhOnBaseChangedPublic(e)" value="@corruptor.GhSelectedBaseId">
                        @foreach (var b in corruptor.GhBaseStates)
                        {
                            <option value="@b.Id">@b.Name</option>
                        }
                    </select>
                    <div class="d-flex gap-1 mt-2 flex-wrap">
                        <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.GhLoadSelected())" disabled="@(!emu!.GhHasSelectedBase)">Load</button>
                        <button class="btn btn-sm btn-outline-danger" @onclick="(()=>emu!.GhDeleteSelected())" disabled="@(!emu!.GhHasSelectedBase)">Delete</button>
                    </div>
                </div>
            </div>
            <div class="gh-section mb-3">
                <label class="form-label mb-1 small">Actions (uses Real-Time Corruptor settings)</label>
                <div class="d-flex gap-2 flex-wrap">
                    <button class="btn btn-sm btn-warning" @onclick="(()=>emu!.GhCorruptAndStashAsync())" disabled="@(!emu!.GhHasSelectedBase || nes==null)">Corrupt &amp; Stash</button>
                    <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.GhClearStashPublic())" disabled="@(corruptor.GhStash.Count==0)">Clear Stash</button>
                </div>
            </div>
            <div class="gh-section mb-3">
                <div class="d-flex justify-content-between align-items-center mb-1">
                    <strong class="small mb-0">Stash History (@corruptor.GhStash.Count)</strong>
                </div>
                @if (corruptor.GhStash.Count==0)
                {
                    <div class="text-muted small fst-italic">(empty)</div>
                }
                else
                {
                    <div class="gh-list">
                        @foreach (var e in corruptor.GhStash.OrderByDescending(e=>e.Created).Take(25))
                        {
                            <div class="gh-item">
                                <div class="gh-item-main">
                                    <span class="gh-name" title="@e.Name">@e.Name</span>
                                    <span class="gh-meta">@e.Writes.Count w @e.Created.ToLocalTime().ToString("HH:mm:ss")</span>
                                </div>
                                <div class="gh-actions btn-group btn-group-sm">
                                    <button class="btn btn-outline-light" title="Replay" @onclick="(()=>emu!.GhReplayEntryAsync(e, false))">▶</button>
                                    <button class="btn btn-outline-success" title="Keep (move to stockpile)" @onclick="(()=>emu!.GhPromote(e))">Keep</button>
                                    <button class="btn btn-outline-danger" title="Discard" @onclick="(()=>emu!.GhDeleteStash(e.Id))">✕</button>
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
            <div class="gh-section">
                <div class="d-flex justify-content-between align-items-center mb-1">
                    <strong class="small mb-0">Stockpile (@corruptor.GhStockpile.Count)</strong>
                    <div class="d-flex gap-1">
                        <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.GhExportStockpileAsync())" disabled="@(corruptor.GhStockpile.Count==0)">Export</button>
                        <label class="btn btn-sm btn-outline-secondary mb-0">
                            Import<input type="file" class="d-none" accept="application/json" @onchange="emu!.GhImportStockpile" />
                        </label>
                    </div>
                </div>
                @if (corruptor.GhStockpile.Count==0)
                {
                    <div class="text-muted small fst-italic">(empty)</div>
                }
                else
                {
                    <div class="gh-list">
                        @foreach (var e in corruptor.GhStockpile.OrderByDescending(e=>e.Created))
                        {
                            <div class="gh-item">
                                <div class="gh-item-main">
                                    @if (emu!.GhIsRenaming(e.Id))
                                    {
                                        <input class="form-control form-control-sm" style="min-width:120px" value="@corruptor.GhRenameText" @onchange="emu!.GhRenameChange" />
                                    }
                                    else
                                    {
                                        <span class="gh-name" title="@e.Name">@e.Name</span>
                                    }
                                    <span class="gh-meta">@e.Writes.Count w • @emu!.GhFindBaseName(e.BaseStateId)</span>
                                </div>
                                <div class="gh-actions btn-group btn-group-sm">
                                    <button class="btn btn-outline-light" title="Replay" @onclick="(()=>emu!.GhReplayEntryAsync(e, true))">▶</button>
                                    @if (emu!.GhIsRenaming(e.Id))
                                    {
                                        <button class="btn btn-outline-success" title="Save name" @onclick="(()=>emu!.GhCommitRename(e.Id))">✔</button>
                                        <button class="btn btn-outline-warning" title="Cancel" @onclick="emu!.GhCancelRename">↺</button>
                                    }
                                    else
                                    {
                                        <button class="btn btn-outline-info" title="Rename" @onclick="(()=>emu!.GhBeginRename(e))">✎</button>
                                    }
                                    <button class="btn btn-outline-danger" title="Delete" @onclick="(()=>emu!.GhDeleteStock(e.Id))">✕</button>
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
        </div>
    </details>

        <details class="panel-block">
        <summary>Controls</summary>
        <div class="panel-content key-grid">
            <div>Arrows: D-Pad</div>
            <div>Z: B</div>
            <div>X: A</div>
            <div>Space: Select</div>
            <div>Enter: Start</div>
        </div>
    </details>

        <details class="panel-block">
        <summary>Debug</summary>
        <div class="panel-content debug-mini">
            <div>Frames: @nesController.FrameCount</div>
            <div>ROM Loaded: @(nes != null ? "Yes" : "No")</div>
            <div><button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.DumpStateAsyncPublic())" disabled="@(nes==null)">Dump State</button></div>
            <div class="mt-2">
                <button class="btn btn-sm btn-outline-primary" @onclick="(()=>emu!.OpenBenchmarks())" disabled="@(nes==null)">@(emu!.BenchRunning?"Running...":"Run Benchmarks")</button>
                <button class="btn btn-sm btn-outline-info ms-1" @onclick="(()=>emu!.OpenComparison())" disabled="@(emu!.BenchHistory.Count()<2)">Compare Results</button>
                <div class="form-check form-switch mt-2 small">
                    <input class="form-check-input" type="checkbox" id="evtSchedToggle" @bind="emu!.EventSchedulerOn" disabled="@(nes==null)" />
                    <label class="form-check-label" for="evtSchedToggle" title="Experimental: event-driven CPU->PPU/APU scheduling (scanline prototype)">Event Scheduler</label>
                </div>
                <div class="form-check form-switch mt-2 small">
                    <input class="form-check-input" type="checkbox" id="sfToggle" @onchange="(e)=>{if(emu?.SoundFontMode != (e.Value is bool b && b || (e.Value is string sv && bool.TryParse(sv,out var p) && p))) emu?.ToggleSoundFontModePublic();}" checked="@emu?.SoundFontMode" disabled="@(nes==null)" />
                    <label class="form-check-label" for="sfToggle" title="Play APU via WebAudio SoundFont/oscillators instead of raw PCM">SoundFont Mode</label>
                </div>
                @if (emu?.SoundFontMode == true)
                {
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfSampleToggle" @onchange="(e)=>{if(emu?.SampleFont != (e.Value is bool b && b || (e.Value is string sv && bool.TryParse(sv,out var p) && p))) emu?.ToggleSampleFontPublic();}" checked="@emu?.SampleFont" />
                        <label class="form-check-label" for="sfSampleToggle" title="Use external sampled SoundFont library (falls back to oscillators if unavailable)">Sampled Instruments</label>
                    </div>
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfLayerToggle" @onchange="(e)=>{if(emu?.SoundFontLayering != (e.Value is bool b && b || (e.Value is string sv && bool.TryParse(sv,out var p) && p))) emu?.ToggleSoundFontLayeringPublic();}" checked="@emu?.SoundFontLayering" />
                        <label class="form-check-label" for="sfLayerToggle" title="Experimental: allow both MNES & WF SoundFont cores to process notes simultaneously (debug/compare)">Layering</label>
                    </div>
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfDevLogToggle" @onchange="(e)=>{if(emu?.SfDevLogging != (e.Value is bool b && b || (e.Value is string sv && bool.TryParse(sv,out var p) && p))) emu?.ToggleSfDevLoggingPublic();}" checked="@emu?.SfDevLogging" />
                        <label class="form-check-label" for="sfDevLogToggle" title="Verbose console logs for SoundFont core routing & throttling">SF Dev Logging</label>
                    </div>
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfOverlayToggle" @onchange="(e)=>{if(emu?.SfOverlay != (e.Value is bool b && b || (e.Value is string sv && bool.TryParse(sv,out var p) && p))) emu?.ToggleSfOverlayPublic();}" checked="@emu?.SfOverlay" />
                        <label class="form-check-label" for="sfOverlayToggle" title="Display on-screen SoundFont diagnostics overlay (lead ms, counters)">SF Overlay</label>
                    </div>
                    <div class="mt-2 d-flex flex-wrap gap-2">
                        <button class="btn btn-sm btn-outline-warning" @onclick="(()=>emu?.FlushSoundFontPublic())" title="Force immediate silence of inactive/active SoundFont synths">SF Flush</button>
                        <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu?.ShowSfDebugPublic())" title="Log SoundFont routing counters to console">SF Debug</button>
                    </div>
                }
            </div>
            @if (emu!.BenchModalOpen)
            {
                <div class="modal-backdrop" style="position:fixed;inset:0;background:#000b;display:flex;align-items:flex-start;justify-content:center;z-index:5000;">
                    <div class="card shadow-lg" style="max-width:960px;width:95%;margin-top:2.5rem;">
                        <div class="card-header d-flex flex-wrap gap-2 justify-content-between align-items-center">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <strong class="small mb-0">Benchmarks</strong>
                                <span class="badge rounded-pill bg-dark text-light small">@emu!.BenchHistory.Count() saved</span>
                                <div class="input-group input-group-sm" style="width:60px;">
                                    <span class="input-group-text">W</span>
                                    <input type="number" min="1" max="9" class="form-control" style="padding-left:2px;padding-right:2px;font-size:.65rem;" @bind="emu!.BenchWeight" />
                                </div>
                                <div class="btn-group btn-group-sm" role="group" aria-label="Benchmark options" style="gap:2px;">
                                    <button type="button" class="btn @(emu!.BenchAutoLoadState?"btn-primary":"btn-outline-primary")" style="font-size:.60rem;padding:2px 4px;line-height:1.1;" @onclick="(()=>emu!.ToggleBenchAutoLoadState())" title="Load baseline savestate before each run">Auto</button>
                                    <button type="button" class="btn @(emu!.BenchSimple5x?"btn-primary":"btn-outline-primary")" style="font-size:.60rem;padding:2px 4px;line-height:1.1;" @onclick="(()=>emu!.ToggleBenchSimpleMode())" title="5× shows only averaged results">5×Avg</button>
                                </div>
                                @if (emu!.BenchRunning)
                                {
                                    <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
                                }
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-outline-primary" @onclick="(()=>emu!.RunBenchmarks5xAsync())" disabled="@(nes==null || emu!.BenchRunning)" title="Run 5 benchmark passes (reloads baseline each)" aria-label="Run five benchmark passes">@(emu!.BenchRunning?"Running...":"Run 5×")</button>
                                <button class="btn btn-sm btn-outline-primary" @onclick="(()=>emu!.RunBenchmarksAsync())" disabled="@(nes==null || emu!.BenchRunning)">@(emu!.BenchRunning?"Running...":$"Run {emu!.BenchWeight}x")</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.CloseBenchmarks())" aria-label="Close">Close</button>
                            </div>
                        </div>
                        <div class="card-body" style="max-height:80vh;overflow:auto;">
                            <div class="mb-4">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <h6 class="small text-uppercase text-muted mb-0">Current Run</h6>
                                    @if (!string.IsNullOrEmpty(emu!.BenchResultsText))
                                    {
                                        <button class="btn btn-sm btn-outline-success" title="Copy results" @onclick="(()=>emu!.CopyBenchResultsAsync())">Copy</button>
                                    }
                                </div>
                                @if (string.IsNullOrEmpty(emu!.BenchResultsText))
                                {
                                    <div class="small fst-italic text-muted">@(emu!.BenchRunning?"Running benchmarks...":"No run yet this session. Click 'Run Again'.")</div>
                                }
                                else
                                {
                                    <pre class="small mb-0" style="white-space:pre;">@emu!.BenchResultsText</pre>
                                }
                            </div>
                            <div class="d-flex justify-content-between align-items-center mb-2 mt-2">
                                <h6 class="small text-uppercase text-muted mb-0">History</h6>
                                <div class="btn-group btn-group-sm">
                                    <button class="btn btn-outline-danger" title="Clear all benchmark history" @onclick="(()=>emu!.ClearBenchHistoryAsync())" disabled="@(emu!.BenchHistory.Count()==0)">Clear</button>
                                </div>
                            </div>
                            @if (emu!.BenchHistory.Count()==0)
                            {
                                <div class="small text-muted fst-italic">(no previous runs saved)</div>
                            }
                            else
                            {
                                <table class="table table-sm table-dark align-middle small mb-0" style="--bs-table-bg:#1e1e1e;">
                                    <thead class="table-secondary text-dark">
                                        <tr>
                                            <th style="width:1%;">#</th>
                                            <th style="min-width:130px;">When</th>
                                            <th style="min-width:160px;">ROM</th>
                                            <th style="width:140px;">Cores</th>
                                            <th style="width:1%;">View</th>
                                            <th style="width:1%;">Del</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                    @foreach (var (entry,idx) in emu!.BenchHistory.Select((e,i)=>(e,i)))
                                    {
                                        <tr class="@(emu!.CurrentBenchHistoryId==entry.Id?"table-primary":"")">
                                            <td>@(idx+1)</td>
                                            <td title="UTC: @entry.TimestampUtc.ToString("u")">@entry.TimestampUtc.ToLocalTime().ToString("HH:mm:ss")</td>
                                            <td class="text-truncate" style="max-width:220px;" title="@entry.Rom">
                                                @if (emu!.EditingBenchRomId == entry.Id)
                                                {
                                                    <input class="form-control form-control-sm" style="min-width:160px;font-size:.65rem;padding:.15rem .25rem;" @bind="emu!.EditingBenchRomValue" @onkeydown="(e)=>HandleBenchRomEditKey(e, entry.Id)" @onblur="(()=>emu!.CommitBenchRomEditPublic(entry.Id))" />
                                                }
                                                else
                                                {
                                                    <span class="d-inline-block text-truncate" style="max-width:220px; cursor:text;" @onclick="(()=>emu!.StartBenchRomEditPublic(entry.Id))" title="Click to edit note">@entry.Rom</span>
                                                }
                                            </td>
                                            <td class="text-nowrap" title="CPU @entry.CpuCore / PPU @entry.PpuCore / APU @entry.ApuCore">@entry.CpuCore/@entry.PpuCore/@entry.ApuCore</td>
                                            <td><button class="btn btn-sm btn-outline-light" @onclick="(()=>emu!.ShowHistoryEntryToggle(entry.Id))" title="View results">@(emu!.CurrentBenchHistoryId==entry.Id?"▾":"▶")</button></td>
                                            <td><button class="btn btn-sm btn-outline-danger" @onclick="(()=>emu!.DeleteBenchEntryAsync(entry.Id))" title="Delete this entry">✕</button></td>
                                        </tr>
                                        @if (emu!.CurrentBenchHistoryId==entry.Id)
                                        {
                                            <tr class="table-secondary text-dark"><td colspan="6"><pre class="small mb-0" style="white-space:pre-wrap;max-height:320px;overflow:auto;">@entry.Display</pre></td></tr>
                                        }
                                    }
                                    </tbody>
                                </table>
                            }
                        </div>
                    </div>
                </div>
            }
            @if (emu!.CompareModalOpen)
            {
                <div class="modal-backdrop" style="position:fixed;inset:0;background:#000b;display:flex;align-items:flex-start;justify-content:center;z-index:5000;">
                    <div class="card shadow-lg" style="max-width:1100px;width:98%;margin-top:2rem;">
                        <div class="card-header d-flex flex-wrap gap-2 justify-content-between align-items-center">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <strong class="small mb-0">Benchmark Comparison</strong>
                                <span class="badge bg-dark small">@emu!.BenchHistory.Count() total</span>
                                <span class="small text-muted">(oldest on left in charts)</span>
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.PlayDiffAnimationAsync())" disabled="@(emu!.DiffAnimating || emu!.RecentDiffRows.Count()==0)">@((emu!.DiffAnimating?"Playing...":"Play Diff"))</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="(()=>emu!.CloseComparison())">Close</button>
                            </div>
                        </div>
                        <div class="card-body" style="max-height:85vh;overflow:auto;">
                            @if (emu!.RecentDiffRows.Count()==0)
                            {
                                <div class="small text-muted fst-italic">Need at least two benchmark entries with structured metrics.</div>
                            }
                            else
                            {
                                <h6 class="small text-uppercase text-muted">Latest vs Previous</h6>
                                <div class="mb-2 small text-muted">Below: numeric diff table. A future update will render a side-by-side frame playback of the two benchmark runs for visual comparison.</div>
                                <div class="table-responsive mb-3">
                                    <table class="table table-sm table-dark align-middle small mb-0" style="--bs-table-bg:#1e1e1e;">
                                        <thead class="table-secondary text-dark">
                                            <tr>
                                                <th>Target</th>
                                                <th title="Current ms per iteration">Cur ms/iter</th>
                                                <th title="Prev ms per iteration">Prev ms/iter</th>
                                                <th title="Delta ms (negative is faster)">Δ ms</th>
                                                <th title="Percent change (negative is faster)">Δ %</th>
                                                <th title="CPU Reads delta">Reads Δ</th>
                                                <th title="CPU Writes delta">Writes Δ</th>
                                                <th title="APU Cycles delta">APU Δ</th>
                                                <th title="OAM DMA Writes delta">OAM Δ</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                        @foreach (var row in emu!.RecentDiffRows)
                                        {
                                            var cls = emu!.HighlightMetricName==row.Name?"table-primary":"";
                                            <tr class="@cls">
                                                <td>@row.Name</td>
                                                <td>@row.CurMs.ToString("F3")</td>
                                                <td>@row.PrevMs.ToString("F3")</td>
                                                <td class="@(row.DeltaMs<0?"text-success":row.DeltaMs>0?"text-danger":"")">@row.DeltaMs.ToString("F3")</td>
                                                <td class="@(row.DeltaPct<0?"text-success":row.DeltaPct>0?"text-danger":"")">@row.DeltaPct.ToString("F2")%</td>
                                                <td class="@(row.ReadsDelta<0?"text-success":row.ReadsDelta>0?"text-danger":"")">@row.ReadsDelta</td>
                                                <td class="@(row.WritesDelta<0?"text-success":row.WritesDelta>0?"text-danger":"")">@row.WritesDelta</td>
                                                <td class="@(row.ApuDelta<0?"text-success":row.ApuDelta>0?"text-danger":"")">@row.ApuDelta</td>
                                                <td class="@(row.OamDelta<0?"text-success":row.OamDelta>0?"text-danger":"")">@row.OamDelta</td>
                                            </tr>
                                        }
                                        </tbody>
                                    </table>
                                </div>
                            }
                            <div class="d-flex justify-content-between align-items-center mt-4 mb-1">
                                <h6 class="small text-uppercase text-muted mb-0">Timeline (@(emu!.CompareNormalize?"% of range":"ms/iter"))</h6>
                                <div class="form-check form-switch small">
                                    <input class="form-check-input" type="checkbox" id="cmpNorm" @bind="emu!.CompareNormalize" />
                                    <label class="form-check-label" for="cmpNorm">Normalize</label>
                                </div>
                            </div>
                            @if (emu!.TimelineSeries.Count==0)
                            {
                                <div class="small text-muted fst-italic">No timeline data.</div>
                            }
                            else
                            {
                                <div class="d-flex flex-wrap gap-3 mb-2">
                                    @foreach (var s in emu!.AllTargets)
                                    {
                                        <label class="form-check-label small me-2">
                                            <input type="checkbox" class="form-check-input me-1" @onchange="(()=>emu!.ToggleTargetVisibility(s))" checked="@emu!.VisibleTargets.Contains(s)" /> @s
                                        </label>
                                    }
                                </div>
                                <div style="overflow:auto; position:relative;" @onmouseleave="(()=>emu!.OnTimelineMouseLeave())">
                                    <svg width="1000" height="240" style="background:#111;border:1px solid #333;" @onmousemove="emu!.OnTimelineMouseMove">
                                        @if (emu!.VisibleTargets.Count()>0)
                                        {
                                            double globalMax = 0;
                                            foreach (var t in emu!.VisibleTargets)
                                                foreach (var v in emu!.TimelineSeries[t])
                                                    if (!double.IsNaN(v.MsPerIter) && v.MsPerIter > globalMax) globalMax = v.MsPerIter;
                                            if (globalMax<=0) { globalMax = 1; }
                                            var count = emu!.TimelineOrder.Count;
                                            var plotW = 960.0; var plotH = 200.0; var left=30; var top=20;
                                            // axes
                                            <line x1="@left" y1="@(top)" x2="@left" y2="@(top+plotH)" stroke="#555" stroke-width="1" />
                                            <line x1="@left" y1="@(top+plotH)" x2="@(left+plotW)" y2="@(top+plotH)" stroke="#555" stroke-width="1" />
                                            // y labels
                                            @if (!emu!.CompareNormalize) {
                                                for (int i=0;i<=4;i++){
                                                    var yVal = globalMax*i/4.0; var y = top+plotH - (yVal/globalMax)*plotH;
                                                    @:<text x="5" y="@(y+4)" font-size="9" fill="#888">@yVal.ToString("F2")</text>
                                                    <line x1="@left" y1="@y" x2="@(left+plotW)" y2="@y" stroke="#222" stroke-width="1" />
                                                }
                                            } else {
                                                for (int i=0;i<=4;i++){
                                                    var yPct = i*25; var y = top+plotH - (i/4.0)*plotH;
                                                    @:<text x="5" y="@(y+4)" font-size="9" fill="#888">@yPct%</text>
                                                    <line x1="@left" y1="@y" x2="@(left+plotW)" y2="@y" stroke="#222" stroke-width="1" />
                                                }
                                            }
                                            // x labels
                                            @for (int i=0;i<count;i++){
                                                var x = left + plotW*(i/(double)Math.Max(1,count-1)); var label = emu!.TimelineOrder[i].ToLocalTime().ToString("HH:mm:ss");
                                                @:<text x="@x" y="@(top+plotH+12)" font-size="8" fill="#666" text-anchor="middle">@label</text>
                                                <line x1="@x" y1="@(top+plotH)" x2="@x" y2="@(top+plotH+4)" stroke="#444" stroke-width="1" />
                                            }
                                            // series lines
                                            @foreach (var t in emu!.VisibleTargets)
                                            {
                                                var color = emu!.GetColorForTarget(t);
                                                double minT = double.MaxValue; double maxT = double.MinValue;
                                                if (emu!.CompareNormalize){
                                                    foreach (var v in emu!.TimelineSeries[t]){ if (!double.IsNaN(v.MsPerIter)){ if (v.MsPerIter<minT) minT=v.MsPerIter; if (v.MsPerIter>maxT) maxT=v.MsPerIter; } }
                                                    if (minT==double.MaxValue){ minT=0; maxT=1; }
                                                    if (Math.Abs(maxT-minT) < 1e-9) { maxT = minT + 1; }
                                                }
                                                var pts = string.Join(' ', emu!.TimelineSeries[t].Select((v,idx)=>{
                                                    var x = left + plotW*(idx/(double)Math.Max(1,count-1));
                                                    double normVal;
                                                    if (emu!.CompareNormalize){
                                                        if (double.IsNaN(v.MsPerIter)) normVal = 0; else normVal = (v.MsPerIter - minT)/(maxT-minT); // 0..1
                                                        var y = top+plotH - normVal*plotH; return $"{x:F1},{y:F1}";
                                                    } else {
                                                        var y = top+plotH - (v.MsPerIter/globalMax)*plotH; return $"{x:F1},{y:F1}";
                                                    }
                                                }));
                                                <polyline points="@pts" fill="none" stroke="@color" stroke-width="2" />
                                            }
                                            @if (emu!.HoverIndex.HasValue && emu!.HoverIndex.Value>=0 && emu!.HoverIndex.Value < count && emu!.HoverPointTooltipData != null)
                                            {
                                                var idx = emu!.HoverIndex.Value;
                                                var hoverX = left + plotW*(idx/(double)Math.Max(1,count-1));
                                                <line x1="@hoverX" y1="@top" x2="@hoverX" y2="@(top+plotH)" stroke="#666" stroke-dasharray="3 3" stroke-width="1" />
                                                foreach (var t in emu!.VisibleTargets)
                                                {
                                                    var pt = emu!.TimelineSeries[t][idx]; if (double.IsNaN(pt.MsPerIter)) continue;
                                                    double minT = double.MaxValue; double maxT = double.MinValue;
                                                    if (emu!.CompareNormalize){
                                                        foreach (var v in emu!.TimelineSeries[t]){ if(!double.IsNaN(v.MsPerIter)){ if (v.MsPerIter<minT) minT=v.MsPerIter; if (v.MsPerIter>maxT) maxT=v.MsPerIter; } }
                                                        if (minT==double.MaxValue){ minT=0; maxT=1; }
                                                        if (Math.Abs(maxT-minT) < 1e-9) { maxT = minT + 1; }
                                                    }
                                                    double y;
                                                    if (emu!.CompareNormalize){
                                                        var normVal = (pt.MsPerIter - minT)/(maxT-minT);
                                                        y = top+plotH - normVal*plotH;
                                                    } else {
                                                        y = top+plotH - (pt.MsPerIter/globalMax)*plotH;
                                                    }
                                                    var color = emu!.GetColorForTarget(t);
                                                    var r = emu!.HoverTarget == t ? 5 : 3;
                                                    <circle cx="@hoverX" cy="@y" r="@r" fill="@color" stroke="#000" stroke-width="1" />
                                                }
                                                // Inline tooltip box (fixed near top-left of plot)
                                                var tooltipData = emu!.HoverPointTooltipData;
                                                var boxX = left + 5; var boxY = top + 5; var lineH = 11; var lines = new List<string>{ $"{tooltipData?.TimeLabel}", $"ROM: {tooltipData?.Rom}", $"CPU {tooltipData?.CpuCore} | PPU {tooltipData?.PpuCore} | APU {tooltipData?.ApuCore}", $"{tooltipData?.Target}: {tooltipData?.MsPerIter:F3} ms/iter", $"R {tooltipData?.Reads} W {tooltipData?.Writes}", $"APU {tooltipData?.ApuCycles} OAM {tooltipData?.OamWrites}"};
                                                var boxW = 160.0; foreach(var l in lines){ boxW = Math.Max(boxW, 12 + l.Length * 6.0); }
                                                var boxH = lines.Count * lineH + 6;
                                                <rect x="@boxX" y="@boxY" width="@boxW" height="@boxH" fill="#222" stroke="#555" stroke-width="1" rx="4" />
                                                {
                                                    // Razor reserves <text>; build SVG text elements manually
                                                    var sbTxt = new System.Text.StringBuilder();
                                                    for (int i=0;i<lines.Count;i++)
                                                    {
                                                        var txt = lines[i]; var ty = boxY + 4 + (i+1)*lineH - 3; string fill; if (i==0) fill="#fff"; else if (i==1) fill="#9cf"; else if (i==2) fill="#bbb"; else fill="#ddd";
                                                        sbTxt.Append($"<text x='{boxX+4}' y='{ty}' font-size='10' fill='{fill}'>{txt}</text>");
                                                    }
                                                    @((MarkupString)sbTxt.ToString())
                                                }
                                            }
                                        }
                                    </svg>
                                </div>
                            }
                        </div>
                    </div>
                </div>
            }
            @if (!string.IsNullOrEmpty(emu?.DebugDumpText))
            {
                <div class="small text-monospace" style="white-space:pre-wrap;max-width:260px">@emu!.DebugDumpText</div>
            }
        </div>
    </details>
    </aside>
</div>

@code {
    // === Refactor Step 1: Introduce Emulator instance (will progressively replace inline logic) ===
    // We keep existing fields/methods temporarily; upcoming steps will delegate to 'emu'.
    private Emulator? emu;
    protected override void OnInitialized()
    {
        // Initialize emulator host if not already; reuse existing OnInitialized logic later migrated.
        if (emu == null)
        {
            emu = new Emulator(Logger, JS, Http, Status, ShaderProvider, Nav)
            {
                OnStateChanged = () => InvokeAsync(StateHasChanged)
            };
            emu.Initialize();
        }
        // Preserve original OnInitialized body below (will be removed once parity verified)
        // ORIGINAL OnInitialized logic follows ↓
    }
    // --- ORIGINAL FIELDS & METHODS (to be migrated/removed) ---
    // --- Controller instances now delegated to Emulator host ---
    private NesController nesController => emu!.Controller;
    private Corruptor corruptor => emu!.Corruptor;

    // --- Save state persistence enhancements ---
    // We compress (GZip) and, if still large, chunk state across multiple IndexedDB entries (kv store) to avoid size issues.
    // Manifest key: SaveKey+".manifest" holds JSON {version, compressed, parts}
    // Single-key format: prefix "GZ:" indicates base64 GZip payload.
    private const int SaveChunkCharSize = 900_000; // conservative chunk size (< ~1MB characters) to fit storage limits

    private NesEmulator.NES? nes
    {
        get => nesController.nes;
        set => nesController.nes = value;
    }
    // Framebuffer is now accessed directly via nesController.framebuffer
    // Replaced timer-based loop with requestAnimationFrame loop for smoother timing
    // Removed unused System.Timers.Timer to eliminate warning (requestAnimationFrame loop used instead)
    private bool[] inputState => nesController.inputState; // Up, Down, Left, Right, A, B, Select, Start
    
    // All NES controller state is now accessed directly via nesController instance
    

    private const string SaveKey = "nes_state_slot0";
    private bool stateBusy = false; // prevent overlapping save/load operations



    // Comparison modal delegates to Emulator methods


    // All corruptor and glitch harvester state is now accessed directly via corruptor instance
    // Shared DotNetObjectReference for JS interop callbacks (Theory 2 fix)
    private DotNetObjectReference<Nes>? _selfRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Delegate first-render setup and JS registrations to Emulator to avoid duplicates.
            if (emu != null)
            {
                await emu.EnsureInitialRenderAsync(true);
            }
        }
        // Initialize touch controller JS handlers when controller view visible
        if (nesController.IsFullscreen && emu!.UI.MobileFullscreenView == "controller" && !emu.UI.TouchControllerInitialized)
        {
            try
            {
                await JS.InvokeVoidAsync("nesInterop.initTouchController", "touch-controller");
                emu.UI.SetTouchControllerInitialized(true);
            }
            catch { }
        }
    }

    // Shader registration/refresh handled in Emulator.Initialize()/OnAfterRender; local duplicates removed.

    // ROM option model & storage for uploaded ROMs
    private List<RomOption> romOptions => nesController.RomOptions;
    private Dictionary<string, byte[]> uploadedRoms => nesController.UploadedRoms;
    private ElementReference fileInput;
    private bool IsBuiltInSelected => romOptions.FirstOrDefault(o => o.Key == nesController.RomFileName)?.BuiltIn ?? true;
    private IEnumerable<RomOption> FilteredRomOptions => string.IsNullOrWhiteSpace(nesController.RomSearch)
        ? romOptions.OrderBy(o=>o.BuiltIn ? 0 : 1).ThenBy(o=>o.Label)
        : romOptions.Where(o=>o.Label.Contains(nesController.RomSearch, StringComparison.OrdinalIgnoreCase) || o.Key.Contains(nesController.RomSearch, StringComparison.OrdinalIgnoreCase))
            .OrderBy(o=>o.BuiltIn ? 0 : 1).ThenBy(o=>o.Label);

    // Local ROM fetch removed (centralized in Emulator/NesController)

    // Quick Win 2: local Start/Pause/Reset wrappers removed. UI now calls emu.StartAsync/emu.PauseAsync/emu.ResetAsyncFacade directly.

    private void SetScale(double scale)
    {
        // Delegated to emulator public API
        if (emu == null) return;
        if (scale != 0.5 && scale != 1.0) return; // preserve original guard
        emu.SetScalePublic(scale);
    }

    private async Task ToggleFullscreen()
    {
        if (emu == null) return;
        await emu.ToggleFullscreenPublic();
    }

    // RefreshShaderOptions removed (now centralized in Emulator)

    // SetShader convenience removed; call emu.SetShaderPublic directly.

    // Duplicate FrameTick/RunFrame removed; Emulator hosts the JS-invokable frame loop.

    // Legacy famiclone toggle removed; use APU core selector instead

    private void SetApuCoreSelFromEmu()
    {
        if (nes == null) return;
        try
        {
            var id = nes.GetApuCoreId();
            var suffix = NesEmulator.CoreRegistry.ExtractSuffix(id, "APU_");
            nesController.ApuCoreSel = suffix;
            nesController.FamicloneOn = suffix.Equals("FMC", StringComparison.OrdinalIgnoreCase);
        }
        catch { }
    }

    // Apply currently selected (or persisted) core choices to emulator instance
    private void ApplySelectedCores()
    {
        if (nes == null) return;
        try
        {
            // CPU core generic selection (fallback to legacy enum if generic fails)
            if (!string.IsNullOrEmpty(nesController.CpuCoreSel))
            {
                if (!nes.SetCpuCore(nesController.CpuCoreSel))
                {
                    nes.SetCpuCore(nesController.CpuCoreSel == "FIX" ? NesEmulator.Bus.CpuCore.FIX : NesEmulator.Bus.CpuCore.FMC);
                }
            }
            // Generic reflection-based PPU selection (fallback to legacy enum only if needed)
            if (!nes.SetPpuCore(nesController.PpuCoreSel))
            {
                // fallback for older saved prefs
                nes.SetPpuCore(nesController.PpuCoreSel switch {
                    "FIX" => NesEmulator.Bus.PpuCore.FIX,
                    "LQ" => NesEmulator.Bus.PpuCore.LQ,
                    "CUBE" => NesEmulator.Bus.PpuCore.CUBE,
                    "BFR" => NesEmulator.Bus.PpuCore.BFR,
                    _ => NesEmulator.Bus.PpuCore.FMC
                });
            }
            if (!string.IsNullOrEmpty(nesController.ApuCoreSel))
            {
                if (!nes.SetApuCore(nesController.ApuCoreSel))
                {
                    // legacy fallback mapping for older core ids
                    switch (nesController.ApuCoreSel)
                    {
                        case "FMC": nes.SetApuCore(NesEmulator.NES.ApuCore.Jank); nesController.FamicloneOn = true; break;
                        case "QN": nes.SetApuCore(NesEmulator.NES.ApuCore.QuickNes); nesController.FamicloneOn = false; break;
                        default: nes.SetApuCore(NesEmulator.NES.ApuCore.Modern); nesController.FamicloneOn = false; break;
                    }
                }
                nesController.FamicloneOn = nesController.ApuCoreSel.Equals("FMC", StringComparison.OrdinalIgnoreCase) || nesController.FamicloneOn;
            }
        }
        catch { }
    // After core selection, auto-handle SoundFont if WF chosen
    }





    // Old famiclone-only handler removed; see OnApuCoreChanged



    // Unused (InputFile component removed)
    // Local InputFile handling removed (we import via JS in Emulator wrapper)

    // LoadRomUpload handler removed; input change calls emu.ImportRomsFromInputAsync(fileInput)

    private async Task RomSelectionChanged(ChangeEventArgs e)
    { if (e.Value is string value && !string.IsNullOrWhiteSpace(value)) { await nesController.RomSelectionChanged(value, async (rk)=> { nesController.RomFileName = rk; await LoadSelectedRom(); }); } }

    private Task LoadRomEntry(string key) { nesController.RomFileName = key; return LoadSelectedRom(); }

    private Task OnRomRowClicked(RomOption opt) => opt.Key == nesController.CurrentRomName ? Task.CompletedTask : nesController.OnRomRowClicked(opt, async k => { nesController.RomFileName = k; await LoadSelectedRom(); });

    private string GetDefaultBuiltInRomKey() => nesController.GetDefaultBuiltInRomKey();

    // DeleteRom removed; call emu.DeleteRomPublic(key)

    // ClearAllUploaded removed; call emu.ClearAllUploadedPublic()

    private void OnRomSearchChanged(ChangeEventArgs e)
    {
        nesController.RomSearch = e.Value?.ToString() ?? string.Empty;
    }

    // TriggerFileDialog removed; call emu.TriggerRomImportDialogPublic()

    // Local GetRomSizeDisplay removed; using nesController.GetRomSizeDisplay

    private Task LoadSelectedRom() => emu?.LoadSelectedRomPublic() ?? Task.CompletedTask;

    private Task ReloadCurrentRom() => emu?.ReloadCurrentRomPublic() ?? Task.CompletedTask;

    private Task DeleteCurrentRom()
    { if (IsBuiltInSelected) return Task.CompletedTask; return emu?.DeleteRomPublic(nesController.RomFileName) ?? Task.CompletedTask; }

    // LoadRomFromServer removed; use emu.ReloadCurrentRomPublic or emu.LoadSelectedRomPublic

    private Task OnRawFileSelected(ChangeEventArgs e)
    {
        try
        {
            if (e.Value is not null)
            {
                // Not directly accessible to read file bytes without InputFile component.
                // Provide status message placeholder.
                Status.Set("File input selected (reload using server loader for now).");
            }
        }
        catch (Exception ex)
        {
            nesController.ErrorMessage = ex.Message;
        }
        return Task.CompletedTask;
    }



    private void OpenBenchModal(){ emu!.SetBenchModalOpen(true); StateHasChanged(); }
    private void ToggleBenchAutoLoad(){ emu!.BenchAutoLoadState = !emu!.BenchAutoLoadState; }
    private void ToggleBenchSimple5x(){ emu!.BenchSimple5x = !emu!.BenchSimple5x; }

    private async Task RunBenchmarks()
    {
        if (nes == null || emu!.BenchRunning) { emu!.SetBenchModalOpen(true); return; }
        emu!.SetBenchModalOpen(true); emu!.SetBenchRunning(true); emu!.SetBenchResultsText(string.Empty); emu!.BenchBaselineRomName = string.Empty; StateHasChanged();
        try {
            bool wasRunning = nesController.IsRunning; // pause emulator for deterministic timing
            if (wasRunning && emu!=null) await emu.PauseAsync();
            if (emu!.BenchAutoLoadState)
            {
                // Attempt to load savestate slot 0 (baseline)
                await TryLoadBaselineStateForBenchmarks();
            }
            int w = emu!.BenchWeight; if (w<1) w=1; if (w>9) w=9; emu!.BenchWeight = w;
            var results = nes.RunBenchmarks(w);
            emu!.SetBenchResultsText(nes.FormatBenchmarksForDisplay(results));
            // Prepend ROM info if we resolved a baseline name
            var displayRom = string.IsNullOrWhiteSpace(emu!.BenchBaselineRomName) ? nesController.CurrentRomName : emu!.BenchBaselineRomName;
            emu!.SetBenchResultsText($"ROM: {displayRom}\n" + emu!.BenchResultsText);
            emu!.AddBenchHistoryEntry(displayRom, emu!.BenchResultsText);
            await PersistBenchHistory();
            if (wasRunning && emu!=null) await emu.StartAsync();
        } catch (Exception ex) { emu!.SetBenchResultsText("Benchmark error: "+ex.Message); }
        finally { emu!.SetBenchRunning(false); StateHasChanged(); }
    }

    // Runs five benchmark passes sequentially, reloading the baseline state before each pass.
    private async Task RunBenchmarks5x()
    {
        if (nes == null || emu!.BenchRunning) { emu!.SetBenchModalOpen(true); return; }
        emu!.SetBenchModalOpen(true); emu!.SetBenchRunning(true); emu!.SetBenchResultsText(string.Empty); emu!.BenchBaselineRomName = string.Empty; StateHasChanged();
        bool wasRunning = nesController.IsRunning;
        try {
            if (wasRunning && emu!=null) await emu.PauseAsync();
            int w = emu!.BenchWeight; if (w<1) w=1; if (w>9) w=9; emu!.BenchWeight = w;
            const int passes = 5;
            var passResults = new List<IReadOnlyList<NesEmulator.NES.BenchResult>>();
            for (int i=1;i<=passes;i++)
            {
                if (emu!.BenchAutoLoadState) await TryLoadBaselineStateForBenchmarks();
                var res = nes.RunBenchmarks(w);
                passResults.Add(res);
                emu!.SetBenchResultsText($"Running pass {i}/{passes}..."); // live status
                StateHasChanged();
            }
            // Aggregate: assume all passes produced same sequence lengths & names
            var averaged = new List<NesEmulator.NES.BenchResult>();
            if (passResults.Count>0)
            {
                var first = passResults[0];
                for (int idx=0; idx<first.Count; idx++)
                {
                    var name = first[idx].Name;
                    int iters = first[idx].Iterations; // assumed constant
                    double msTotalAvg = passResults.Average(p=>p[idx].MsTotal);
                    double msPerIterAvg = passResults.Average(p=>p[idx].MsPerIter);
                    long cpuReadsAvg = (long)passResults.Average(p=>p[idx].CpuReads);
                    long cpuWritesAvg = (long)passResults.Average(p=>p[idx].CpuWrites);
                    long apuCyclesAvg = (long)passResults.Average(p=>p[idx].ApuCycles);
                    long oamDmaWritesAvg = (long)passResults.Average(p=>p[idx].OamDmaWrites);
                    long batchFlushesAvg = (long)passResults.Average(p=>p[idx].BatchFlushes);
                    averaged.Add(new NesEmulator.NES.BenchResult(name, iters, msTotalAvg, msPerIterAvg, cpuReadsAvg, cpuWritesAvg, apuCyclesAvg, oamDmaWritesAvg, batchFlushesAvg));
                }
            }
            // Build display text summarizing passes and averaged table
            var sb = new System.Text.StringBuilder();
            var displayRom = string.IsNullOrWhiteSpace(emu!.BenchBaselineRomName) ? nesController.CurrentRomName : emu!.BenchBaselineRomName;
            sb.AppendLine($"ROM: {displayRom}");
            sb.AppendLine("Benchmark Results (5-pass average)");
            sb.AppendLine($"Each pass weight={w}; fields averaged over {passes} passes.");
            sb.AppendLine();
            sb.AppendLine("Target Cat\tIter\tTot(ms)\tPer(ms)\tReads\tWrites\tAPU Cyc\tOAM DMA\tBatches\tAvgBatch");
            foreach (var r in averaged)
            {
                sb.AppendLine($"{r.Name}\t{r.Iterations}\t{r.MsTotal:F2}\t{r.MsPerIter:F3}\t{r.CpuReads}\t{r.CpuWrites}\t{r.ApuCycles}\t{r.OamDmaWrites}\t{r.BatchFlushes}\t{r.AvgBatchSize:F1}");
            }
            if (!emu!.BenchSimple5x)
            {
                sb.AppendLine();
                sb.AppendLine("Raw Pass Summaries:");
                for (int i=0;i<passes;i++)
                {
                    sb.AppendLine($"-- Pass {i+1} --");
                    foreach (var r in passResults[i])
                    {
                        sb.AppendLine($"{r.Name}\t{r.Iterations}\t{r.MsTotal:F2}\t{r.MsPerIter:F3}\t{r.CpuReads}\t{r.CpuWrites}\t{r.ApuCycles}\t{r.OamDmaWrites}\t{r.BatchFlushes}\t{r.AvgBatchSize:F1}");
                    }
                    sb.AppendLine();
                }
            }
            emu!.SetBenchResultsText(sb.ToString().TrimEnd());
            // Single history entry containing averaged + raw details
            displayRom = string.IsNullOrWhiteSpace(emu!.BenchBaselineRomName) ? nesController.CurrentRomName : emu!.BenchBaselineRomName;
            emu!.AddBenchHistoryEntry(displayRom, emu!.BenchResultsText);
            await PersistBenchHistory();
        } catch (Exception ex) { emu!.SetBenchResultsText("Benchmark 5x error: "+ex.Message); }
    finally { emu!.SetBenchRunning(false); if (wasRunning && emu!=null) await emu.StartAsync(); StateHasChanged(); }
    }

    // Silent baseline state loader used exclusively for benchmarks to improve result stability.
    // Returns true if a savestate was found & loaded; false if none or on failure.
    private async Task<bool> TryLoadBaselineStateForBenchmarks()
    {
        try
        {
            // If another save/load op is in progress, skip to avoid contention.
            if (stateBusy) return false;
            // Detect manifest (chunked) first
            var manifestJson = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey + ".manifest");
            string full = string.Empty;
            if (!string.IsNullOrWhiteSpace(manifestJson) && manifestJson.Contains("parts"))
            {
                int parts = ExtractInt(manifestJson, "parts");
                bool compressed = manifestJson.Contains("\"compressed\":true");
                var sb = new System.Text.StringBuilder();
                for (int i = 0; i < parts; i++)
                {
                    var part = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey + $".part{i}");
                    if (string.IsNullOrEmpty(part)) return false; // missing part -> abort silently
                    sb.Append(part);
                }
                full = sb.ToString();
                if (compressed && full.StartsWith("GZ:"))
                {
                    full = DecompressString(full.Substring(3));
                }
            }
            else
            {
                var single = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey);
                if (string.IsNullOrWhiteSpace(single)) return false; // no baseline saved
                if (single.StartsWith("GZ:"))
                {
                    full = DecompressString(single.Substring(3));
                }
                else full = single;
            }

            if (string.IsNullOrEmpty(full)) return false;

            // If state embeds ROM data, ensure we load it (mirrors logic in LoadState but without UI noise)
            try
            {
                using var doc = System.Text.Json.JsonDocument.Parse(full);
                var root = doc.RootElement;
                // Capture romName metadata for benchmark labeling (do not change currentRomName here)
                try { if (root.TryGetProperty("romName", out var rnEl) && rnEl.ValueKind==System.Text.Json.JsonValueKind.String) emu!.BenchBaselineRomName = rnEl.GetString() ?? emu!.BenchBaselineRomName; } catch {}
                if (root.TryGetProperty("romData", out var romEl) && romEl.ValueKind == System.Text.Json.JsonValueKind.Array)
                {
                    int len = romEl.GetArrayLength();
                    if (len > 0)
                    {
                        var romBytes = new byte[len];
                        int idx = 0; foreach (var v in romEl.EnumerateArray()) { if (idx >= len) break; romBytes[idx++] = (byte)v.GetByte(); }
                        nes = new NesEmulator.NES { RomName = nesController.CurrentRomName };
                        nes.LoadROM(romBytes);
                        try { nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors); } catch {}
                        // Warm-up a frame
                        try { nes.RunFrame(); } catch {}
                        try { nesController.framebuffer = nes.GetFrameBuffer(); await JS.InvokeVoidAsync("nesInterop.drawFrame", "nes-canvas", nesController.framebuffer); } catch {}
                        emu!.RebuildMemoryDomainsPublic();
                        // If state contains romName metadata, capture for later UI update
                        try { if (root.TryGetProperty("romName", out var rnEl) && rnEl.ValueKind==System.Text.Json.JsonValueKind.String) { nes.RomName = rnEl.GetString() ?? nes.RomName; } } catch {}
                    }
                }
            }
            catch { /* ignore parse errors */ }

            nes?.LoadState(full);
            // Benchmark-specific behavior: force cores selected in the UI rather than those stored in the savestate.
            // This allows benchmarking different core implementations against the exact same memory/map baseline
            // without the savestate auto-switching cores under us. We intentionally reapply the selected cores
            // AFTER memory + mapper + ROM state are restored so that RAM/PRG/CHR data reflects the saved snapshot
            // while CPU/PPU/APU internal register state will correspond to a freshly switched core (cold state).
            // If in the future we want to attempt cross-core transfer of internal CPU/PPU/APU state, we could
            // extend ApplySelectedCores to capture and translate compatible fields, but for now the goal is
            // comparative performance, so a consistent memory baseline is sufficient.
            try { ApplySelectedCores(); } catch {}
            // Optional tiny warm-up to stabilize any core-initial one-time work before timing begins.
            try { nes?.RunFrame(); } catch {}
            try { if(nes!=null){ var savedName = nes.GetSavedRomName(full); if(!string.IsNullOrWhiteSpace(savedName)) { nes.RomName = savedName; nesController.CurrentRomName = savedName; nesController.RomFileName = savedName; } } } catch {}
            nesController.AutoStaticSuppressed = true; // ensure benchmarks display real frames
            try { nes?.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors); } catch {}
            try { await JS.InvokeVoidAsync("nesInterop.resetAudioTimeline"); } catch { }
            try { nesController.framebuffer = nes!.GetFrameBuffer(); await JS.InvokeVoidAsync("nesInterop.drawFrame", "nes-canvas", nesController.framebuffer); } catch {}
            return true;
        }
        catch
        {
            return false; // silent failure acceptable for benchmarks
        }
    }
    private void CloseBenchModal(){ emu!.SetBenchModalOpen(false); }
    private async Task CopyBenchResults()
    {
        try { if (!string.IsNullOrEmpty(emu!.BenchResultsText)) await JS.InvokeVoidAsync("navigator.clipboard.writeText", emu!.BenchResultsText); } catch { }
    }

    private async Task PersistBenchHistory()
    {
        try {
            var payload = System.Text.Json.JsonSerializer.Serialize(emu!.BenchHistory);
            await JS.InvokeVoidAsync("nesInterop.idbSetItem", Emulator.BenchHistoryKey, payload);
        } catch {}
    }
    private async Task LoadBenchHistory()
    {
        try {
            var json = await JS.InvokeAsync<string>("nesInterop.idbGetItem", Emulator.BenchHistoryKey);
            if (!string.IsNullOrWhiteSpace(json))
            {
                var list = System.Text.Json.JsonSerializer.Deserialize<List<BenchHistoryEntry>>(json);
                if (list != null) { emu!.SetBenchHistoryItems(list.OrderByDescending(e=>e.TimestampUtc).ToList()); }
            }
        } catch {}
    }
    private async Task ClearBenchHistory()
    {
        emu!.ClearBenchHistoryItems(); await PersistBenchHistory();
    }
    private void ShowHistoryEntry(string id)
    {
        emu!.SetCurrentBenchHistoryId(id == emu!.CurrentBenchHistoryId ? null : id);
    }
    private async Task DeleteBenchEntry(string id)
    {
        var e = emu!.BenchHistory.FirstOrDefault(x=>x.Id==id); if (e!=null){ emu!.RemoveBenchHistoryItem(id); await PersistBenchHistory(); }
    }

    // === Comparison Modal Logic ===
    private void OpenCompareModal()
    {
        emu!.OpenComparison();
    }
    private void CloseCompareModal()
    {
        emu!.CloseComparison(); 
    }

    // Memory domain building now centralized in Emulator.BuildMemoryDomains; use emu.RebuildMemoryDomainsPublic()

    // Inline editing of benchmark ROM/note
    private string? editingBenchRomId = null; private string editingBenchRomValue = string.Empty;
    private void StartBenchRomEdit(BenchHistoryEntry entry)
    {
        editingBenchRomId = entry.Id; editingBenchRomValue = entry.Rom; StateHasChanged();
    }
    private async Task CommitBenchRomEdit(string id)
    {
        if (editingBenchRomId != id) { editingBenchRomId=null; return; }
        // Delegate edit to Emulator to avoid modifying init-only record properties.
        var newVal = editingBenchRomValue?.Trim() ?? string.Empty;
        if (!string.IsNullOrEmpty(newVal))
        {
            emu!.EditingBenchRomValue = newVal;
            await emu!.CommitBenchRomEditPublic(id);
        }
        editingBenchRomId=null; editingBenchRomValue=string.Empty; StateHasChanged();
    }
    private async void HandleBenchRomEditKey(KeyboardEventArgs e, string id)
    {
        if (e.Key=="Enter") await emu!.CommitBenchRomEditPublic(id); else if (e.Key=="Escape") emu!.CancelBenchRomEditPublic();
    }

    private void OnCrashBehaviorChanged(ChangeEventArgs e)
    {
        if (e.Value is string v)
        {
            corruptor.CrashBehavior = v;
            try
            {
                if (nes != null)
                {
                    if (v == "IgnoreErrors") nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors);
                    else nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.RedScreen);
                }
            }
            catch { }
        }
    }

    // GetApproxSize moved into Emulator as a helper for memory domain sizing.

    private void DomainsChanged(ChangeEventArgs e)
    {
        // TODO: implement manual multiple select tracking if needed
    }
    private void OnIntensityChange(ChangeEventArgs e) { if (int.TryParse(e.Value?.ToString(), out var v)) corruptor.CorruptIntensity = Math.Clamp(v,1,65535); }
    private void OnIntensityBoxChange(ChangeEventArgs e) { OnIntensityChange(e); }




    public void Dispose()
    {
        try
        {
            JS.InvokeVoidAsync("nesInterop.stopEmulationLoop");
            // Dispose shared DotNetObjectReference to avoid leaks (Theory 2)
            _selfRef?.Dispose();
            _selfRef = null;
            // Navigation change detach handled inside Emulator after migration; legacy handler removal suppressed.
            Logger.LogInformation("BrokenNes disposed");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error disposing NES emulator");
        }
    }

    // Local UploadedRom class removed; using BrokenNes.Models.UploadedRom

    // (Boot method removed; auto-start handled in OnAfterRenderAsync and StartEmulation safeguards)

    // ===== JS Invokable wrappers for mobile fullscreen bottom bar =====
    [JSInvokable]
    public Task JsSaveState() => emu!.SaveStateAsyncPublic();
    [JSInvokable]
    public Task JsLoadState() => emu!.LoadStateAsyncPublic();
    [JSInvokable]
    public Task JsResetGame() => emu?.ResetAsyncFacade() ?? Task.CompletedTask;
    [JSInvokable]
    public void JsExitFullscreen()
    {
        nesController.IsFullscreen = false;
        StateHasChanged();
    }

    [JSInvokable]
    public void JsSetMobileFsView(string v) => emu?.UI.JsSetMobileFsView(v);
    [JSInvokable]
    public async Task OnRomsDropped(UploadedRom[] roms)
    {
        if (roms == null || roms.Length == 0) return;
        int added = 0;
        foreach (var f in roms)
        {
            if (string.IsNullOrWhiteSpace(f.name) || string.IsNullOrWhiteSpace(f.base64)) continue;
            try
            {
                var data = Convert.FromBase64String(f.base64);
                if (data.Length == 0) continue;
                uploadedRoms[f.name] = data;
                if (!romOptions.Any(o => o.Key == f.name))
                {
                    romOptions.Add(new RomOption { Key = f.name, Label = f.name + " (uploaded)", BuiltIn = false });
                }
                added++;
            }
            catch { }
        }
        nesController.RomFileName = roms.Last().name;
        await LoadSelectedRom();
        Status.Set($"Dropped {added} ROM(s).");
        if (!string.Equals(nesController.CurrentRomName, "test.nes", StringComparison.OrdinalIgnoreCase))
        {
            try { await JS.InvokeVoidAsync("nesInterop.focusCorruptorPanel"); } catch {}
        }
    }

    // ================= Helper methods for compressed & chunked saves =================
    private static string CompressString(string input)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(input);
        using var ms = new MemoryStream();
        using (var gzip = new System.IO.Compression.GZipStream(ms, System.IO.Compression.CompressionLevel.Fastest, true))
        {
            gzip.Write(bytes, 0, bytes.Length);
        }
        return Convert.ToBase64String(ms.ToArray());
    }

    private static string DecompressString(string base64)
    {
        var data = Convert.FromBase64String(base64);
        using var ms = new MemoryStream(data);
        using var gzip = new System.IO.Compression.GZipStream(ms, System.IO.Compression.CompressionMode.Decompress);
        using var outMs = new MemoryStream();
        gzip.CopyTo(outMs);
        return System.Text.Encoding.UTF8.GetString(outMs.ToArray());
    }

    private int ExtractInt(string json, string prop)
    {
        try
        {
            var token = "\"" + prop + "\":";
            int idx = json.IndexOf(token, StringComparison.Ordinal);
            if (idx >= 0)
            {
                idx += token.Length;
                int end = idx;
                while (end < json.Length && char.IsDigit(json[end])) end++;
                if (int.TryParse(json.Substring(idx, end - idx), out var val)) return val;
            }
        }
        catch { }
        return 0;
    }

    private async Task RemoveExistingChunks()
    {
        try
        {
            var manifestJson = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey + ".manifest");
            if (!string.IsNullOrWhiteSpace(manifestJson) && manifestJson.Contains("parts"))
            {
                int parts = ExtractInt(manifestJson, "parts");
                for (int i = 0; i < parts; i++)
                {
                    await JS.InvokeVoidAsync("nesInterop.removeStateKey", SaveKey + $".part{i}");
                }
                await JS.InvokeVoidAsync("nesInterop.removeStateKey", SaveKey + ".manifest");
            }
        }
        catch { }
    }
}

