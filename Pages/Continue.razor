@page "/continue"
@using NesEmulator
@using NesEmulator.Shaders
@using System.Text.Json
@using BrokenNes.Shared
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@inject IJSRuntime JS
@inject NavigationManager Nav
@inject BrokenNes.Services.GameSaveService SaveSvc
@inject IShaderProvider ShaderProvider

<div class="options-root continue-root">
  <h2 class="opt-title">DECK BUILDER</h2>

  @if (_overlayActive)
  {
    <div class="ach-arrive-overlay" aria-hidden="true">
      <div class="spotlight"></div>
    </div>
  }

  <section class="cont-header">
    <div class="hdr-main">
      <div class="lvl-title">
        <span class="chip">@CurrentLevel</span>
        <strong>@LevelTitle</strong>
      </div>
      <div class="lvl-status">
        <span class="status-chip @(LevelCleared?"cleared":"not-cleared") @((_overlayActive && _firstClearArrival)?"spotlit":null)" title="@(LevelCleared?"Achievement earned this level":"Earn at least one achievement to clear the level")">
          @(LevelCleared?"Cleared":"Not Cleared")
        </span>
      </div>
    </div>
    <div class="hdr-cards">
      <span class="small-note">Enforced:</span>
      @foreach (var c in EnforcedCards)
      {
        <button type="button" class="enf-chip" style="border-color:@c.border" title="View card" @onclick="(()=>OpenCardZoom(c.domain, c.id))">@c.label</button>
      }
    </div>
    <div class="hdr-cta">
  <button class="btn-next" disabled="@(!CanAdvanceLevel)" title="Requires level cleared and @RequiredStars stars" @onclick="AdvanceLevel">Level progression: @Stars/@RequiredStars ⭐</button>
    </div>
  </section>

  <section class="opt-section">
    <h3 class="opt-h3">Build Console</h3>
    <div class="core-grid">
      @CoreSlot("CPU", EnforcedCpu, SelectedCpu, OpenCpuPicker)
      @CoreSlot("PPU", EnforcedPpu, SelectedPpu, OpenPpuPicker)
      @CoreSlot("APU", EnforcedApu, SelectedApu, OpenApuPicker)
  @CoreSlot("SHADER", EnforcedShader, SelectedShader, OpenShaderPicker)
    </div>
  </section>

  <section class="opt-section">
    <h3 class="opt-h3">
      <button type="button"
              class="panel-toggle"
              aria-expanded="@(!CartridgeCollapsed)"
              aria-controls="cartridge-panel"
              title="Toggle Cartridge panel"
              @onclick="ToggleCartridge">
        Cartridge <span class="toggle-ico">@((CartridgeCollapsed?"▸":"▾"))</span>
      </button>
    </h3>
    @if (!CartridgeCollapsed)
    {
    <div class="rom-selector" id="cartridge-panel">
      <div class="rom-toolbar">
        <label class="small-note"><input type="checkbox" @bind="FilterCompatibleOnly" /> Only show compatible</label>
        <div class="rom-toolbar-right">
          <button type="button" class="rom-import-btn" @onclick="OpenImport">Import</button>
          <input class="rom-search" placeholder="Search title…" @bind="RomSearch" />
        </div>
      </div>
      @if (RomRowsFiltered.Count == 0)
      {
        <div class="rom-empty small-note">No games found or available in storage. Import the default DB in CRUD or add your own.</div>
      }
      else
      {
        <div class="rom-table" role="table" aria-label="ROM list">
          <div class="rom-thead" role="rowgroup">
            <div class="rom-tr rom-th" role="row">
              <div class="c-title" role="columnheader">Title</div>
              <div class="c-compat" role="columnheader">Compat</div>
              <div class="c-ach" role="columnheader">Stars</div>
            </div>
          </div>
          <div class="rom-tbody" role="rowgroup">
            @foreach (var g in RomRowsFiltered)
            {
              var disabled = !g.Compatible || !g.Present;
              <button type="button"
                      class="rom-tr rom-td @(SelectedGameId==g.Id?"selected":null) @(disabled?"disabled":null)"
                      role="row"
                      aria-disabled="@disabled"
                      title="@(disabled?(!g.Present?"ROM not present":"No achievements available"):"Select game")"
                      disabled="@disabled"
                      @onclick="(()=>SelectGameAsync(g.Id))">
                <div class="c-title" role="cell">
                  <div class="rom-title">@g.Title</div>
                  @if (!string.IsNullOrWhiteSpace(g.Subtitle)) { <div class="rom-sub">@g.Subtitle</div>; }
                </div>
                <div class="c-compat" role="cell"><span class="chip @(g.Compatible?"ok":"no")">@(g.Compatible?"Yes":"No")</span></div>
                <div class="c-ach" role="cell">@g.Completed/@g.Total</div>
              </button>
            }
          </div>
        </div>
      }
    </div>
    }
    
    <!-- Game info moved under Cartridge selector -->
    @if (!CartridgeCollapsed && SelectedGameId is null)
    {
      <div class="game-box small-note">Select a game to view details.</div>
    }
    else if (!CartridgeCollapsed && GameInfoItems.Count == 0)
    {
      <div class="game-box small-note">No information found for this game.</div>
    }
    else if (!CartridgeCollapsed)
    {
      <div class="game-box">
        <div class="game-grid" aria-label="Selected game details">
          @foreach (var kv in GameInfoItems)
          {
            <div class="game-row @(kv.Label=="Note"?"note":null)">
              <div class="label small-note">@kv.Label</div>
              <div class="value">@kv.Value</div>
            </div>
          }
        </div>
      </div>
    }
  </section>

  <section class="opt-section">
    <h3 class="opt-h3">Achievements</h3>
    @if (SelectedGame == null)
    {
      <div class="ach-box small-note">Select a compatible game to view achievements.</div>
    }
    else if (GameAchTotal == 0)
    {
      <div class="ach-box small-note">No achievements found for this game.</div>
    }
    else
    {
      <div class="ach-box">
        <div class="ach-summary" title="Completed/Total">
          <span class="small-note">@SelectedGame.Title</span>
          <strong>@GameAchCompleted/@GameAchTotal</strong>
          <span class="small-note">completed</span>
          @if (AchievementsFilteredCount != GameAchTotal)
          {
            <span class="small-note">(showing @AchievementsFilteredCount)</span>
          }
        </div>
        <div class="ach-toolbar">
          <label class="small-note"><input type="checkbox" @bind="HideCompleted" /> Hide completed</label>
          <input class="rom-search" placeholder="Search achievements…" @bind="AchSearch" />
        </div>
        @if (AchievementsFilteredCount == 0 && GameAchTotal > 0)
        {
          <div class="small-note">All achievements completed for this game.</div>
        }
        else
        {
          <ul class="ach-list" aria-label="Achievements for selected game">
            @foreach (var a in AchievementsFiltered)
            {
              <li class="ach-item @(a.Completed?"done":"todo")" title="@(a.Completed?"Completed":"Not completed")">
                <span class="ach-check" aria-hidden="true">@(a.Completed?"▣":"▢")</span>
                <span class="ach-title">@a.Title</span>
                @if (!string.IsNullOrWhiteSpace(a.Description))
                {
                  <span class="ach-desc small-note">@a.Description</span>
                }
                @if (a.Difficulty > 0)
                {
                  <span class="ach-diff chip" title="Difficulty">D@a.Difficulty</span>
                }
              </li>
            }
          </ul>
        }
      </div>
    }
  </section>

  <div class="opt-footer">
  @if (CanContinueGame)
  {
    <button class="opt-link start-btn unlocked"
      title="Resume from last trusted checkpoint"
      @onclick="StartContinueGame">Continue game</button>
  }
  else
  {
    <button class="opt-link start-btn @(CanStartGame?"unlocked":"locked")"
      disabled="@(!CanStartGame)"
      title="Build valid and game with achievements required"
      @onclick="StartStageGame">Start the game</button>
  }
    <a href="./deck-builder?skipHW=1" class="opt-link" @onclick="OnReturn" @onclick:preventDefault>RETURN</a>
  </div>
</div>

@if (ImportOpen)
{
  <div class="import-modal-backdrop" @onclick="CloseImport" @onclick:stopPropagation>
    <div class="import-modal" @onclick="StopClick" @onclick:stopPropagation>
      <h3 class="import-title">Import ROMs</h3>
      <div class="import-body">
        <div class="import-controls">
          <button type="button" class="rom-import-btn" @onclick="TriggerBrowse">Browse…</button>
          <input id="continue-import-input" type="file" accept=".nes" multiple style="display:none" @ref="ImportInputRef" @onchange="OnBrowseChanged" />
        </div>
        <div id="import-drop-area" class="import-drop">Drag and drop .nes files here</div>
        @if (PendingImports.Count == 0)
        {
          <div class="small-note">No files added yet.</div>
        }
        else
        {
          <ul class="import-list">
            @foreach (var f in PendingImports)
            {
              <li title="@f.Name">@f.Name <span class="small-note">(@f.SizeLabel)</span></li>
            }
          </ul>
        }
      </div>
      <div class="import-footer">
        <button type="button" class="rom-import-btn" disabled="@(PendingImports.Count==0)" @onclick="DoImportGamesAsync">Import games</button>
        <button type="button" class="rom-cancel-btn" @onclick="CloseImport">Cancel</button>
      </div>
    </div>
  </div>
}

@if (ZoomCard != null)
{
  <div class="card-modal-backdrop @(ModalClosing?"closing":"opening")" @onclick="CloseZoom">
    <div class="card-modal-content @(ModalClosing?"closing":"opening")" @onclick="CloseZoom">
      @((MarkupString)CardSvgRenderer.Render(ZoomCard))
    </div>
  </div>
}

@* Unlock Lootbox Modal *@
@if (UnlockModalOpen)
{
  <div class="unlock-modal-backdrop @(UnlockModalClosing?"closing":"opening")" @onclick="CloseUnlockModal">
    <div class="unlock-modal @(UnlockModalClosing?"closing":"opening")" @onclick:stopPropagation>
      <div class="unlock-header">
        <h3>New Cores Unlocked</h3>
      </div>
      <div class="unlock-body">
        <div class="loot-stage">
          @foreach (var it in UnlockItems)
          {
            <button class="loot-card" title="View" @onclick="(()=>OpenCardZoom(it.Card.Domain, it.Card.Id))">
              @((MarkupString)CardSvgRenderer.Render(it.Card, 142, 200))
            </button>
          }
        </div>
      </div>
      <div class="unlock-actions">
        <button class="unlock-ok" @onclick="CloseUnlockModal">OK</button>
      </div>
    </div>
  </div>
}

@* Core Picker Modal (Continue page aesthetic) *@
@if (CorePickerOpen)
{
  <div class="cont-cp-modal-backdrop" @onclick="CloseCorePicker">
    <div class="cont-cp-modal" @onclick:stopPropagation>
      <div class="cont-cp-header">
        <strong class="small-note">Select @CorePickerTitle</strong>
        <button type="button" class="cont-cp-close" @onclick="CloseCorePicker">Close</button>
      </div>
      <div class="cont-cp-body">
        @if (CorePickerItems.Count == 0)
        {
          <div class="small-note">No options available.</div>
        }
        else
        {
          <div class="cont-cp-list">
            @foreach (var it in CorePickerItems)
            {
              <div class="cont-cp-row">
                <button type="button" class="cont-cp-select" @onclick="(()=>OnCorePicked(it.Id))" title="Select">
                  <span class="pill pill-id @PillRateClass(it.Rating)">@it.Id</span>
                  <span class="row-main">@it.DisplayName</span>
                  <span class="row-meta">
                    <span class="meta-badge @CategoryClass(it.Category)">@(!string.IsNullOrWhiteSpace(it.Category)?it.Category:CorePickerDomain)</span>
                    <span class="meta-perf @PerfClass(it.Performance)" title="Performance">@it.Performance</span>
                    <span class="meta-stars" title="Rating">@RenderStars(it.Rating)</span>
                  </span>
                </button>
                <button type="button" class="cont-cp-view" title="View" @onclick:stopPropagation="true" @onclick="(()=>OpenCardZoom(it.Domain, it.Id))">View</button>
              </div>
            }
          </div>
        }
      </div>
    </div>
  </div>
}

@code {
  // State
  private int CurrentLevel = 1;
  private int Stars = 0;
  private string LevelTitle = " ";
  private int RequiredStars = 5;
  private bool CanContinueSelected =>
    _pendingDeckContinue && SelectedGame != null &&
    !string.IsNullOrWhiteSpace(SelectedGame.RomKey) &&
    string.Equals(_pendingDeckContinueRom, SelectedGame.RomKey, StringComparison.OrdinalIgnoreCase);
  private bool _pendingDeckContinue = false;
  private string? _pendingDeckContinueRom = null;
  private string? _pendingDeckContinueTitle = null;

  private (string domain, string id, string label, string border)[] EnforcedCards = Array.Empty<(string,string,string,string)>();

  // Enforced slots (null = not enforced)
  private string? EnforcedCpu = null;
  private string? EnforcedPpu = null;
  private string? EnforcedApu = null;
  private string? EnforcedShader = null;
  private string? EnforcedClock = null;

  // Player-selected (temporary choices for this level/session)
  private string? SelectedCpu = null;
  private string? SelectedPpu = null;
  private string? SelectedApu = null;
  private string? SelectedShader = null;

  private CoreCardModel? ZoomCard;
  private bool ModalClosing = false;
  private bool _zoomInit = false;

  // Unlock modal (lootbox-style)
  private bool UnlockModalOpen = false;
  private bool UnlockModalClosing = false;
  private readonly List<UnlockItem> UnlockItems = new();
  private sealed class UnlockItem { public string Domain { get; set; } = string.Empty; public string Id { get; set; } = string.Empty; public CoreCardModel Card { get; set; } = new(); }

  // Owned choices
  private IReadOnlyList<string> OwnedCpu = Array.Empty<string>();
  private IReadOnlyList<string> OwnedPpu = Array.Empty<string>();
  private IReadOnlyList<string> OwnedApu = Array.Empty<string>();
  private IReadOnlyList<string> OwnedShader = Array.Empty<string>();

  // ROM selector state
  private sealed class DbGame { public string id { get; set; } = string.Empty; public string? commonName { get; set; } public string? title { get; set; } public string? name { get; set; } public string? romKey { get; set; } public string? system { get; set; } public string? platform { get; set; } public string? notes { get; set; } public string? subtitle { get; set; } }
  private sealed class DbAchievement { public string id { get; set; } = string.Empty; public string gameId { get; set; } = string.Empty; public string? title { get; set; } }
  private sealed class RomRow { public string Id { get; set; } = string.Empty; public string Title { get; set; } = string.Empty; public string? Subtitle { get; set; } public string System { get; set; } = "NES"; public int Total { get; set; } public int Completed { get; set; } public bool Compatible => Total > 0; public string? Notes { get; set; } public bool Present { get; set; } public string? RomKey { get; set; } }
  private List<RomRow> RomRows = new();
  private List<RomRow> RomRowsFiltered => RomRows
    .Where(r => r.Present)
    .Where(r => !FilterCompatibleOnly || r.Compatible)
    .Where(r => string.IsNullOrWhiteSpace(RomSearch) || (r.Title?.Contains(RomSearch, StringComparison.OrdinalIgnoreCase) ?? false))
    .OrderByDescending(r => r.Compatible)
    .ThenBy(r => r.Title, StringComparer.OrdinalIgnoreCase)
    .ToList();
  private string? SelectedGameId = null;
  private RomRow? SelectedGame => RomRows.FirstOrDefault(r => r.Id == SelectedGameId);
  private bool FilterCompatibleOnly = true;
  private string RomSearch = string.Empty;
  private HashSet<string> UnlockedAchievementIds = new(StringComparer.OrdinalIgnoreCase);
  // Per-selected-game achievements view
  private sealed class UiAchievement
  {
    public string Id { get; set; } = string.Empty;
    public string Title { get; set; } = string.Empty;
    public string? Description { get; set; }
    public int Difficulty { get; set; }
    public string[] Tags { get; set; } = Array.Empty<string>();
    public bool Completed { get; set; }
  }
  private readonly List<UiAchievement> GameAchievements = new();
  private int GameAchCompleted = 0;
  private int GameAchTotal = 0;
  private bool HideCompleted = true;
  private string AchSearch = string.Empty;
  private IEnumerable<UiAchievement> AchievementsFiltered => GameAchievements
    .Where(a => !HideCompleted || !a.Completed)
    .Where(a => string.IsNullOrWhiteSpace(AchSearch) || (a.Title?.Contains(AchSearch, StringComparison.OrdinalIgnoreCase) ?? false) || (a.Description?.Contains(AchSearch, StringComparison.OrdinalIgnoreCase) ?? false))
    .OrderBy(a => a.Completed) // incomplete first
    .ThenBy(a => a.Title, StringComparer.OrdinalIgnoreCase);
  private int AchievementsFilteredCount => AchievementsFiltered.Count();
  // Import modal state
  private bool ImportOpen = false;
  private ElementReference ImportInputRef;
  private IDisposable? _importRef; // holds DotNetObjectReference to prevent GC
  private bool _importDropInit = false;
  private readonly List<ImportItem> PendingImports = new();

  protected override async Task OnInitializedAsync()
  {
    try { await JS.InvokeVoidAsync("nesInterop.ensureAudioContext"); } catch { }
    try { await JS.InvokeVoidAsync("nesInterop.applySavedAudioVolumes"); } catch { }
    try { await JS.InvokeVoidAsync("eval", "window.homePixelBgEnsure && window.homePixelBgEnsure();"); } catch { }

  // Load save, then fetch level data from continueDb and derive enforced chips and cost
  var save = await SaveSvc.LoadAsync();
  // Trusted continue marker from save (set early so ROM load can prioritize selection)
  _pendingDeckContinue = save.PendingDeckContinue;
  _pendingDeckContinueRom = save.PendingDeckContinueRom;
  _pendingDeckContinueTitle = save.PendingDeckContinueTitle;
  CurrentLevel = Math.Max(1, save.Level);
  Stars = save.Achievements?.Count ?? 0;
  UnlockedAchievementIds = new(save.Achievements ?? new());
  await LoadLevelFromDbAsync(CurrentLevel);
  // Initialize cleared status from save
  LevelCleared = save.LevelCleared;

  // Owned sets (used by pickers)
  OwnedCpu = (save.OwnedCpuIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();
  OwnedPpu = (save.OwnedPpuIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();
  OwnedApu = (save.OwnedApuIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();
  OwnedShader = (save.OwnedShaderIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();

  // Preselect from saved preferences (defaults FMC/PX). Enforced slots will visually override.
  ApplyPreferredSelections(save);

  await LoadRomsFromDbAsync();
  // Start the correct level music once data is loaded
  try { await PlayContinueLevelMusicAsync(); } catch { }

  // If arriving from NES with achievement flags, run the arrival UX
  TryParseArrivalFlags();
  // Default: expanded; collapse only on special arrivals
  CartridgeCollapsed = (_returnedArrival || _achievedArrival || _firstClearArrival);
  if (_achievedArrival && !_arrivalHandled)
  {
    _arrivalHandled = true;
    _ = RunAchievementArrivalFlowAsync();
  }
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      // Crossfade into DeckBuilder music for continuity
      try { await JS.InvokeVoidAsync("nesInterop.fadeOutAndStopTitleMusic"); } catch { }
  // The correct track will be started after save/level load completes in OnInitializedAsync
    }

    if (ZoomCard != null && !_zoomInit)
    {
      _zoomInit = true;
      try { await JS.InvokeVoidAsync("eval", @"(function(){window.nesUi=window.nesUi||{};window.nesUi.zoomModalSvg=function(){try{var host=document.querySelector('.card-modal-content');if(!host)return;var svg=host.querySelector('svg');if(!svg)return;svg.removeAttribute('width');svg.removeAttribute('height');svg.style.width='98vw';svg.style.maxWidth='98vw';svg.style.height='auto';svg.style.maxHeight='98vh';svg.style.display='block';}catch(e){}};window.nesUi.zoomModalSvg();})();"); } catch { }
    }

    // When import modal opens, wire drag/drop once
    if (ImportOpen && !_importDropInit)
    {
      _importDropInit = true;
      try
      {
        var self = DotNetObjectReference.Create(this);
        _importRef?.Dispose();
        _importRef = self;
        await JS.InvokeVoidAsync("nesInterop.initRomDragDrop", "import-drop-area", self);
      }
      catch { }
    }
  }

  // Per-level cleared flag (placeholder until per-level attribution exists)
  private bool LevelCleared = false;
  private bool CanAdvanceLevel => LevelCleared && Stars >= RequiredStars;
  // ===== Arrival UX state =====
  private bool _achievedArrival = false; // query flag achieved=1
  private bool _firstClearArrival = false; // query flag firstClear=1
  private bool _returnedArrival = false; // query flag returned=1 (from NES Return button)
  private bool _arrivalHandled = false;
  private bool _overlayActive = false; // darken screen
  // status chip will be spotlit via class when _overlayActive && _firstClearArrival
  // Cartridge panel collapse state (expanded by default, except on specific arrivals)
  private bool CartridgeCollapsed = false;

  private void TryParseArrivalFlags()
  {
    try
    {
      var uri = new Uri(Nav.Uri);
      var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
      var query = uri.Query;
      if (!string.IsNullOrEmpty(query))
      {
        var span = query.AsSpan();
        if (span.Length > 0 && span[0] == '?') span = span[1..];
        foreach (var part in span.ToString().Split('&', StringSplitOptions.RemoveEmptyEntries))
        {
          var kv = part.Split('=', 2);
          if (kv.Length > 0 && kv[0].Length > 0)
          {
            var key = Uri.UnescapeDataString(kv[0]);
            var val = kv.Length > 1 ? Uri.UnescapeDataString(kv[1]) : string.Empty;
            map[key] = val;
          }
        }
      }
      bool GetBool(string key)
      {
        if (!map.TryGetValue(key, out var v) || string.IsNullOrWhiteSpace(v)) return false;
        return v == "1" || v.Equals("true", StringComparison.OrdinalIgnoreCase) || v.Equals("yes", StringComparison.OrdinalIgnoreCase);
      }
  _achievedArrival = GetBool("achieved");
  _firstClearArrival = GetBool("firstClear");
  _returnedArrival = GetBool("returned");
    }
    catch { }
  }

  private async Task RunAchievementArrivalFlowAsync()
  {
    try
    {
      // Only run spotlight flow if the level wasn't cleared before
      if (_firstClearArrival)
      {
        _overlayActive = true; await InvokeAsync(StateHasChanged);
        // Play SFX for first clear flip (uses SFX bus and respects SFX volume)
        try
        {
          await JS.InvokeVoidAsync("eval", @"(function(){try{
            if(window.nesInterop && window.nesInterop.ensureAudioContext){ window.nesInterop.ensureAudioContext(); }
            var id='cont-ach-sfx';
            var el=document.getElementById(id);
            if(!el){
              el=document.createElement('audio');
              el.id=id;
              el.src='sfx/SFX01.mp3';
              el.preload='auto';
              el.style.display='none';
              document.body.appendChild(el);
            }
            if(window.nesInterop && typeof window.nesInterop.playSfxElement==='function'){
              window.nesInterop.playSfxElement(id);
            } else {
              try{ el.currentTime=0; el.volume=(window.nesInterop&&window.nesInterop.getSfxVolume? window.nesInterop.getSfxVolume():0.8); el.play().catch(function(){}); }catch{}
            }
          }catch{}})();");
        }
        catch { }
        LevelCleared = true; await SaveClearedFlagAsync(); await InvokeAsync(StateHasChanged);
        // Wait 3 second, then remove overlay
        try { await Task.Delay(2000); } catch { }
        _overlayActive = false; await InvokeAsync(StateHasChanged);
      }

      // After arrival flow, if eligible, auto-advance to next level
      // Recompute Stars from save for safety
      try
      {
        var save = await SaveSvc.LoadAsync();
        Stars = save.Achievements?.Count ?? Stars;
        LevelCleared = save.LevelCleared; // trust persisted value
      }
      catch { }
      if (CanAdvanceLevel)
      {
        // Small grace delay so the user sees the cleared state
        try { await Task.Delay(500); } catch { }
        await AdvanceLevel();
      }
    }
    catch { }
  }

  private void ToggleCartridge()
  {
    CartridgeCollapsed = !CartridgeCollapsed;
  }

  private async Task SaveClearedFlagAsync()
  {
    try
    {
      var save = await SaveSvc.LoadAsync();
      if (!save.LevelCleared)
      {
        save.LevelCleared = true;
        await SaveSvc.SaveAsync(save);
      }
    }
    catch { }
  }
  private bool BuildValid => (EnforcedCpu ?? SelectedCpu) != null
    && (EnforcedPpu ?? SelectedPpu) != null
    && (EnforcedApu ?? SelectedApu) != null
    && (EnforcedShader ?? SelectedShader) != null;
  private bool CanStartGame => BuildValid && SelectedGame != null && SelectedGame.Total > 0 && SelectedGame.Present;
  private bool CanContinueGame => CanStartGame && CanContinueSelected;

  private async Task AdvanceLevel()
  {
    try
    {
  var save = await SaveSvc.LoadAsync();
  if (!LevelCleared || Stars < RequiredStars) return;
  // Play level-advance SFX (SFX09)
  try
  {
    await JS.InvokeVoidAsync("eval", @"(function(){try{
      if(window.nesInterop && window.nesInterop.ensureAudioContext){ window.nesInterop.ensureAudioContext(); }
      var id='cont-advance-sfx';
      var el=document.getElementById(id);
      if(!el){ el=document.createElement('audio'); el.id=id; el.src='sfx/SFX09.mp3'; el.preload='auto'; el.style.display='none'; document.body.appendChild(el); }
      if(window.nesInterop && typeof window.nesInterop.playSfxElement==='function'){
        window.nesInterop.playSfxElement(id);
      } else { try{ el.currentTime=0; el.volume=(window.nesInterop&&window.nesInterop.getSfxVolume? window.nesInterop.getSfxVolume():0.8); el.play().catch(function(){}); }catch{} }
    }catch{}})();");
  }
  catch { }
  // Take note of enforced cores used in the level we are leaving
  var enforcedPairs = new List<(string domain, string id)>();
  if (!string.IsNullOrWhiteSpace(EnforcedCpu)) enforcedPairs.Add(("CPU", EnforcedCpu!));
  if (!string.IsNullOrWhiteSpace(EnforcedPpu)) enforcedPairs.Add(("PPU", EnforcedPpu!));
  if (!string.IsNullOrWhiteSpace(EnforcedApu)) enforcedPairs.Add(("APU", EnforcedApu!));
  if (!string.IsNullOrWhiteSpace(EnforcedShader)) enforcedPairs.Add(("SHADER", EnforcedShader!));
  if (!string.IsNullOrWhiteSpace(EnforcedClock)) enforcedPairs.Add(("CLOCK", EnforcedClock!));

  // Grant enforced cores into the owned lists (track newly added for celebration)
  var newlyAdded = new List<(string domain, string id)>();
  bool AddIfMissing(List<string> list, string id)
  {
    if (!list.Contains(id, StringComparer.OrdinalIgnoreCase)) { list.Add(id); return true; }
    return false;
  }
  save.OwnedCpuIds ??= new();
  save.OwnedPpuIds ??= new();
  save.OwnedApuIds ??= new();
  save.OwnedShaderIds ??= new();
  save.OwnedClockIds ??= new();
  // If level had no enforced cards, unlock 2–3 random 'Last' cards not yet owned
  if (enforcedPairs.Count == 0)
  {
    var bonus = await PickRandomLastCardsAsync(save);
    foreach (var p in bonus) enforcedPairs.Add(p);
  }
  foreach (var (domain, id) in enforcedPairs)
  {
    switch (domain)
    {
      case "CPU": if (AddIfMissing(save.OwnedCpuIds, id)) newlyAdded.Add(("CPU", id)); break;
      case "PPU": if (AddIfMissing(save.OwnedPpuIds, id)) newlyAdded.Add(("PPU", id)); break;
      case "APU": if (AddIfMissing(save.OwnedApuIds, id)) newlyAdded.Add(("APU", id)); break;
      case "SHADER": if (AddIfMissing(save.OwnedShaderIds, id)) newlyAdded.Add(("SHADER", id)); break;
      case "CLOCK": if (AddIfMissing(save.OwnedClockIds, id)) newlyAdded.Add(("CLOCK", id)); break;
    }
  }

  // Advance to next level in save
  save.Level = Math.Max(1, save.Level) + 1;
  // Reset the level-cleared flag for the newly advanced level
  save.LevelCleared = false;
  await SaveSvc.SaveAsync(save);
      // Reset selections for new level
      SelectedCpu = SelectedPpu = SelectedApu = null;
      CurrentLevel = save.Level;
      Stars = save.Achievements?.Count ?? 0;
  await LoadLevelFromDbAsync(CurrentLevel);
  // New level starts as not cleared (reflect persisted save)
  LevelCleared = save.LevelCleared;
  // Update music to match the new level
  try { await PlayContinueLevelMusicAsync(true); } catch { }
  // Refresh in-memory Owned lists to reflect new unlocks
  await RefreshOwnedFromSaveAsync();

  // Re-apply user's preferred selections for the new level (enforced slots will override visually)
  try { ApplyPreferredSelections(save); } catch { }

  // If any new cores were added, celebrate with a lootbox-style modal
  if (newlyAdded.Count > 0)
  {
    ShowUnlockModal(newlyAdded);
  }
  StateHasChanged();
    }
    catch { }
  }

  // Pick 2–3 random cards labeled 'Last' and not owned yet
  private async Task<List<(string domain, string id)>> PickRandomLastCardsAsync(BrokenNes.Models.GameSave save)
  {
    var result = new List<(string domain, string id)>();
    try
    {
      var json = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('cards'); return JSON.stringify(arr||[]); } catch(e){ return '[]'; } })()");
      if (string.IsNullOrWhiteSpace(json)) return result;
      using var doc = JsonDocument.Parse(json);
      var ownedCpu = new HashSet<string>(save.OwnedCpuIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var ownedPpu = new HashSet<string>(save.OwnedPpuIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var ownedApu = new HashSet<string>(save.OwnedApuIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var ownedShader = new HashSet<string>(save.OwnedShaderIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var ownedClock = new HashSet<string>(save.OwnedClockIds ?? new(), StringComparer.OrdinalIgnoreCase);
      var candidates = new List<(string domain, string id)>();
      foreach (var el in doc.RootElement.EnumerateArray())
      {
        var type = el.TryGetProperty("type", out var pt) ? (pt.GetString() ?? string.Empty) : string.Empty;
        if (!string.Equals(type, "Last", StringComparison.OrdinalIgnoreCase)) continue;
        var comp = el.TryGetProperty("id", out var pid) ? (pid.GetString() ?? string.Empty) : string.Empty; // DOMAIN_ID
        if (string.IsNullOrWhiteSpace(comp)) continue;
        var parts = comp.Split('_', 2, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length != 2) continue;
        var domain = parts[0].ToUpperInvariant();
        var id = parts[1];
        bool alreadyOwned = domain switch
        {
          "CPU" => ownedCpu.Contains(id),
          "PPU" => ownedPpu.Contains(id),
          "APU" => ownedApu.Contains(id),
          "SHADER" => ownedShader.Contains(id),
          "CLOCK" => ownedClock.Contains(id),
          _ => true
        };
        if (alreadyOwned) continue;
        candidates.Add((domain, id));
      }
      if (candidates.Count == 0) return result;
      int maxK = Math.Min(3, candidates.Count);
      int minK = Math.Min(2, maxK);
      int k; try { k = new Random().Next(minK, maxK + 1); } catch { k = minK; }
      var shuffled = candidates.OrderBy(_ => Guid.NewGuid()).ToList();
      for (int i = 0; i < k; i++) result.Add(shuffled[i]);
    }
    catch { }
    return result;
  }

  private async Task SelectGameAsync(string id)
  {
    SelectedGameId = id;
    await LoadAchievementsForGameAsync(id);
  await LoadGameInfoAsync(id);
  }

  // ===== Import modal logic =====
  private void OpenImport()
  {
    ImportOpen = true; _importDropInit = false; StateHasChanged();
  }
  private void CloseImport()
  {
    ImportOpen = false; StateHasChanged();
  }
  private void StopClick(MouseEventArgs _){ /* prevent backdrop close */ }
  private async Task TriggerBrowse()
  {
    try { await JS.InvokeVoidAsync("eval", "document.getElementById('continue-import-input')?.click()"); } catch { }
  }
  private async Task OnBrowseChanged(ChangeEventArgs _)
  {
    await AddFilesFromInputAsync();
  }
  public sealed class UploadedRom { public string name { get; set; } = string.Empty; public string base64 { get; set; } = string.Empty; }
  private sealed class ImportItem { public string Name { get; set; } = string.Empty; public string Base64 { get; set; } = string.Empty; public string SizeLabel { get; set; } = string.Empty; }
  private static string HumanSizeFromBase64(string b64)
  {
    try { var pad = b64.EndsWith("==") ? 2 : (b64.EndsWith("=") ? 1 : 0); var bytes = Math.Max(0, (b64.Length * 3 / 4) - pad); string[] u = {"B","KB","MB","GB"}; double val = bytes; int i=0; while(val>=1024 && i<u.Length-1){ val/=1024; i++; } return $"{val:0.#} {u[i]}"; } catch { return ""; }
  }
  private void AddPendingUnique(IEnumerable<UploadedRom> files)
  {
    var set = new HashSet<string>(PendingImports.Select(p => p.Name), StringComparer.OrdinalIgnoreCase);
    foreach (var f in files)
    {
      if (string.IsNullOrWhiteSpace(f.name) || string.IsNullOrWhiteSpace(f.base64)) continue;
      if (set.Contains(f.name)) continue; // skip duplicate by name
      PendingImports.Add(new ImportItem { Name = f.name, Base64 = f.base64, SizeLabel = HumanSizeFromBase64(f.base64) });
      set.Add(f.name);
    }
  }
  private async Task AddFilesFromInputAsync()
  {
    try
    {
      var arr = await JS.InvokeAsync<UploadedRom[]>("nesInterop.readSelectedRoms", ImportInputRef);
      if (arr != null && arr.Length > 0)
      {
        AddPendingUnique(arr);
        StateHasChanged();
      }
    }
    catch { }
  }
  [JSInvokable]
  public Task OnRomsDropped(UploadedRom[] roms)
  {
    try { if (roms != null && roms.Length > 0) { AddPendingUnique(roms); StateHasChanged(); } } catch { }
    return Task.CompletedTask;
  }
  private async Task DoImportGamesAsync()
  {
    if (PendingImports.Count == 0) return;
    try
    {
      foreach (var item in PendingImports)
      {
        try
        {
          // Save ROM blob to nesStorage
          try { await JS.InvokeVoidAsync("nesInterop.saveRom", item.Name, item.Base64); } catch { }
          // Put minimal Game record into continue-db if missing
          var nameJson = JsonSerializer.Serialize(item.Name);
          var b64Json = JsonSerializer.Serialize(item.Base64);
          var js = @"(async()=>{ try { if(!window.continueDb) return; await window.continueDb.open(); const name = __NAME__; const b64 = __B64__;
const bin = atob(b64);
const size = bin.length;
const title = name.replace(/\.nes$/i,'');
// Build Uint8Array from base64 string
const bytes = new Uint8Array(size); for (let i=0;i<size;i++){ bytes[i] = bin.charCodeAt(i) & 0xFF; }
// Compute iNES header signature (sha1 of first 16 bytes)
async function sha1Hex(buf){ const d = await crypto.subtle.digest('SHA-1', buf); const arr = new Uint8Array(d); let s=''; for (let b of arr){ s += b.toString(16).padStart(2,'0'); } return s; }
let headerSignature = '';
try { if (bytes.length >= 16) { const hdr = bytes.slice(0,16); const h = await sha1Hex(hdr); headerSignature = 'ines_' + h; } } catch {}
// Parse iNES sizes and trainer to locate PRG+CHR
function parseIdFromInes(u8){ try{ if(u8.length<16) return ''; if(!(u8[0]==0x4E && u8[1]==0x45 && u8[2]==0x53 && u8[3]==0x1A)) return ''; const prg16=u8[4]; const chr8=u8[5]; const f6=u8[6]; const hasTrainer = (f6 & 0x04) !== 0; let off=16 + (hasTrainer?512:0); let prgBytes = prg16*16384; let chrBytes = chr8*8192; if (off+prgBytes+chrBytes>u8.length){ prgBytes = Math.max(0, Math.min(prgBytes, u8.length-off)); chrBytes = Math.max(0, Math.min(chrBytes, u8.length-off-prgBytes)); }
  const prg = u8.slice(off, off+prgBytes); const chr = u8.slice(off+prgBytes, off+prgBytes+chrBytes);
  return {prg, chr}; } catch{ return ''; } }
let gameId = name; try{ const parts = parseIdFromInes(bytes); if (parts && parts.prg){ const concat = new Uint8Array(parts.prg.length + parts.chr.length); concat.set(parts.prg,0); if (parts.chr && parts.chr.length>0) concat.set(parts.chr, parts.prg.length); const sha = await sha1Hex(concat); gameId = 'nes_' + sha; } } catch {}
const id = gameId;
let g = await window.continueDb.get('games', id);
if(!g){ const rec = { id: id, title: title, system:'nes', romKey:name, builtIn:false, size:size, createdAt:new Date().toISOString(), status:'Nothing', commonName:'', note:'', headerSignature: headerSignature }; await window.continueDb.put('games', rec); } } catch(e) { console.warn('continue import failed', e); } } )()";
          js = js.Replace("__NAME__", nameJson).Replace("__B64__", b64Json);
          try { await JS.InvokeVoidAsync("eval", js); } catch { }
        }
        catch { }
      }
    }
    catch { }
    finally
    {
      ImportOpen = false; PendingImports.Clear();
      await LoadRomsFromDbAsync();
      StateHasChanged();
    }
  }

  private RenderFragment CoreSlot(string domain, string? enforced, string? selected, Action openPicker) => builder =>
  {
    int seq = 0; bool isLocked = !string.IsNullOrWhiteSpace(enforced);
    builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", $"core-slot{(isLocked?" locked":"")}");
      builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", "slot-title"); builder.AddContent(seq++, domain); builder.CloseElement();
      builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", "slot-body");
  // Card container or empty panel
  if (!isLocked && string.IsNullOrWhiteSpace(selected))
  {
    // Empty slot: show gray panel placeholder
    builder.OpenElement(seq++, "button");
    builder.AddAttribute(seq++, "type", "button");
    builder.AddAttribute(seq++, "class", "slot-empty");
    builder.AddAttribute(seq++, "title", $"Select {domain} core");
    builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, openPicker));
    builder.AddContent(seq++, "Select a Core");
    builder.CloseElement();
  }
  else
  {
    builder.OpenElement(seq++, "div");
    builder.AddAttribute(seq++, "class", "card-wrap");
    // Inline positioning + explicit size to guarantee overlay coverage
    builder.AddAttribute(seq++, "style", "position:relative; width:142px; height:200px; line-height:0; display:inline-block;");
            // Determine which card to render
            CoreCardModel cardModel;
            if (isLocked)
            {
              cardModel = BuildCard(domain, enforced!);
            }
            else // has selection
            {
              cardModel = BuildCard(domain, selected!);
            }
            var svg = CardSvgRenderer.Render(cardModel, 142, 200);
            builder.AddMarkupContent(seq++, svg);

            if (isLocked)
            {
              builder.OpenElement(seq++, "div");
              builder.AddAttribute(seq++, "class", "card-enforced-overlay");
              // Inline overlay styles to guarantee coverage over the SVG
              builder.AddAttribute(seq++, "style", "position:absolute;inset:0;background:rgba(0,0,0,0.75);display:flex;align-items:center;justify-content:center;z-index:1000;pointer-events:none;");
              builder.AddAttribute(seq++, "title", "Enforced by level");
              builder.AddAttribute(seq++, "aria-hidden", "true");

              // Centered lock icon behind text
              builder.OpenElement(seq++, "svg");
              builder.AddAttribute(seq++, "viewBox", "0 0 64 64");
              builder.AddAttribute(seq++, "aria-hidden", "true");
              builder.AddAttribute(seq++, "focusable", "false");
              builder.AddAttribute(seq++, "style", "position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:128px;height:128px;opacity:.22;fill:#fff;stroke:#fff;stroke-width:4;overflow:visible;");
              builder.AddMarkupContent(seq++, "<rect x='16' y='28' width='32' height='28' rx='5' ry='5'/><path d='M22 28 V20 a10 10 0 0 1 20 0 v8' fill='none' stroke-linecap='round' stroke-linejoin='round'/>");
              builder.CloseElement();

              builder.OpenElement(seq++, "div");
              builder.AddAttribute(seq++, "class", "enforced-text");
              builder.AddAttribute(seq++, "style", "color:#fff;font-size:0.9rem;font-weight:700;text-shadow:0 1px 2px rgba(0,0,0,0.8);");
              builder.AddContent(seq++, "Enforced");
              builder.CloseElement();
              builder.CloseElement();

              // Click to view enforced card (ensure full coverage like overlay)
              builder.OpenElement(seq++, "button");
              builder.AddAttribute(seq++, "type", "button");
              builder.AddAttribute(seq++, "class", "card-cover-btn");
              builder.AddAttribute(seq++, "style", "position:absolute;inset:0;background:transparent;border:0;padding:0;margin:0;cursor:pointer;z-index:1001;");
              builder.AddAttribute(seq++, "aria-label", $"View {domain} card");
              builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => OpenCardZoom(domain, enforced!)));
              builder.CloseElement();
            }
            else
            {
              // Make the whole card clickable to open the picker when not locked
              builder.OpenElement(seq++, "button");
              builder.AddAttribute(seq++, "type", "button");
              builder.AddAttribute(seq++, "class", "card-cover-btn");
              builder.AddAttribute(seq++, "style", "position:absolute;inset:0;background:transparent;border:0;padding:0;margin:0;cursor:pointer;z-index:1001;");
              builder.AddAttribute(seq++, "aria-label", $"Select {domain} core");
              builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, openPicker));
              builder.CloseElement();
            }
          builder.CloseElement(); // .card-wrap
  }
      builder.CloseElement(); // .slot-body
    builder.CloseElement(); // .core-slot
  };

  // Mirror the SVG card's rating-to-border palette for consistency
  private static string RatingToBorderColor(int rating)
  {
    return rating switch
    {
      <= 0 => "#6b7280", // slate/neutral
      1 => "#ef4444",    // red 500
      2 => "#f59e0b",    // amber 500
      3 => "#10b981",    // emerald 500
      4 => "#3b82f6",    // blue 500
      _ => "#a855f7"      // purple 500 for 5
    };
  }

  private void OpenCpuPicker() => OpenPicker("CPU");
  private void OpenPpuPicker() => OpenPicker("PPU");
  private void OpenApuPicker() => OpenPicker("APU");
  private void OpenShaderPicker() => OpenPicker("SHADER");

  private void OpenPicker(string domain)
  {
    // Open modal picker filtered to owned cores for this domain
    EnsureCoreMeta();
    CorePickerDomain = domain;
    CorePickerItems.Clear();
    switch (domain)
    {
      case "CPU":
        {
          var allowed = new HashSet<string>(OwnedCpu, StringComparer.OrdinalIgnoreCase);
          CorePickerItems.AddRange(_cpuMeta.Where(m => allowed.Contains(m.Id)));
        }
        break;
      case "PPU":
        {
          var allowed = new HashSet<string>(OwnedPpu, StringComparer.OrdinalIgnoreCase);
          CorePickerItems.AddRange(_ppuMeta.Where(m => allowed.Contains(m.Id)));
        }
        break;
      case "APU":
        {
          var allowed = new HashSet<string>(OwnedApu, StringComparer.OrdinalIgnoreCase);
          CorePickerItems.AddRange(_apuMeta.Where(m => allowed.Contains(m.Id)));
        }
        break;
      case "SHADER":
        {
          var allowed = new HashSet<string>(OwnedShader, StringComparer.OrdinalIgnoreCase);
          CorePickerItems.AddRange(_shaderMeta.Where(m => allowed.Contains(m.Id)));
        }
        break;
    }
    ApplyPickerSort();
    CorePickerOpen = true;
    StateHasChanged();
  }

  private async Task OpenCardZoom(string domain, string id)
  {
    ZoomCard = BuildCard(domain, id);
    ModalClosing = false; _zoomInit = false;
    await InvokeAsync(StateHasChanged);
  }

  private async Task CloseZoom()
  {
    if (ZoomCard == null) return;
    ModalClosing = true; await InvokeAsync(StateHasChanged);
    try { await Task.Delay(160); } catch { }
    ZoomCard = null; ModalClosing = false; _zoomInit = false;
  }

  private CoreCardModel BuildCard(string domain, string id)
  {
    // Fetch meta via reflection to enrich the card (best-effort)
    string name = id; string desc = string.Empty; int perf = 0; int rating = 0; string footer = domain;
    try
    {
      // Minimal iNES to allow core instantiation when needed
      var dummy = new byte[16 + 16 * 1024]; dummy[0]=0x4E; dummy[1]=0x45; dummy[2]=0x53; dummy[3]=0x1A; dummy[4]=1; dummy[5]=0; var cart = new Cartridge(dummy); var bus = new Bus(cart);
      switch (domain)
      {
        case "CPU":
          if (CoreRegistry.CpuTypes.TryGetValue(id, out var tCpu))
          {
            var cpu = CoreRegistry.CreateInstance<ICPU>(tCpu, bus);
            if (cpu != null) { name = cpu.CoreName ?? ("CPU_" + id); desc = cpu.Description ?? ""; perf = cpu.Performance; rating = Math.Clamp(cpu.Rating,0,5); footer = cpu.Category ?? domain; }
          }
          break;
        case "PPU":
          if (CoreRegistry.PpuTypes.TryGetValue(id, out var tPpu))
          {
            var ppu = CoreRegistry.CreateInstance<IPPU>(tPpu, bus);
            if (ppu != null) { name = ppu.CoreName ?? ("PPU_" + id); desc = ppu.Description ?? ""; perf = ppu.Performance; rating = Math.Clamp(ppu.Rating,0,5); footer = ppu.Category ?? domain; }
          }
          break;
        case "APU":
          if (CoreRegistry.ApuTypes.TryGetValue(id, out var tApu))
          {
            var apu = CoreRegistry.CreateInstance<IAPU>(tApu, bus);
            if (apu != null) { name = apu.CoreName ?? ("APU_" + id); desc = apu.Description ?? ""; perf = apu.Performance; rating = Math.Clamp(apu.Rating,0,5); footer = apu.Category ?? domain; }
          }
          break;
        case "SHADER":
          try
          {
            var sh = ShaderProvider?.GetById(id);
            if (sh != null)
            {
              name = !string.IsNullOrWhiteSpace(sh.DisplayName) ? sh.DisplayName : (sh.CoreName ?? ("SHADER_" + id));
              desc = sh.Description ?? string.Empty;
              perf = sh.Performance;
              rating = Math.Clamp(sh.Rating, 0, 5);
              footer = "SHADER";
            }
          }
          catch { }
          break;
        default:
          // Unknown domain (e.g., MAPPER/CLOCK/SHADER) — synthesize a reasonable card label
          name = $"{domain}_" + id; desc = string.Empty; perf = 0; rating = 0; footer = domain;
          break;
      }
    }
    catch { }
    return new CoreCardModel{ Id=id, ShortName=$"{domain}_{id}", DisplayName=name, Description=desc, Performance=perf, Rating=rating, FooterNote=footer, Domain=domain };
  }

  private string BuildRel(string path){ if(string.IsNullOrWhiteSpace(path)) return string.Empty; return path.TrimStart('/'); }

  private async Task OnReturn()
  {
    try { await JS.InvokeVoidAsync("eval", @"(function(){try{if(window.music){try{window.music.fadeOut&&window.music.fadeOut(700,true);}catch(e){}} setTimeout(function(){try{window.nesInterop&&window.nesInterop.playTitleMusic&&window.nesInterop.playTitleMusic();}catch(e){}},150);}catch(e){}})();"); } catch { }
    try { await Task.Delay(120); } catch { }
    Nav.NavigateTo(BuildRel("deck-builder?skipHW=1"), false);
  }

  // ===== Level data (continueDb) =====
  private sealed class DbLevel
  {
    public int index { get; set; }
    public string[]? requiredCards { get; set; }
    public int requiredStars { get; set; }
    public string? title { get; set; }
    public string? cardChallenge { get; set; }
  }

  private async Task LoadLevelFromDbAsync(int index)
  {
    try
    {
      // Ask continueDb for this level by primary key (index)
      var json = await JS.InvokeAsync<string>("eval", @$"(async()=>{{ try {{ if(!window.continueDb) return ''; await window.continueDb.open(); const rec = await window.continueDb.get('levels', {index}); return JSON.stringify(rec||null); }} catch(e) {{ return ''; }} }})()");
      DbLevel? level = string.IsNullOrWhiteSpace(json) ? null : JsonSerializer.Deserialize<DbLevel>(json);

      // Defaults if no record
      LevelTitle = level?.title ?? level?.cardChallenge ?? $"Level {index}";
  // Respect 0 as a valid value; only fallback to 5 if the level record is missing
  RequiredStars = level != null ? Math.Max(0, level.requiredStars) : 5;

  // Reset enforced slots
  EnforcedCpu = EnforcedPpu = EnforcedApu = EnforcedShader = EnforcedClock = null;

      // Parse requiredCards => fill per-domain enforced ids and build header chips
      var enforced = new List<(string domain, string id, string label, string border)>();
      foreach (var raw in (level?.requiredCards ?? Array.Empty<string>()))
      {
        if (string.IsNullOrWhiteSpace(raw)) continue;
        var parts = raw.Split('_', 2, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length != 2) continue;
        var domain = parts[0].ToUpperInvariant();
        var id = parts[1];
        switch (domain)
        {
          case "CPU": EnforcedCpu = id; break;
          case "PPU": EnforcedPpu = id; break;
          case "APU": EnforcedApu = id; break;
          case "SHADER": EnforcedShader = id; break;
          case "CLOCK": EnforcedClock = id; break;
        }
  // Skip displaying CLOCK in the enforced chips header
  if (domain == "CLOCK") continue;
  var card = BuildCard(domain, id);
  enforced.Add((domain, id, $"{domain}_"+id, RatingToBorderColor(Math.Clamp(card.Rating,0,5))));
      }
      // If DB had no enforced cards, do NOT enforce defaults — allow free play
      if (enforced.Count == 0)
      {
        EnforcedCpu = EnforcedPpu = EnforcedApu = EnforcedShader = EnforcedClock = null;
      }
      EnforcedCards = enforced.ToArray();
    }
    catch
    {
      // Fallbacks if continueDb not available: free play (no enforced cards)
      LevelTitle = $"Level {index}";
      RequiredStars = 5;
      EnforcedCpu = EnforcedPpu = EnforcedApu = EnforcedShader = EnforcedClock = null;
      EnforcedCards = Array.Empty<(string domain, string id, string label, string border)>();
    }
  }

  private async Task LoadRomsFromDbAsync()
  {
    try
    {
      var json = await JS.InvokeAsync<string>("eval", @"(async()=>{try{if(!window.continueDb)return '';await window.continueDb.open();const [games,ach]=await Promise.all([window.continueDb.getAll('games'),window.continueDb.getAll('achievements')]);return JSON.stringify({games,ach});}catch(e){return ''}})()");
      if (string.IsNullOrWhiteSpace(json)) return;
      using var doc = JsonDocument.Parse(json);
      var root = doc.RootElement;
      if (!root.TryGetProperty("games", out var gArr) || !root.TryGetProperty("ach", out var aArr)) return;

  // Read actual stored ROM names from nesStorage to reflect real availability
  var storedNamesJson = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { const arr = await (window.nesInterop ? window.nesInterop.getStoredRoms() : []); return JSON.stringify((arr||[]).map(x=>x && x.name || '')); } catch(e) { return '[]'; } })()");
  var storedNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
  try { using var ndoc = JsonDocument.Parse(string.IsNullOrWhiteSpace(storedNamesJson)?"[]":storedNamesJson); foreach (var n in ndoc.RootElement.EnumerateArray()) { var s = n.GetString(); if (!string.IsNullOrWhiteSpace(s)) storedNames.Add(s!); } } catch { }

    var games = new List<DbGame>();
      foreach (var g in gArr.EnumerateArray())
      {
        games.Add(new DbGame
        {
          id = g.GetProperty("id").GetString() ?? string.Empty,
      commonName = g.TryGetProperty("commonName", out var cn) ? cn.GetString() : null,
          title = g.TryGetProperty("title", out var t) ? t.GetString() : null,
          name = g.TryGetProperty("name", out var n) ? n.GetString() : null,
          romKey = g.TryGetProperty("romKey", out var rk) ? rk.GetString() : null,
          system = g.TryGetProperty("system", out var s) ? s.GetString() : null,
          platform = g.TryGetProperty("platform", out var p) ? p.GetString() : null,
          notes = g.TryGetProperty("notes", out var no) ? no.GetString() : null,
          subtitle = g.TryGetProperty("subtitle", out var sub) ? sub.GetString() : null,
        });
      }

      var achByGame = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
      var completedByGame = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
      foreach (var a in aArr.EnumerateArray())
      {
        var gid = a.TryGetProperty("gameId", out var gpe) ? (gpe.GetString() ?? string.Empty) : string.Empty;
        if (string.IsNullOrEmpty(gid)) continue;
        achByGame[gid] = (achByGame.TryGetValue(gid, out var c) ? c : 0) + 1;
        var aid = a.TryGetProperty("id", out var idpe) ? idpe.GetString() : null;
        if (!string.IsNullOrWhiteSpace(aid) && UnlockedAchievementIds.Contains(aid!))
        {
          completedByGame[gid] = (completedByGame.TryGetValue(gid, out var cc) ? cc : 0) + 1;
        }
      }

      RomRows = games.Select(g => new RomRow
      {
        Id = g.id,
        Title = !string.IsNullOrWhiteSpace(g.commonName) ? g.commonName! : (g.romKey ?? g.title ?? g.name ?? g.id),
        Subtitle = string.IsNullOrWhiteSpace(g.subtitle) ? null : g.subtitle,
        Total = achByGame.TryGetValue(g.id, out var tot) ? tot : 0,
        Completed = completedByGame.TryGetValue(g.id, out var comp) ? comp : 0,
        Notes = g.notes,
        Present = (!string.IsNullOrWhiteSpace(g.romKey) && storedNames.Contains(g.romKey!)),
        RomKey = g.romKey
      }).ToList();

      // Default select game: prefer the one flagged for trusted continue (matching ROM key), else first compatible + present
      if (SelectedGameId == null)
      {
        if (_pendingDeckContinue && !string.IsNullOrWhiteSpace(_pendingDeckContinueRom))
        {
          var match = RomRows.FirstOrDefault(r => r.Present && !string.IsNullOrWhiteSpace(r.RomKey) && string.Equals(r.RomKey, _pendingDeckContinueRom, StringComparison.OrdinalIgnoreCase));
          SelectedGameId = match?.Id;
        }
        SelectedGameId ??= RomRows.FirstOrDefault(r => r.Compatible && r.Present)?.Id;
      }
      else
      {
        // If the previously selected game is not present anymore, reselect
        var sel = RomRows.FirstOrDefault(r => r.Id == SelectedGameId);
        if (sel == null || !sel.Present)
        {
          if (_pendingDeckContinue && !string.IsNullOrWhiteSpace(_pendingDeckContinueRom))
          {
            var match = RomRows.FirstOrDefault(r => r.Present && !string.IsNullOrWhiteSpace(r.RomKey) && string.Equals(r.RomKey, _pendingDeckContinueRom, StringComparison.OrdinalIgnoreCase));
            SelectedGameId = match?.Id;
          }
          SelectedGameId ??= RomRows.FirstOrDefault(r => r.Compatible && r.Present)?.Id;
        }
      }
      if (!string.IsNullOrEmpty(SelectedGameId))
      {
        await LoadAchievementsForGameAsync(SelectedGameId);
        await LoadGameInfoAsync(SelectedGameId);
      }
    }
    catch { }
  }

  // ===== Game info panel (continueDb) =====
  private sealed record GameKv(string Label, string Value);
  private readonly List<GameKv> GameInfoItems = new();

  private static string PrettyLabel(string prop)
  {
    if (string.IsNullOrWhiteSpace(prop)) return string.Empty;
    // Insert spaces before capitals and numbers, then title-case
    var sb = new System.Text.StringBuilder();
    for (int i = 0; i < prop.Length; i++)
    {
      char c = prop[i];
      if (i > 0 && (char.IsUpper(c) && !char.IsUpper(prop[i - 1]) || char.IsDigit(c) && !char.IsDigit(prop[i - 1])))
        sb.Append(' ');
      sb.Append(c);
    }
    var s = sb.ToString().Replace("_", " ");
    // Special cases
    s = s.Replace("Rom Key", "ROM Key");
    s = s.Replace("Id", "ID");
    s = s.Replace("Url", "URL");
    // Capitalize first letter of words
    return System.Globalization.CultureInfo.InvariantCulture.TextInfo.ToTitleCase(s);
  }

  private static string HumanSize(long bytes)
  {
    string[] u = ["B", "KB", "MB", "GB"]; double val = bytes; int i = 0; while (val >= 1024 && i < u.Length - 1) { val /= 1024; i++; }
    return $"{val:0.#} {u[i]}";
  }

  private async Task LoadGameInfoAsync(string? gameId)
  {
    GameInfoItems.Clear();
    if (string.IsNullOrWhiteSpace(gameId)) { await InvokeAsync(StateHasChanged); return; }
    try
    {
      var gid = JsonSerializer.Serialize(gameId);
      var json = await JS.InvokeAsync<string>("eval", @$"(async()=>{{ try {{ if(!window.continueDb) return ''; await window.continueDb.open(); const rec = await window.continueDb.get('games', {gid}); return JSON.stringify(rec||null); }} catch(e) {{ return ''; }} }})()");
      if (!string.IsNullOrWhiteSpace(json))
      {
        using var doc = JsonDocument.Parse(json);
        var root = doc.RootElement;
        if (root.ValueKind == JsonValueKind.Object)
        {
          // First: synthesize Name = commonName (if set) else title
          string? commonName = root.TryGetProperty("commonName", out var pCN) ? pCN.GetString() : null;
          string? title = root.TryGetProperty("title", out var pTitle) ? pTitle.GetString() : null;
          var displayName = !string.IsNullOrWhiteSpace(commonName) ? commonName : (string.IsNullOrWhiteSpace(title) ? null : title);
          if (!string.IsNullOrWhiteSpace(displayName))
          {
            GameInfoItems.Add(new GameKv("Name", displayName!));
          }
          // Capture note/notes to add at bottom later
          string? noteVal = null;
          if (root.TryGetProperty("note", out var pNote) && pNote.ValueKind == JsonValueKind.String)
            noteVal = pNote.GetString();
          if (string.IsNullOrWhiteSpace(noteVal) && root.TryGetProperty("notes", out var pNotes) && pNotes.ValueKind == JsonValueKind.String)
            noteVal = pNotes.GetString();

          foreach (var prop in root.EnumerateObject())
          {
            var name = prop.Name;
            // Exclusions: ID, Created At (per request), and the raw name fields we synthesized
            if (string.Equals(name, "id", StringComparison.OrdinalIgnoreCase)) continue;
            if (string.Equals(name, "createdAt", StringComparison.OrdinalIgnoreCase)) continue;
            if (string.Equals(name, "commonName", StringComparison.OrdinalIgnoreCase)) continue;
            if (string.Equals(name, "title", StringComparison.OrdinalIgnoreCase)) continue;
            if (string.Equals(name, "name", StringComparison.OrdinalIgnoreCase)) continue;
            if (string.Equals(name, "builtIn", StringComparison.OrdinalIgnoreCase)) continue;
            if (string.Equals(name, "system", StringComparison.OrdinalIgnoreCase)) continue;
            if (string.Equals(name, "note", StringComparison.OrdinalIgnoreCase)) continue;
            if (string.Equals(name, "notes", StringComparison.OrdinalIgnoreCase)) continue;
            var valEl = prop.Value;
            string valueStr = string.Empty;
            switch (valEl.ValueKind)
            {
              case JsonValueKind.String:
                valueStr = valEl.GetString() ?? string.Empty;
                break;
              case JsonValueKind.Number:
                if (name.Equals("size", StringComparison.OrdinalIgnoreCase) && valEl.TryGetInt64(out var bytes))
                  valueStr = HumanSize(bytes);
                else valueStr = valEl.ToString();
                break;
              case JsonValueKind.True:
              case JsonValueKind.False:
                valueStr = valEl.GetBoolean() ? "Yes" : "No";
                break;
              default:
                valueStr = valEl.ToString();
                break;
            }
            if (!string.IsNullOrWhiteSpace(valueStr))
            {
              GameInfoItems.Add(new GameKv(PrettyLabel(name), valueStr));
            }
          }
          if (!string.IsNullOrWhiteSpace(noteVal))
          {
            GameInfoItems.Add(new GameKv("Note", noteVal!));
          }
        }
      }
    }
    catch { }

    // Fallback: synthesize from current SelectedGame row if DB read failed or empty
  if (GameInfoItems.Count == 0)
    {
      var sel = SelectedGame;
      if (sel != null)
      {
    void add(string label, string? val){ if (!string.IsNullOrWhiteSpace(val)) GameInfoItems.Add(new GameKv(label, val!)); }
  add("Name", sel.Title);
  add("Subtitle", sel.Subtitle);
  add("ROM Key", sel.RomKey);
  if (!string.IsNullOrWhiteSpace(sel.Notes)) add("Note", sel.Notes);
      }
    }
    await InvokeAsync(StateHasChanged);
  }

  private async Task LoadAchievementsForGameAsync(string gameId)
  {
    GameAchievements.Clear();
    GameAchCompleted = 0; GameAchTotal = 0;
    try
    {
      var gid = JsonSerializer.Serialize(gameId);
  var json = await JS.InvokeAsync<string>("eval", @$"(async()=>{{ try {{ if(!window.continueDb) return ''; await window.continueDb.open(); const gid = {gid}; let list = []; try {{ list = await window.continueDb.getAllFromIndex('achievements','by_gameId', gid) || []; }} catch(e) {{ }} if (!list || list.length===0) {{ const all = await window.continueDb.getAll('achievements'); list = (all||[]).filter(a => a && a.gameId === gid); }} const arr = (list||[]).map(a => {{ return {{ id: a.id||'', title: a.title||a.id||'', description: a.description||'', difficulty: (typeof a.difficulty==='number'?a.difficulty:0), tags: (Array.isArray(a.tags)?a.tags:[]) }}; }}); return JSON.stringify(arr); }} catch(e) {{ return ''; }} }})()");
      if (!string.IsNullOrWhiteSpace(json))
      {
        var tmp = new List<UiAchievement>();
        using var doc = JsonDocument.Parse(json);
        foreach (var e in doc.RootElement.EnumerateArray())
        {
          var id = e.TryGetProperty("id", out var pid) ? (pid.GetString() ?? string.Empty) : string.Empty;
          if (string.IsNullOrEmpty(id)) continue;
          var title = e.TryGetProperty("title", out var ptitle) ? (ptitle.GetString() ?? id) : id;
          var desc = e.TryGetProperty("description", out var pdesc) ? pdesc.GetString() : null;
          var diff = e.TryGetProperty("difficulty", out var pdiff) && pdiff.ValueKind==JsonValueKind.Number ? pdiff.GetInt32() : 0;
          bool completed = UnlockedAchievementIds.Contains(id);
          tmp.Add(new UiAchievement{ Id=id, Title=title, Description=desc, Difficulty=diff, Completed=completed });
        }
        // Keep correct totals and keep ALL achievements; the HideCompleted toggle controls filtering
        GameAchTotal = tmp.Count;
        GameAchCompleted = tmp.Count(a => a.Completed);
        GameAchievements.AddRange(tmp);
      }
    }
    catch { GameAchievements.Clear(); GameAchCompleted = 0; GameAchTotal = 0; }
    await InvokeAsync(StateHasChanged);
  }

  private async Task StartStageGame()
  {
    if (!CanStartGame) return;
    try
    {
      var sel = SelectedGame;
      if (sel == null || string.IsNullOrWhiteSpace(sel.RomKey)) return;
      // Build query string for stage mode
      string rom = Uri.EscapeDataString(sel.RomKey);
      string shader = Uri.EscapeDataString((EnforcedShader ?? SelectedShader) ?? string.Empty);
      string cpu = Uri.EscapeDataString((EnforcedCpu ?? SelectedCpu) ?? string.Empty);
      string ppu = Uri.EscapeDataString((EnforcedPpu ?? SelectedPpu) ?? string.Empty);
      string apu = Uri.EscapeDataString((EnforcedApu ?? SelectedApu) ?? string.Empty);
  var qs = new List<string> { "stage=1", $"rom={rom}", "achievements=1" };
      if (!string.IsNullOrWhiteSpace(shader)) qs.Add($"shader={shader}");
      if (!string.IsNullOrWhiteSpace(cpu)) qs.Add($"cpu={cpu}");
      if (!string.IsNullOrWhiteSpace(ppu)) qs.Add($"ppu={ppu}");
      if (!string.IsNullOrWhiteSpace(apu)) qs.Add($"apu={apu}");
      var url = "nes?" + string.Join('&', qs);
      // Soft fade audio and navigate
      try { await JS.InvokeVoidAsync("eval", @"(function(){ try{ if(window.music && typeof window.music.fadeOut==='function'){ window.music.fadeOut(500,true); } }catch(e){} })();"); } catch { }
      Nav.NavigateTo(url, false);
    }
    catch { }
  }

  private async Task StartContinueGame()
  {
  // Require same rules as Start + a trusted continue for the selected game
  if (!CanContinueGame) return;
    try
    {
      var sel = SelectedGame;
      if (sel == null || string.IsNullOrWhiteSpace(sel.RomKey)) return;

  // Keep the trusted continue marker so the user can retry as needed

      // Build query same as stage but without achievements param; we only want autoload
      string rom = Uri.EscapeDataString(sel.RomKey);
      string shader = Uri.EscapeDataString((EnforcedShader ?? SelectedShader) ?? string.Empty);
      string cpu = Uri.EscapeDataString((EnforcedCpu ?? SelectedCpu) ?? string.Empty);
      string ppu = Uri.EscapeDataString((EnforcedPpu ?? SelectedPpu) ?? string.Empty);
      string apu = Uri.EscapeDataString((EnforcedApu ?? SelectedApu) ?? string.Empty);
  // Enable achievements processing in NES view while autoloading the savestate
  var qs = new List<string> { "stage=1", $"rom={rom}", "autoloadState=1", "achievements=1" };
      if (!string.IsNullOrWhiteSpace(shader)) qs.Add($"shader={shader}");
      if (!string.IsNullOrWhiteSpace(cpu)) qs.Add($"cpu={cpu}");
      if (!string.IsNullOrWhiteSpace(ppu)) qs.Add($"ppu={ppu}");
      if (!string.IsNullOrWhiteSpace(apu)) qs.Add($"apu={apu}");
      var url = "nes?" + string.Join('&', qs);
      try { await JS.InvokeVoidAsync("eval", @"(function(){ try{ if(window.music && typeof window.music.fadeOut==='function'){ window.music.fadeOut(500,true); } }catch(e){} })();"); } catch { }
      Nav.NavigateTo(url, false);
    }
    catch { }
  }

  // ===== Continue music bound to level =====
  private static int DeckBuilderTrackNumberForLevel(int level)
  {
    if (level <= 0) level = 1;
    // Pattern repeats every 4 levels: 1->1, 2->4, 3->3, 4->2, then repeats
    var mod = ((level - 1) % 4 + 4) % 4;
    return mod switch { 0 => 1, 1 => 4, 2 => 3, 3 => 2, _ => 1 };
  }

  private static string DeckBuilderTrackPathForLevel(int level)
    => $"music/DeckBuilder{DeckBuilderTrackNumberForLevel(level)}.mp3";

  private async Task PlayContinueLevelMusicAsync(bool hardSwitch = false)
  {
    var want = DeckBuilderTrackPathForLevel(CurrentLevel);
    var wantJson = JsonSerializer.Serialize(want);
    var hardJson = hardSwitch ? "true" : "false";
    try
    {
      var script = @"(function(){
  try{
    var want=__WANT__;
    var hard=__HARD__;
    window.nesUi=window.nesUi||{};
    if(!window.nesUi.playDeckBuilderLevel){
      window.nesUi.playDeckBuilderLevel=function(w,hard){
        try{
          if(!window.music){ setTimeout(function(){ window.nesUi.playDeckBuilderLevel(w,hard); }, 200); return; }
          var cur=(typeof window.music.currentSrc==='function'?(window.music.currentSrc()||''):''),
              isP=(typeof window.music.isPlaying==='function'&&!!window.music.isPlaying());
          if(cur && cur.indexOf(w)!==-1 && isP) return;
          if(hard){
            try{ if(typeof window.music.stop==='function'){ window.music.stop(); } else if(typeof window.music.pause==='function'){ window.music.pause(); if(typeof window.music.setCurrentTime==='function'){ try{ window.music.setCurrentTime(0); }catch(e){} } } }catch(e){}
            try{ window.music.play(w,{loop:true,fadeInMs:0}); }catch(e){}
          } else if(isP && typeof window.music.fadeOut==='function'){
            try{ window.music.fadeOut(600,true); }catch(e){}
            setTimeout(function(){ try{ window.music.play(w,{loop:true,fadeInMs:800}); }catch(e){} }, 140);
          } else {
            try{ window.music.play(w,{loop:true,fadeInMs:700}); }catch(e){}
          }
        }catch(e){}
      };
    }
    window.nesUi.playDeckBuilderLevel(want, hard);
  }catch(e){}
})();";
      script = script.Replace("__WANT__", wantJson);
      script = script.Replace("__HARD__", hardJson);
      await JS.InvokeVoidAsync("eval", script);
    }
    catch { }
  }

  // ===== Core Picker (Continue) =====
  private bool CorePickerOpen = false;
  private string CorePickerDomain = string.Empty; // CPU/PPU/APU/SHADER
  private readonly List<PickerItem> CorePickerItems = new();
  private string CorePickerTitle => CorePickerDomain switch { "CPU" => "CPU Core", "PPU" => "PPU Core", "APU" => "APU Core", "SHADER" => "Shader", _ => "Core" };

  private sealed class PickerItem
  {
    public string Domain { get; set; } = string.Empty;
    public string Id { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public string? Description { get; set; }
    public int Performance { get; set; }
    public int Rating { get; set; }
    public string? Category { get; set; }
  }

  private void CloseCorePicker()
  {
    CorePickerOpen = false;
    CorePickerDomain = string.Empty;
    CorePickerItems.Clear();
  }

  private async Task OnCorePicked(string id)
  {
    try
    {
      switch (CorePickerDomain)
      {
        case "CPU": SelectedCpu = id; break;
        case "PPU": SelectedPpu = id; break;
        case "APU": SelectedApu = id; break;
        case "SHADER": SelectedShader = id; break;
      }
  // Persist user preference (do not write enforced selections; picker only opens when not enforced)
  await SavePreferredAsync(CorePickerDomain, id);
    }
    finally
    {
      CloseCorePicker();
      await InvokeAsync(StateHasChanged);
    }
  }

  private bool _coreMetaReady = false;
  private List<PickerItem> _cpuMeta = new();
  private List<PickerItem> _ppuMeta = new();
  private List<PickerItem> _apuMeta = new();
  private List<PickerItem> _shaderMeta = new();

  private void EnsureCoreMeta()
  {
    if (_coreMetaReady) return;
    try
    {
      // Minimal valid iNES ROM (NROM-128: 1x16KB PRG, 0 CHR)
      var dummy = new byte[16 + 16 * 1024];
      dummy[0] = 0x4E; dummy[1] = 0x45; dummy[2] = 0x53; dummy[3] = 0x1A;
      dummy[4] = 1; dummy[5] = 0; dummy[6] = 0; dummy[7] = 0;
      var cart = new Cartridge(dummy);
      var bus = new Bus(cart);

      var cpuDict = CoreRegistry.CreateInstances<ICPU>(bus, "CPU_");
      _cpuMeta = cpuDict.Select(kv => new PickerItem
      {
        Domain = "CPU",
        Id = kv.Key,
        DisplayName = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
        Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
        Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
        Rating = Math.Clamp(SafeGetStruct(() => kv.Value.Rating) ?? 0, 0, 5),
        Category = SafeGet(() => kv.Value.Category) ?? ""
      }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      var ppuDict = CoreRegistry.CreateInstances<IPPU>(bus, "PPU_");
      _ppuMeta = ppuDict.Select(kv => new PickerItem
      {
        Domain = "PPU",
        Id = kv.Key,
        DisplayName = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
        Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
        Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
        Rating = Math.Clamp(SafeGetStruct(() => kv.Value.Rating) ?? 0, 0, 5),
        Category = SafeGet(() => kv.Value.Category) ?? ""
      }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      var apuDict = CoreRegistry.CreateInstances<IAPU>(bus, "APU_");
      _apuMeta = apuDict.Select(kv => new PickerItem
      {
        Domain = "APU",
        Id = kv.Key,
        DisplayName = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
        Description = SafeGet(() => kv.Value.Description) ?? string.Empty,
        Performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
        Rating = Math.Clamp(SafeGetStruct(() => kv.Value.Rating) ?? 0, 0, 5),
        Category = SafeGet(() => kv.Value.Category) ?? ""
      }).OrderBy(m => m.Id, StringComparer.OrdinalIgnoreCase).ToList();

      _shaderMeta = new List<PickerItem>();
      try
      {
        // Build provider lookup for metadata (by IShader)
        var prov = new Dictionary<string, IShader>(StringComparer.OrdinalIgnoreCase);
        try { foreach (var s in ShaderProvider.All) prov[s.Id] = s; } catch { }

        // Controller-free: use provider order
        foreach (var s in prov.Values.OrderBy(v => v.Id, StringComparer.OrdinalIgnoreCase))
        {
          string? cat = null;
          try { if (s.Defines != null && s.Defines.TryGetValue("Category", out var c)) cat = c; } catch { }
          _shaderMeta.Add(new PickerItem
          {
            Domain = "SHADER",
            Id = s.Id,
            DisplayName = s.DisplayName ?? s.Id,
            Description = s.Description ?? string.Empty,
            Performance = s.Performance,
            Rating = Math.Clamp(s.Rating, 0, 5),
            Category = cat ?? string.Empty
          });
        }
      }
      catch { }
    }
    catch { }
    _coreMetaReady = true;
  }

  private static string PillRateClass(int rating)
  {
    var r = Math.Clamp(rating, 0, 5);
    return $"pill-rate-{r}";
  }

  private static string CategoryClass(string? category)
  {
    if (string.IsNullOrWhiteSpace(category)) return "cat-col-0";
    unchecked
    {
      int hash = 0;
      foreach (var ch in category)
      {
        hash = (hash * 31) + char.ToLowerInvariant(ch);
      }
      int idx = Math.Abs(hash) % 8; // 8 color buckets
      return $"cat-col-{idx}";
    }
  }

  private static string RenderStars(int rating)
  {
    var r = Math.Clamp(rating, 0, 5);
    return new string('\u2605', r) + new string('\u2606', 5 - r);
  }

  private static string PerfClass(int perf)
  {
    if (perf > 0) return "perf-pos";
    if (perf < 0) return "perf-neg";
    return string.Empty;
  }

  private static string? SafeGet(Func<string?> f){ try { return f(); } catch { return null; } }
  private static int? SafeGetStruct(Func<int> f){ try { return f(); } catch { return null; } }

  private void ApplyPickerSort()
  {
    if (CorePickerItems.Count <= 1) return;
    if (string.Equals(CorePickerDomain, "SHADER", StringComparison.OrdinalIgnoreCase))
    {
      CorePickerItems.Sort((a,b)=>
      {
        int ap = string.Equals(a.Id, "PX", StringComparison.OrdinalIgnoreCase) ? 0 : 1;
        int bp = string.Equals(b.Id, "PX", StringComparison.OrdinalIgnoreCase) ? 0 : 1;
        int cmp = ap.CompareTo(bp);
        if (cmp != 0) return cmp;
        return string.Compare(a.DisplayName, b.DisplayName, StringComparison.OrdinalIgnoreCase);
      });
    }
    else
    {
      CorePickerItems.Sort((a,b)=>
      {
        int ap = string.Equals(a.Id, "FMC", StringComparison.OrdinalIgnoreCase) ? 0 : 1;
        int bp = string.Equals(b.Id, "FMC", StringComparison.OrdinalIgnoreCase) ? 0 : 1;
        int cmp = ap.CompareTo(bp);
        if (cmp != 0) return cmp;
        return string.Compare(a.DisplayName, b.DisplayName, StringComparison.OrdinalIgnoreCase);
      });
    }
  }

  // ===== Unlock modal helpers =====
  private void ShowUnlockModal(IEnumerable<(string domain, string id)> items)
  {
    UnlockItems.Clear();
    foreach (var (domain, id) in items)
    {
      try
      {
        var card = BuildCard(domain, id);
        UnlockItems.Add(new UnlockItem { Domain = domain, Id = id, Card = card });
      }
      catch { }
    }
    if (UnlockItems.Count == 0) return;
    UnlockModalClosing = false;
    UnlockModalOpen = true;
    StateHasChanged();
  }

  private async Task CloseUnlockModal()
  {
    if (!UnlockModalOpen) return;
    UnlockModalClosing = true; await InvokeAsync(StateHasChanged);
    try { await Task.Delay(160); } catch { }
    UnlockModalOpen = false; UnlockModalClosing = false;
    UnlockItems.Clear();
    // Ensure Owned lists and picker are up-to-date after closing
    await RefreshOwnedFromSaveAsync();
    UpdateCorePickerItemsIfOpen();
    await InvokeAsync(StateHasChanged);
  }

  private async Task RefreshOwnedFromSaveAsync()
  {
    try
    {
      var save = await SaveSvc.LoadAsync();
      OwnedCpu = (save.OwnedCpuIds ?? new()).OrderBy(s => s, StringComparer.OrdinalIgnoreCase).ToArray();
      OwnedPpu = (save.OwnedPpuIds ?? new()).OrderBy(s => s, StringComparer.OrdinalIgnoreCase).ToArray();
      OwnedApu = (save.OwnedApuIds ?? new()).OrderBy(s => s, StringComparer.OrdinalIgnoreCase).ToArray();
      OwnedShader = (save.OwnedShaderIds ?? new()).OrderBy(s => s, StringComparer.OrdinalIgnoreCase).ToArray();
  // No direct UI for CLOCK in Continue, but refresh keeps state consistent
    }
    catch { }
  }

  private void UpdateCorePickerItemsIfOpen()
  {
    if (!CorePickerOpen || string.IsNullOrWhiteSpace(CorePickerDomain)) return;
    EnsureCoreMeta();
    CorePickerItems.Clear();
    switch (CorePickerDomain)
    {
      case "CPU":
        {
          var allowed = new HashSet<string>(OwnedCpu, StringComparer.OrdinalIgnoreCase);
          CorePickerItems.AddRange(_cpuMeta.Where(m => allowed.Contains(m.Id)));
        }
        break;
      case "PPU":
        {
          var allowed = new HashSet<string>(OwnedPpu, StringComparer.OrdinalIgnoreCase);
          CorePickerItems.AddRange(_ppuMeta.Where(m => allowed.Contains(m.Id)));
        }
        break;
      case "APU":
        {
          var allowed = new HashSet<string>(OwnedApu, StringComparer.OrdinalIgnoreCase);
          CorePickerItems.AddRange(_apuMeta.Where(m => allowed.Contains(m.Id)));
        }
        break;
      case "SHADER":
        {
          var allowed = new HashSet<string>(OwnedShader, StringComparer.OrdinalIgnoreCase);
          CorePickerItems.AddRange(_shaderMeta.Where(m => allowed.Contains(m.Id)));
        }
        break;
    }
    ApplyPickerSort();
  }

  // ===== Preferred selections persistence =====
  private void ApplyPreferredSelections(BrokenNes.Models.GameSave save)
  {
    // Helper to choose a safe selection that is owned; falls back to defaults.
    static string? Choose(string? pref, IReadOnlyList<string> owned, string def)
    {
      if (owned == null || owned.Count == 0) return null;
      var set = new HashSet<string>(owned, StringComparer.OrdinalIgnoreCase);
      if (!string.IsNullOrWhiteSpace(pref) && set.Contains(pref!)) return pref;
      if (!string.IsNullOrWhiteSpace(def) && set.Contains(def)) return def;
      return owned[0];
    }

    // Always set selected from preferences; enforced visuals will override rendering.
    SelectedCpu = Choose(save.PreferredCpuId ?? "FMC", OwnedCpu, "FMC");
    SelectedPpu = Choose(save.PreferredPpuId ?? "FMC", OwnedPpu, "FMC");
    SelectedApu = Choose(save.PreferredApuId ?? "FMC", OwnedApu, "FMC");
    SelectedShader = Choose(save.PreferredShaderId ?? "PX", OwnedShader, "PX");
  }

  private async Task SavePreferredAsync(string domain, string id)
  {
    try
    {
      var save = await SaveSvc.LoadAsync();
      switch (domain)
      {
        case "CPU": save.PreferredCpuId = id; break;
        case "PPU": save.PreferredPpuId = id; break;
        case "APU": save.PreferredApuId = id; break;
        case "SHADER": save.PreferredShaderId = id; break;
      }
      await SaveSvc.SaveAsync(save);
    }
    catch { }
  }
}
