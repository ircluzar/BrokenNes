@page "/"
@page "/nes"
@using System.Timers
@using System.Linq
@using Microsoft.Extensions.Logging
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.WebAssembly.Services
@inject ILogger<Nes> Logger
@inject IJSRuntime JS
@inject HttpClient Http
@inject StatusService Status
@inject NesEmulator.Shaders.IShaderProvider ShaderProvider


@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger" role="alert">
        <strong>⚠️ SYSTEM ERROR:</strong> @errorMessage
    </div>
}

@* Status moved to global StatusBar component *@

@if(!hasBooted)
{
    <div class="boot-overlay">
        <button class="boot-btn boot-btn-large" @onclick="Boot" autofocus aria-label="Boot emulator">BOOT</button>
    </div>
}

<div class="nes-grid">
    <section class="play-area">
        <div class="quick-controls btn-toolbar gap-2 flex-wrap justify-content-center mb-3" role="toolbar">
            <div class="btn-group">
                <button class="btn btn-success ctrl-btn" @onclick="StartEmulation" disabled="@(isRunning || nes == null)" title="Start (Play)" aria-label="Start">
                    <svg viewBox="0 0 100 100" class="ctrl-ico play" role="img" focusable="false"><polygon points="28,18 82,50 28,82" /></svg>
                </button>
                <button class="btn btn-warning ctrl-btn" @onclick="PauseEmulation" disabled="@(!isRunning)" title="Pause" aria-label="Pause">
                    <svg viewBox="0 0 100 100" class="ctrl-ico pause" role="img" focusable="false"><rect x="24" y="18" width="20" height="64" rx="6" /><rect x="56" y="18" width="20" height="64" rx="6" /></svg>
                </button>
                <button class="btn btn-danger ctrl-btn" @onclick="ResetEmulation" disabled="@(nes == null)" title="Reset" aria-label="Reset">
                    <svg viewBox="0 0 100 100" class="ctrl-ico reset" role="img" focusable="false"><path d="M50 18a32 32 0 1 1-22.63 9.37" fill="none" stroke="currentColor" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/><path d="M23 13 30 40 5 34" fill="currentColor" /></svg>
                </button>
            </div>
            <div class="btn-group">
                <div class="qc-select-stack">
                    <label for="shaderSelect" class="mini-label" title="Select video shader pass">Shader</label>
                    <select id="shaderSelect" class="btn btn-rf btn-select" title="Video shader" @onchange="OnShaderSelectChanged" value="@activeShaderKey" aria-label="Video Shader">
                        @foreach(var sh in shaderOptions){
                            <option value="@sh.Key">@sh.Label</option>
                        }
                    </select>
                </div>
                <div class="qc-select-stack">
                    <label for="apuCoreSelect" class="mini-label" title="Select audio processing core">APU Core</label>
                    <select id="apuCoreSelect" class="btn btn-fmc btn-select" title="Audio core mode" @onchange="OnApuCoreChanged" value="@apuCoreSel" aria-label="Audio Core">
                        @foreach(var opt in apuCoreOptions){ <option value="@opt">@opt</option> }
                    </select>
                </div>
                <div class="qc-select-stack">
                    <label for="cpuCoreSelect" class="mini-label" title="Select CPU core implementation">CPU Core</label>
                    <select id="cpuCoreSelect" class="btn btn-rf btn-select" title="CPU core" @onchange="OnCpuCoreChanged" value="@cpuCoreSel" aria-label="CPU Core">
                        @foreach(var opt in cpuCoreOptions){ <option value="@opt">@opt</option> }
                    </select>
                </div>
                <div class="qc-select-stack">
                    <label for="ppuCoreSelect" class="mini-label" title="Select PPU core implementation">PPU Core</label>
                    <select id="ppuCoreSelect" class="btn btn-rf btn-select" title="PPU core" @onchange="OnPpuCoreChanged" value="@ppuCoreSel" aria-label="PPU Core">
                        @foreach(var opt in ppuCoreOptions){ <option value="@opt">@opt</option> }
                    </select>
                </div>
            </div>
            <div class="btn-group">
                <button class="btn btn-load-state" @onclick="LoadState" disabled="@(nes==null)" title="Load state">Load</button>
                <button class="btn btn-save-state" @onclick="SaveState" disabled="@(nes==null)" title="Save state">Save</button>
            </div>
        </div>
    <div class="screen-shell @(emuScale == 0.5 ? "scale-50" : "scale-100")" id="screen-shell">
            <div class="overlay-status small">
                <div class="badges d-flex flex-wrap">
                    <span class="badge bg-dark-subtle text-dark me-1">FPS: @fps.ToString("F1")</span>
                    <span class="badge bg-dark-subtle text-dark me-1">State: @(isRunning ? "Running" : "Paused")</span>
                    <span class="badge bg-dark-subtle text-dark me-1">ROM: <strong>@currentRomName</strong></span>
                    <span class="badge bg-dark-subtle text-dark">Size: @FormatSize(lastLoadedRomSize)</span>
                    <span class="badge bg-dark-subtle text-dark ms-1">SF Core: @activeSfCoreDisplay</span>
                    @if (soundFontLayering)
                    {
                        <span class="badge bg-warning text-dark ms-1" title="Layering enabled: both cores may receive note events">Layering</span>
                    }
                </div>
                <div class="overlay-actions">
                    <button type="button" class="ov-btn @(emuScale==0.5 ? "active" : string.Empty) desktop-only" title="Scale 50%" @onclick="(()=>SetScale(0.5))">½×</button>
                    <button type="button" class="ov-btn @(emuScale==1 ? "active" : string.Empty) desktop-only" title="Scale 100%" @onclick="(()=>SetScale(1))">1×</button>
                    <button type="button" class="ov-btn" title="Toggle Fullscreen" @onclick="ToggleFullscreen">⛶</button>
                </div>
            </div>
            <div class="screen-aspect">
                <canvas id="nes-canvas" width="512" height="480" class="pixel-perfect responsive-canvas"></canvas>
            </div>
            @* Inline mobile fullscreen portrait tab bar (only shown via CSS when .mobile-fs-active & portrait) *@
            <div id="mobile-fs-view-bar">
                <button data-view="controller" class="view-btn @(mobileFsView=="controller"?"active":string.Empty)" @onclick="ViewController">Controller</button>
                <button data-view="rtc" class="view-btn @(mobileFsView=="rtc"?"active":string.Empty)" @onclick="ViewRtc">RTC</button>
                <button data-view="gh" class="view-btn @(mobileFsView=="gh"?"active":string.Empty)" @onclick="ViewGh">Glitch Harvester</button>
            </div>
            @* Mobile fullscreen (portrait) views container: always present in fullscreen portrait; controller now lives inside instead of toggling container visibility *@
            <div class="mobile-fs-extra-views">
                @if (mobileFsView == "controller")
                {
                    <div class="mobile-view controller-view" id="touch-controller">
                        <div class="controller-grid">
                            <div class="upper-row">
                                <div class="dpad">
                                    <div class="pad-btn" data-btn="up">▲</div>
                                    <div class="pad-btn" data-btn="left">◀</div>
                                    <div class="pad-btn" data-btn="right">▶</div>
                                    <div class="pad-btn" data-btn="down">▼</div>
                                    <div class="center-dot"></div>
                                </div>
                                <div class="actions">
                                    <div class="ab-cluster">
                                        <div class="btn-b" data-btn="b">B</div>
                                        <div class="btn-a" data-btn="a">A</div>
                                    </div>
                                </div>
                            </div>
                            <div class="start-select-row">
                                <div class="small-btn" data-btn="select">SELECT</div>
                                <div class="small-btn" data-btn="start">START</div>
                            </div>
                            <div class="system-row">
                                <button class="sys-btn" data-act="exit">Exit Fullscreen</button>
                                <button class="sys-btn" data-act="load">Load State</button>
                                <button class="sys-btn" data-act="save">Save State</button>
                            </div>
                        </div>
                    </div>
                }
                else if (mobileFsView == "rtc")
                {
                    <div class="mobile-view rtc-view small">
                        <div class="d-flex align-items-center justify-content-between mb-2">
                            <strong class="small mb-0">Real-Time Corruptor</strong>
                            <span class="text-muted small">@lastBlastInfo</span>
                        </div>
                        <div class="row g-3 flex-wrap">
                            <div class="col-12">
                                <label class="form-label small mb-1">Memory Domains</label>
                                <select multiple size="5" class="form-select form-select-sm" @onchange="DomainsChanged">
                                    @foreach (var d in memoryDomains)
                                    {
                                        <option value="@d.Key" selected="@d.Selected">@d.Label (@d.Size)</option>
                                    }
                                </select>
                            </div>
                            <div class="col-12">
                                <label class="form-label mb-1 small">Intensity (@corruptIntensity)</label>
                                <input type="range" min="1" max="4096" step="1" class="form-range" value="@corruptIntensity" @oninput="OnIntensityChange" />
                                <div class="d-flex gap-2 align-items-center mb-2 flex-wrap">
                                    <input type="number" min="1" max="4096" class="form-control form-control-sm intensity-box" value="@corruptIntensity" @onchange="OnIntensityBoxChange" />
                                    <button class="btn btn-sm btn-outline-danger" @onclick="Blast" disabled="@(nes==null || autoCorrupt)" title="Apply one-time corruption now">Blast</button>
                                    <button class="btn btn-sm @(autoCorrupt ? "btn-success" : "btn-outline-success")" @onclick="ToggleAutoCorruptButton" title="Toggle auto-corruption each frame">Auto: @(autoCorrupt ? "ON" : "OFF")</button>
                                    @if (!letItRipUsed)
                                    {
                                        <button class="btn btn-sm" style="background-color:#6f42c1;color:#fff;border-color:#6f42c1" @onclick="LetItRip" title="Intensity=1; select PRG ROM + System RAM; enable auto-corrupt; then hide button">Let it rip</button>
                                    }
                                </div>
                                <div class="row g-2 small">
                                    <div class="col-6">
                                        <label class="form-label mb-1 small">Blast Type</label>
                                        <select class="form-select form-select-sm" value="@blastType" @onchange="OnBlastTypeChanged">
                                            <option value="RANDOM">RANDOM</option>
                                            <option value="TILT">TILT</option>
                                            <option value="RANDOMTILT">RANDOMTILT</option>
                                            <option value="NOP">NOP</option>
                                            <option value="BITFLIP">BITFLIP</option>
                                        </select>
                                    </div>
                                    <div class="col-6 small text-muted d-flex align-items-end">Random writes across selected domains.</div>
                                </div>
                                <div class="mt-2 small text-muted fst-italic">Last: @lastBlastInfo</div>
                            </div>
                        </div>
                    </div>
                }
                else if (mobileFsView == "gh")
                {
                    <div class="mobile-view gh-view small">
                        <div class="gh-section mb-3">
                            <div class="d-flex flex-wrap gap-2 align-items-end">
                                <div class="flex-grow-1" style="min-width:140px;">
                                    <label class="form-label mb-1 small">New Base Name</label>
                                    <input class="form-control form-control-sm" placeholder="e.g. TitleScreen" @bind="ghNewBaseName" />
                                </div>
                                <button class="btn btn-sm btn-primary mt-3" @onclick="GhAddBaseState" disabled="@(nes==null)">Add Base</button>
                            </div>
                            <div class="mt-2">
                                <label class="form-label mb-1 small">Base States</label>
                                <select class="form-select form-select-sm" size="4" @onchange="GhOnBaseChanged" value="@ghSelectedBaseId">
                                    @foreach (var b in ghBaseStates)
                                    {
                                        <option value="@b.Id">@b.Name</option>
                                    }
                                </select>
                                <div class="d-flex gap-1 mt-2 flex-wrap">
                                    <button class="btn btn-sm btn-outline-secondary" @onclick="GhLoadSelectedBase" disabled="@(!GhHasSelectedBase)">Load</button>
                                    <button class="btn btn-sm btn-outline-danger" @onclick="GhDeleteSelectedBase" disabled="@(!GhHasSelectedBase)">Delete</button>
                                </div>
                            </div>
                        </div>
                        <div class="gh-section mb-3">
                            <label class="form-label mb-1 small">Actions (uses RTC settings)</label>
                            <div class="d-flex gap-2 flex-wrap">
                                <button class="btn btn-sm btn-warning" @onclick="GhCorruptAndStash" disabled="@(!GhHasSelectedBase || nes==null)">Corrupt &amp; Stash</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="GhClearStash" disabled="@(ghStash.Count==0)">Clear Stash</button>
                            </div>
                        </div>
                        <div class="gh-section mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <strong class="small mb-0">Stash (@ghStash.Count)</strong>
                            </div>
                            @if (ghStash.Count==0)
                            {
                                <div class="text-muted small fst-italic">(empty)</div>
                            }
                            else
                            {
                                <div class="gh-list">
                                    @foreach (var e in ghStash.OrderByDescending(e=>e.Created).Take(20))
                                    {
                                        <div class="gh-item">
                                            <div class="gh-item-main">
                                                <span class="gh-name" title="@e.Name">@e.Name</span>
                                                <span class="gh-meta">@e.Writes.Count w @e.Created.ToLocalTime().ToString("HH:mm:ss")</span>
                                            </div>
                                            <div class="gh-actions btn-group btn-group-sm">
                                                <button class="btn btn-outline-light" title="Replay" @onclick="(()=>GhReplayEntry(e, fromStockpile:false))">▶</button>
                                                <button class="btn btn-outline-success" title="Keep" @onclick="(()=>GhPromoteEntry(e))">Keep</button>
                                                <button class="btn btn-outline-danger" title="Discard" @onclick="(()=>GhDeleteStash(e.Id))">✕</button>
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                        <div class="gh-section">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <strong class="small mb-0">Stockpile (@ghStockpile.Count)</strong>
                            </div>
                            @if (ghStockpile.Count==0)
                            {
                                <div class="text-muted small fst-italic">(empty)</div>
                            }
                            else
                            {
                                <div class="gh-list">
                                    @foreach (var e in ghStockpile.OrderByDescending(e=>e.Created).Take(20))
                                    {
                                        <div class="gh-item">
                                            <div class="gh-item-main">
                                                @if (GhIsRenaming(e.Id))
                                                {
                                                    <input class="form-control form-control-sm" style="min-width:120px" value="@ghRenameText" @onchange="GhRenameChange" />
                                                }
                                                else
                                                {
                                                    <span class="gh-name" title="@e.Name">@e.Name</span>
                                                }
                                                <span class="gh-meta">@e.Writes.Count w • @GhFindBaseName(e.BaseStateId)</span>
                                            </div>
                                            <div class="gh-actions btn-group btn-group-sm">
                                                <button class="btn btn-outline-light" title="Replay" @onclick="(()=>GhReplayEntry(e, fromStockpile:true))">▶</button>
                                                @if (GhIsRenaming(e.Id))
                                                {
                                                    <button class="btn btn-outline-success" title="Save" @onclick="(()=>GhCommitRename(e.Id))">✔</button>
                                                    <button class="btn btn-outline-warning" title="Cancel" @onclick="GhCancelRename">↺</button>
                                                }
                                                else
                                                {
                                                    <button class="btn btn-outline-info" title="Rename" @onclick="(()=>GhBeginRename(e))">✎</button>
                                                }
                                                <button class="btn btn-outline-danger" title="Delete" @onclick="(()=>GhDeleteStock(e.Id))">✕</button>
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    </div>
                }
            </div>
        </div>
    </section>
    <aside class="side-panels">
    <details id="rom-manager-panel" class="panel-block" open>
        <summary>ROM Manager</summary>
        <div class="panel-content">
            <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                <input id="rom-search" type="text" class="form-control form-control-sm" placeholder="Search ROMs..." style="max-width:180px" @oninput="OnRomSearchChanged" value="@romSearch" />
                <button class="btn btn-sm btn-success" @onclick="TriggerFileDialog">Import</button>
                <button class="btn btn-sm btn-outline-secondary" @onclick="ReloadCurrentRom" disabled="@(string.IsNullOrEmpty(currentRomName))">Reload</button>
                @* Removed standalone Delete and Clear Uploaded buttons (row deletion + per-ROM Del button sufficient) *@
            </div>
            <div class="mb-2 small text-muted">Built-in + cached uploaded ROMs (persisted in browser storage). Click a row to load. Drag .nes files onto this list to import.</div>
            <div class="table-responsive" style="max-height:260px; overflow:auto;">
                <table id="rom-table" class="table table-sm table-dark align-middle mb-0 rom-table">
                    <thead class="table-secondary text-dark" style="position:sticky;top:0;">
                        <tr>
                            <th style="width:1%;"></th>
                            <th>Name</th>
                            <th style="width:90px;">Size</th>
                            <th style="width:80px;">Source</th>
                            <th style="width:70px;">Delete</th>
                        </tr>
                    </thead>
                    <tbody>
                        @if (!FilteredRomOptions.Any())
                        {
                            <tr><td colspan="5" class="text-center text-muted small">No ROMs match filter.</td></tr>
                        }
                        else
                        {
                            @foreach (var opt in FilteredRomOptions)
                            {
                                var isCurrent = opt.Key == currentRomName;
                                var sizeDisplay = GetRomSizeDisplay(opt.Key);
                                <tr class="@(isCurrent ? "table-primary" : "")" @onclick="(()=>OnRomRowClicked(opt))">
                                    <td>@(isCurrent ? "▶" : "")</td>
                                    <td class="text-truncate" style="max-width:200px;" title="@opt.Key">@opt.Label</td>
                                    <td>@sizeDisplay</td>
                                    <td>@(opt.BuiltIn ? "Built-in" : "Uploaded")</td>
                                    <td><button class="btn btn-sm btn-outline-danger" @onclick:stopPropagation="true" @onclick="(()=>DeleteRom(opt.Key))" disabled="@opt.BuiltIn">Del</button></td>
                                </tr>
                            }
                        }
                    </tbody>
                </table>
            </div>
            <div class="mt-2 small d-flex flex-wrap gap-3 text-muted">
                <div>Total: @FilteredRomOptions.Count() ROM(s)</div>
                <div>Uploaded: @uploadedRoms.Count</div>
                <div>Selected: @currentRomName</div>
            </div>
            <input @ref="fileInput" id="rom-upload" type="file" accept=".nes" class="d-none" @onchange="LoadRomUpload" multiple />
        </div>
    </details>

    <details id="corruptor-panel" class="panel-block corruptor-panel">
        <summary>Real-Time Corruptor</summary>
        <div class="panel-content corruptor-content">
            <div class="row g-3 flex-wrap">
                <div class="col-12 col-sm-5">
                    <label class="form-label small mb-1">Memory Domains</label>
                    <select multiple size="5" class="form-select form-select-sm" @onchange="DomainsChanged">
                        @foreach (var d in memoryDomains)
                        {
                            <option value="@d.Key" selected="@d.Selected">@d.Label (@d.Size)</option>
                        }
                    </select>
                    <div class="mt-2 small text-secondary">
                        Crash Mode:
                        <select class="form-select form-select-sm mt-1" @onchange="OnCrashBehaviorChanged" value="@crashBehavior">
                            <option value="RedScreen">Red Screen</option>
                            <option value="IgnoreErrors">Ignore Errors</option>
                        </select>
                    </div>
                </div>
                <div class="col-12 col-sm-7">
                    <div class="d-flex align-items-center justify-content-between mb-1">
                        <label class="form-label mb-0 small">Intensity</label>
                        <code class="small">@corruptIntensity</code>
                    </div>
                    <input type="range" min="1" max="4096" step="1" class="form-range" value="@corruptIntensity" @oninput="OnIntensityChange" />
                    <div class="d-flex gap-2 align-items-center mb-2 flex-wrap">
                        <input type="number" min="1" max="4096" class="form-control form-control-sm intensity-box" value="@corruptIntensity" @onchange="OnIntensityBoxChange" />
                        <button class="btn btn-sm btn-outline-danger" @onclick="Blast" disabled="@(nes==null || autoCorrupt)" title="Apply one-time corruption now">Blast</button>
                        <button class="btn btn-sm @(autoCorrupt ? "btn-success" : "btn-outline-success")" @onclick="ToggleAutoCorruptButton" title="Toggle auto-corruption each frame">Auto: @(autoCorrupt ? "ON" : "OFF")</button>
                        @if (!letItRipUsed)
                        {
                            <button class="btn btn-sm" style="background-color:#6f42c1;color:#fff;border-color:#6f42c1" @onclick="LetItRip" title="Intensity=1; select PRG ROM + System RAM; enable auto-corrupt; then hide button">Let it rip</button>
                        }
                    </div>
                    <div class="row g-2 small">
                        <div class="col-6">
                            <label class="form-label mb-1 small">Blast Type</label>
                            <select class="form-select form-select-sm" value="@blastType" @onchange="OnBlastTypeChanged">
                                <option value="RANDOM">RANDOM</option>
                                <option value="TILT">TILT</option>
                                <option value="RANDOMTILT">RANDOMTILT</option>
                                <option value="NOP">NOP</option>
                                <option value="BITFLIP">BITFLIP</option>
                            </select>
                        </div>
                        <div class="col-6 small text-muted d-flex align-items-end">Random writes across selected domains.</div>
                    </div>
                    <div class="mt-2 small text-muted fst-italic">Last: @lastBlastInfo</div>
                </div>
            </div>
        </div>
    </details>

    <details class="panel-block glitch-harvester-panel">
        <summary>Glitch Harvester</summary>
        <div class="panel-content glitch-harvester-content small">
            <div class="gh-section mb-3">
                <div class="d-flex flex-wrap gap-2 align-items-end">
                    <div class="flex-grow-1" style="min-width:140px;">
                        <label class="form-label mb-1 small">New Base Name</label>
                        <input class="form-control form-control-sm" placeholder="e.g. TitleScreen" @bind="ghNewBaseName" />
                    </div>
                    <button class="btn btn-sm btn-primary mt-3" @onclick="GhAddBaseState" disabled="@(nes==null)">Add Base</button>
                </div>
                <div class="mt-2">
                    <label class="form-label mb-1 small">Base States</label>
                    <select class="form-select form-select-sm" size="4" @onchange="GhOnBaseChanged" value="@ghSelectedBaseId">
                        @foreach (var b in ghBaseStates)
                        {
                            <option value="@b.Id">@b.Name</option>
                        }
                    </select>
                    <div class="d-flex gap-1 mt-2 flex-wrap">
                        <button class="btn btn-sm btn-outline-secondary" @onclick="GhLoadSelectedBase" disabled="@(!GhHasSelectedBase)">Load</button>
                        <button class="btn btn-sm btn-outline-danger" @onclick="GhDeleteSelectedBase" disabled="@(!GhHasSelectedBase)">Delete</button>
                    </div>
                </div>
            </div>
            <div class="gh-section mb-3">
                <label class="form-label mb-1 small">Actions (uses Real-Time Corruptor settings)</label>
                <div class="d-flex gap-2 flex-wrap">
                    <button class="btn btn-sm btn-warning" @onclick="GhCorruptAndStash" disabled="@(!GhHasSelectedBase || nes==null)">Corrupt &amp; Stash</button>
                    <button class="btn btn-sm btn-outline-secondary" @onclick="GhClearStash" disabled="@(ghStash.Count==0)">Clear Stash</button>
                </div>
            </div>
            <div class="gh-section mb-3">
                <div class="d-flex justify-content-between align-items-center mb-1">
                    <strong class="small mb-0">Stash History (@ghStash.Count)</strong>
                </div>
                @if (ghStash.Count==0)
                {
                    <div class="text-muted small fst-italic">(empty)</div>
                }
                else
                {
                    <div class="gh-list">
                        @foreach (var e in ghStash.OrderByDescending(e=>e.Created).Take(25))
                        {
                            <div class="gh-item">
                                <div class="gh-item-main">
                                    <span class="gh-name" title="@e.Name">@e.Name</span>
                                    <span class="gh-meta">@e.Writes.Count w @e.Created.ToLocalTime().ToString("HH:mm:ss")</span>
                                </div>
                                <div class="gh-actions btn-group btn-group-sm">
                                    <button class="btn btn-outline-light" title="Replay" @onclick="(()=>GhReplayEntry(e, fromStockpile:false))">▶</button>
                                    <button class="btn btn-outline-success" title="Keep (move to stockpile)" @onclick="(()=>GhPromoteEntry(e))">Keep</button>
                                    <button class="btn btn-outline-danger" title="Discard" @onclick="(()=>GhDeleteStash(e.Id))">✕</button>
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
            <div class="gh-section">
                <div class="d-flex justify-content-between align-items-center mb-1">
                    <strong class="small mb-0">Stockpile (@ghStockpile.Count)</strong>
                    <div class="d-flex gap-1">
                        <button class="btn btn-sm btn-outline-secondary" @onclick="GhExportStockpile" disabled="@(ghStockpile.Count==0)">Export</button>
                        <label class="btn btn-sm btn-outline-secondary mb-0">
                            Import<input type="file" class="d-none" accept="application/json" @onchange="GhImportStockpile" />
                        </label>
                    </div>
                </div>
                @if (ghStockpile.Count==0)
                {
                    <div class="text-muted small fst-italic">(empty)</div>
                }
                else
                {
                    <div class="gh-list">
                        @foreach (var e in ghStockpile.OrderByDescending(e=>e.Created))
                        {
                            <div class="gh-item">
                                <div class="gh-item-main">
                                    @if (GhIsRenaming(e.Id))
                                    {
                                        <input class="form-control form-control-sm" style="min-width:120px" value="@ghRenameText" @onchange="GhRenameChange" />
                                    }
                                    else
                                    {
                                        <span class="gh-name" title="@e.Name">@e.Name</span>
                                    }
                                    <span class="gh-meta">@e.Writes.Count w • @GhFindBaseName(e.BaseStateId)</span>
                                </div>
                                <div class="gh-actions btn-group btn-group-sm">
                                    <button class="btn btn-outline-light" title="Replay" @onclick="(()=>GhReplayEntry(e, fromStockpile:true))">▶</button>
                                    @if (GhIsRenaming(e.Id))
                                    {
                                        <button class="btn btn-outline-success" title="Save name" @onclick="(()=>GhCommitRename(e.Id))">✔</button>
                                        <button class="btn btn-outline-warning" title="Cancel" @onclick="GhCancelRename">↺</button>
                                    }
                                    else
                                    {
                                        <button class="btn btn-outline-info" title="Rename" @onclick="(()=>GhBeginRename(e))">✎</button>
                                    }
                                    <button class="btn btn-outline-danger" title="Delete" @onclick="(()=>GhDeleteStock(e.Id))">✕</button>
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
        </div>
    </details>

        <details class="panel-block">
        <summary>Controls</summary>
        <div class="panel-content key-grid">
            <div>Arrows: D-Pad</div>
            <div>Z: B</div>
            <div>X: A</div>
            <div>Space: Select</div>
            <div>Enter: Start</div>
        </div>
    </details>

        <details class="panel-block">
        <summary>Debug</summary>
        <div class="panel-content debug-mini">
            <div>Frames: @frameCount</div>
            <div>ROM Loaded: @(nes != null ? "Yes" : "No")</div>
            <div><button class="btn btn-sm btn-outline-secondary" @onclick="DumpState" disabled="@(nes==null)">Dump State</button></div>
            <div class="mt-2">
                <button class="btn btn-sm btn-outline-primary" @onclick="OpenBenchModal" disabled="@(nes==null /* allow opening even if benchRunning? keep disabled only if no nes */)">@(benchRunning?"Running...":"Run Benchmarks")</button>
                <button class="btn btn-sm btn-outline-info ms-1" @onclick="OpenCompareModal" disabled="@(benchHistory.Count<2)">Compare Results</button>
                <div class="form-check form-switch mt-2 small">
                    <input class="form-check-input" type="checkbox" id="evtSchedToggle" @onchange="ToggleEventScheduler" checked="@eventSchedulerOn" disabled="@(nes==null)" />
                    <label class="form-check-label" for="evtSchedToggle" title="Experimental: event-driven CPU->PPU/APU scheduling (scanline prototype)">Event Scheduler</label>
                </div>
                <div class="form-check form-switch mt-2 small">
                    <input class="form-check-input" type="checkbox" id="sfToggle" @onchange="ToggleSoundFontMode" checked="@soundFontMode" disabled="@(nes==null)" />
                    <label class="form-check-label" for="sfToggle" title="Play APU via WebAudio SoundFont/oscillators instead of raw PCM">SoundFont Mode</label>
                </div>
                @if (soundFontMode)
                {
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfSampleToggle" @onchange="ToggleSampleFont" checked="@sampleFont" />
                        <label class="form-check-label" for="sfSampleToggle" title="Use external sampled SoundFont library (falls back to oscillators if unavailable)">Sampled Instruments</label>
                    </div>
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfLayerToggle" @onchange="ToggleSoundFontLayering" checked="@soundFontLayering" />
                        <label class="form-check-label" for="sfLayerToggle" title="Experimental: allow both MNES & WF SoundFont cores to process notes simultaneously (debug/compare)">Layering</label>
                    </div>
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfDevLogToggle" @onchange="ToggleSfDevLogging" checked="@sfDevLogging" />
                        <label class="form-check-label" for="sfDevLogToggle" title="Verbose console logs for SoundFont core routing & throttling">SF Dev Logging</label>
                    </div>
                    <div class="form-check form-switch mt-2 small">
                        <input class="form-check-input" type="checkbox" id="sfOverlayToggle" @onchange="ToggleSfOverlay" checked="@sfOverlay" />
                        <label class="form-check-label" for="sfOverlayToggle" title="Display on-screen SoundFont diagnostics overlay (lead ms, counters)">SF Overlay</label>
                    </div>
                    <div class="mt-2 d-flex flex-wrap gap-2">
                        <button class="btn btn-sm btn-outline-warning" @onclick="FlushSoundFont" title="Force immediate silence of inactive/active SoundFont synths">SF Flush</button>
                        <button class="btn btn-sm btn-outline-secondary" @onclick="ShowSfDebug" title="Log SoundFont routing counters to console">SF Debug</button>
                    </div>
                }
            </div>
            @if (benchModalOpen)
            {
                <div class="modal-backdrop" style="position:fixed;inset:0;background:#000b;display:flex;align-items:flex-start;justify-content:center;z-index:5000;">
                    <div class="card shadow-lg" style="max-width:960px;width:95%;margin-top:2.5rem;">
                        <div class="card-header d-flex flex-wrap gap-2 justify-content-between align-items-center">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <strong class="small mb-0">Benchmarks</strong>
                                <span class="badge rounded-pill bg-dark text-light small">@benchHistory.Count saved</span>
                                <div class="input-group input-group-sm" style="width:60px;">
                                    <span class="input-group-text">W</span>
                                    <input type="number" min="1" max="9" class="form-control" style="padding-left:2px;padding-right:2px;font-size:.65rem;" @bind="benchWeight" @bind:after="(()=>{ if(benchWeight<1) benchWeight=1; if(benchWeight>9) benchWeight=9; })" />
                                </div>
                                <div class="btn-group btn-group-sm" role="group" aria-label="Benchmark options" style="gap:2px;">
                                    <button type="button" class="btn @(benchAutoLoadState?"btn-primary":"btn-outline-primary")" style="font-size:.60rem;padding:2px 4px;line-height:1.1;" @onclick="ToggleBenchAutoLoad" title="Load baseline savestate before each run">Auto</button>
                                    <button type="button" class="btn @(benchSimple5x?"btn-primary":"btn-outline-primary")" style="font-size:.60rem;padding:2px 4px;line-height:1.1;" @onclick="ToggleBenchSimple5x" title="5× shows only averaged results">5×Avg</button>
                                </div>
                                @if (benchRunning)
                                {
                                    <span class="spinner-border spinner-border-sm text-primary" role="status"></span>
                                }
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-outline-primary" @onclick="RunBenchmarks5x" disabled="@(nes==null || benchRunning)" title="Run 5 benchmark passes (reloads baseline each)" aria-label="Run five benchmark passes">@(benchRunning?"Running...":"Run 5×")</button>
                                <button class="btn btn-sm btn-outline-primary" @onclick="RunBenchmarks" disabled="@(nes==null || benchRunning)">@(benchRunning?"Running...":$"Run {benchWeight}x")</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="CloseBenchModal" aria-label="Close">Close</button>
                            </div>
                        </div>
                        <div class="card-body" style="max-height:80vh;overflow:auto;">
                            <div class="mb-4">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <h6 class="small text-uppercase text-muted mb-0">Current Run</h6>
                                    @if (!string.IsNullOrEmpty(benchResultsText))
                                    {
                                        <button class="btn btn-sm btn-outline-success" title="Copy results" @onclick="CopyBenchResults">Copy</button>
                                    }
                                </div>
                                @if (string.IsNullOrEmpty(benchResultsText))
                                {
                                    <div class="small fst-italic text-muted">@(benchRunning?"Running benchmarks...":"No run yet this session. Click 'Run Again'.")</div>
                                }
                                else
                                {
                                    <pre class="small mb-0" style="white-space:pre;">@benchResultsText</pre>
                                }
                            </div>
                            <div class="d-flex justify-content-between align-items-center mb-2 mt-2">
                                <h6 class="small text-uppercase text-muted mb-0">History</h6>
                                <div class="btn-group btn-group-sm">
                                    <button class="btn btn-outline-danger" title="Clear all benchmark history" @onclick="ClearBenchHistory" disabled="@(benchHistory.Count==0)">Clear</button>
                                </div>
                            </div>
                            @if (benchHistory.Count==0)
                            {
                                <div class="small text-muted fst-italic">(no previous runs saved)</div>
                            }
                            else
                            {
                                <table class="table table-sm table-dark align-middle small mb-0" style="--bs-table-bg:#1e1e1e;">
                                    <thead class="table-secondary text-dark">
                                        <tr>
                                            <th style="width:1%;">#</th>
                                            <th style="min-width:130px;">When</th>
                                            <th style="min-width:160px;">ROM</th>
                                            <th style="width:140px;">Cores</th>
                                            <th style="width:1%;">View</th>
                                            <th style="width:1%;">Del</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                    @foreach (var (entry,idx) in benchHistory.Select((e,i)=>(e,i)))
                                    {
                                        <tr class="@(currentBenchHistoryId==entry.Id?"table-primary":"")">
                                            <td>@(idx+1)</td>
                                            <td title="UTC: @entry.TimestampUtc.ToString("u")">@entry.TimestampUtc.ToLocalTime().ToString("HH:mm:ss")</td>
                                            <td class="text-truncate" style="max-width:220px;" title="@entry.Rom">
                                                @if (editingBenchRomId == entry.Id)
                                                {
                                                    <input class="form-control form-control-sm" style="min-width:160px;font-size:.65rem;padding:.15rem .25rem;" @bind="editingBenchRomValue" @onkeydown="(e)=>HandleBenchRomEditKey(e, entry.Id)" @onblur="(()=>CommitBenchRomEdit(entry.Id))" />
                                                }
                                                else
                                                {
                                                    <span class="d-inline-block text-truncate" style="max-width:220px; cursor:text;" @onclick="(()=>StartBenchRomEdit(entry))" title="Click to edit note">@entry.Rom</span>
                                                }
                                            </td>
                                            <td class="text-nowrap" title="CPU @entry.CpuCore / PPU @entry.PpuCore / APU @entry.ApuCore">@entry.CpuCore/@entry.PpuCore/@entry.ApuCore</td>
                                            <td><button class="btn btn-sm btn-outline-light" @onclick="(()=>ShowHistoryEntry(entry.Id))" title="View results">@(currentBenchHistoryId==entry.Id?"▾":"▶")</button></td>
                                            <td><button class="btn btn-sm btn-outline-danger" @onclick="(()=>DeleteBenchEntry(entry.Id))" title="Delete this entry">✕</button></td>
                                        </tr>
                                        @if (currentBenchHistoryId==entry.Id)
                                        {
                                            <tr class="table-secondary text-dark"><td colspan="6"><pre class="small mb-0" style="white-space:pre-wrap;max-height:320px;overflow:auto;">@entry.Display</pre></td></tr>
                                        }
                                    }
                                    </tbody>
                                </table>
                            }
                        </div>
                    </div>
                </div>
            }
            @if (compareModalOpen)
            {
                <div class="modal-backdrop" style="position:fixed;inset:0;background:#000b;display:flex;align-items:flex-start;justify-content:center;z-index:5000;">
                    <div class="card shadow-lg" style="max-width:1100px;width:98%;margin-top:2rem;">
                        <div class="card-header d-flex flex-wrap gap-2 justify-content-between align-items-center">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <strong class="small mb-0">Benchmark Comparison</strong>
                                <span class="badge bg-dark small">@benchHistory.Count total</span>
                                <span class="small text-muted">(oldest on left in charts)</span>
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-outline-secondary" @onclick="PlayDiffAnimation" disabled="@(diffAnimating || recentDiffRows.Count==0)">@((diffAnimating?"Playing...":"Play Diff"))</button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="CloseCompareModal">Close</button>
                            </div>
                        </div>
                        <div class="card-body" style="max-height:85vh;overflow:auto;">
                            @if (recentDiffRows.Count==0)
                            {
                                <div class="small text-muted fst-italic">Need at least two benchmark entries with structured metrics.</div>
                            }
                            else
                            {
                                <h6 class="small text-uppercase text-muted">Latest vs Previous</h6>
                                <div class="mb-2 small text-muted">Below: numeric diff table. A future update will render a side-by-side frame playback of the two benchmark runs for visual comparison.</div>
                                <div class="table-responsive mb-3">
                                    <table class="table table-sm table-dark align-middle small mb-0" style="--bs-table-bg:#1e1e1e;">
                                        <thead class="table-secondary text-dark">
                                            <tr>
                                                <th>Target</th>
                                                <th title="Current ms per iteration">Cur ms/iter</th>
                                                <th title="Prev ms per iteration">Prev ms/iter</th>
                                                <th title="Delta ms (negative is faster)">Δ ms</th>
                                                <th title="Percent change (negative is faster)">Δ %</th>
                                                <th title="CPU Reads delta">Reads Δ</th>
                                                <th title="CPU Writes delta">Writes Δ</th>
                                                <th title="APU Cycles delta">APU Δ</th>
                                                <th title="OAM DMA Writes delta">OAM Δ</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                        @foreach (var row in recentDiffRows)
                                        {
                                            var cls = highlightMetricName==row.Name?"table-primary":"";
                                            <tr class="@cls">
                                                <td>@row.Name</td>
                                                <td>@row.CurMs:F3</td>
                                                <td>@row.PrevMs:F3</td>
                                                <td class="@(row.DeltaMs<0?"text-success":row.DeltaMs>0?"text-danger":"")">@row.DeltaMs:F3</td>
                                                <td class="@(row.DeltaPct<0?"text-success":row.DeltaPct>0?"text-danger":"")">@row.DeltaPct:F2%</td>
                                                <td class="@(row.ReadsDelta<0?"text-success":row.ReadsDelta>0?"text-danger":"")">@row.ReadsDelta</td>
                                                <td class="@(row.WritesDelta<0?"text-success":row.WritesDelta>0?"text-danger":"")">@row.WritesDelta</td>
                                                <td class="@(row.ApuDelta<0?"text-success":row.ApuDelta>0?"text-danger":"")">@row.ApuDelta</td>
                                                <td class="@(row.OamDelta<0?"text-success":row.OamDelta>0?"text-danger":"")">@row.OamDelta</td>
                                            </tr>
                                        }
                                        </tbody>
                                    </table>
                                </div>
                            }
                            <div class="d-flex justify-content-between align-items-center mt-4 mb-1">
                                <h6 class="small text-uppercase text-muted mb-0">Timeline (@(compareNormalize?"% of range":"ms/iter"))</h6>
                                <div class="form-check form-switch small">
                                    <input class="form-check-input" type="checkbox" id="cmpNorm" @bind="compareNormalize" />
                                    <label class="form-check-label" for="cmpNorm">Normalize</label>
                                </div>
                            </div>
                            @if (timelineSeries.Count==0)
                            {
                                <div class="small text-muted fst-italic">No timeline data.</div>
                            }
                            else
                            {
                                <div class="d-flex flex-wrap gap-3 mb-2">
                                    @foreach (var s in allTargets)
                                    {
                                        <label class="form-check-label small me-2">
                                            <input type="checkbox" class="form-check-input me-1" @onchange="(()=>ToggleTarget(s))" checked="@visibleTargets.Contains(s)" /> @s
                                        </label>
                                    }
                                </div>
                                <div style="overflow:auto; position:relative;" @onmouseleave="TimelineMouseLeave">
                                    <svg width="1000" height="240" style="background:#111;border:1px solid #333;" @onmousemove="TimelineMouseMove">
                                        @if (visibleTargets.Count>0)
                                        {
                                            double globalMax = 0;
                                            foreach (var t in visibleTargets)
                                                foreach (var v in timelineSeries[t])
                                                    if (!double.IsNaN(v.MsPerIter) && v.MsPerIter > globalMax) globalMax = v.MsPerIter;
                                            if (globalMax<=0) { globalMax = 1; }
                                            var count = timelineOrder.Count;
                                            var plotW = 960.0; var plotH = 200.0; var left=30; var top=20;
                                            // axes
                                            <line x1="@left" y1="@(top)" x2="@left" y2="@(top+plotH)" stroke="#555" stroke-width="1" />
                                            <line x1="@left" y1="@(top+plotH)" x2="@(left+plotW)" y2="@(top+plotH)" stroke="#555" stroke-width="1" />
                                            // y labels
                                            @if (!compareNormalize) {
                                                for (int i=0;i<=4;i++){
                                                    var yVal = globalMax*i/4.0; var y = top+plotH - (yVal/globalMax)*plotH;
                                                    @:<text x="5" y="@(y+4)" font-size="9" fill="#888">@yVal.ToString("F2")</text>
                                                    <line x1="@left" y1="@y" x2="@(left+plotW)" y2="@y" stroke="#222" stroke-width="1" />
                                                }
                                            } else {
                                                for (int i=0;i<=4;i++){
                                                    var yPct = i*25; var y = top+plotH - (i/4.0)*plotH;
                                                    @:<text x="5" y="@(y+4)" font-size="9" fill="#888">@yPct%</text>
                                                    <line x1="@left" y1="@y" x2="@(left+plotW)" y2="@y" stroke="#222" stroke-width="1" />
                                                }
                                            }
                                            // x labels
                                            @for (int i=0;i<count;i++){
                                                var x = left + plotW*(i/(double)Math.Max(1,count-1)); var label = timelineOrder[i].ToLocalTime().ToString("HH:mm:ss");
                                                @:<text x="@x" y="@(top+plotH+12)" font-size="8" fill="#666" text-anchor="middle">@label</text>
                                                <line x1="@x" y1="@(top+plotH)" x2="@x" y2="@(top+plotH+4)" stroke="#444" stroke-width="1" />
                                            }
                                            // series lines
                                            @foreach (var t in visibleTargets)
                                            {
                                                var color = ColorForTarget(t);
                                                double minT = double.MaxValue; double maxT = double.MinValue;
                                                if (compareNormalize){
                                                    foreach (var v in timelineSeries[t]){ if (!double.IsNaN(v.MsPerIter)){ if (v.MsPerIter<minT) minT=v.MsPerIter; if (v.MsPerIter>maxT) maxT=v.MsPerIter; } }
                                                    if (minT==double.MaxValue){ minT=0; maxT=1; }
                                                    if (Math.Abs(maxT-minT) < 1e-9) { maxT = minT + 1; }
                                                }
                                                var pts = string.Join(' ', timelineSeries[t].Select((v,idx)=>{
                                                    var x = left + plotW*(idx/(double)Math.Max(1,count-1));
                                                    double normVal;
                                                    if (compareNormalize){
                                                        if (double.IsNaN(v.MsPerIter)) normVal = 0; else normVal = (v.MsPerIter - minT)/(maxT-minT); // 0..1
                                                        var y = top+plotH - normVal*plotH; return $"{x:F1},{y:F1}";
                                                    } else {
                                                        var y = top+plotH - (v.MsPerIter/globalMax)*plotH; return $"{x:F1},{y:F1}";
                                                    }
                                                }));
                                                <polyline points="@pts" fill="none" stroke="@color" stroke-width="2" />
                                            }
                                            @if (hoverIndex.HasValue && hoverIndex.Value>=0 && hoverIndex.Value < count && hoverPointTooltip != null)
                                            {
                                                var idx = hoverIndex.Value;
                                                var hoverX = left + plotW*(idx/(double)Math.Max(1,count-1));
                                                <line x1="@hoverX" y1="@top" x2="@hoverX" y2="@(top+plotH)" stroke="#666" stroke-dasharray="3 3" stroke-width="1" />
                                                foreach (var t in visibleTargets)
                                                {
                                                    var pt = timelineSeries[t][idx]; if (double.IsNaN(pt.MsPerIter)) continue;
                                                    double minT = double.MaxValue; double maxT = double.MinValue;
                                                    if (compareNormalize){
                                                        foreach (var v in timelineSeries[t]){ if(!double.IsNaN(v.MsPerIter)){ if (v.MsPerIter<minT) minT=v.MsPerIter; if (v.MsPerIter>maxT) maxT=v.MsPerIter; } }
                                                        if (minT==double.MaxValue){ minT=0; maxT=1; }
                                                        if (Math.Abs(maxT-minT) < 1e-9) { maxT = minT + 1; }
                                                    }
                                                    double y;
                                                    if (compareNormalize){
                                                        var normVal = (pt.MsPerIter - minT)/(maxT-minT);
                                                        y = top+plotH - normVal*plotH;
                                                    } else {
                                                        y = top+plotH - (pt.MsPerIter/globalMax)*plotH;
                                                    }
                                                    var color = ColorForTarget(t);
                                                    var r = hoverTarget == t ? 5 : 3;
                                                    <circle cx="@hoverX" cy="@y" r="@r" fill="@color" stroke="#000" stroke-width="1" />
                                                }
                                                // Inline tooltip box (fixed near top-left of plot)
                                                var boxX = left + 5; var boxY = top + 5; var lineH = 11; var lines = new List<string>{ $"{hoverPointTooltip.TimeLabel}", $"ROM: {hoverPointTooltip.Rom}", $"CPU {hoverPointTooltip.CpuCore} | PPU {hoverPointTooltip.PpuCore} | APU {hoverPointTooltip.ApuCore}", $"{hoverPointTooltip.Target}: {hoverPointTooltip.MsPerIter:F3} ms/iter", $"R {hoverPointTooltip.Reads} W {hoverPointTooltip.Writes}", $"APU {hoverPointTooltip.ApuCycles} OAM {hoverPointTooltip.OamWrites}"};
                                                var boxW = 160.0; foreach(var l in lines){ boxW = Math.Max(boxW, 12 + l.Length * 6.0); }
                                                var boxH = lines.Count * lineH + 6;
                                                <rect x="@boxX" y="@boxY" width="@boxW" height="@boxH" fill="#222" stroke="#555" stroke-width="1" rx="4" />
                                                {
                                                    // Razor reserves <text>; build SVG text elements manually
                                                    var sbTxt = new System.Text.StringBuilder();
                                                    for (int i=0;i<lines.Count;i++)
                                                    {
                                                        var txt = lines[i]; var ty = boxY + 4 + (i+1)*lineH - 3; string fill; if (i==0) fill="#fff"; else if (i==1) fill="#9cf"; else if (i==2) fill="#bbb"; else fill="#ddd";
                                                        sbTxt.Append($"<text x='{boxX+4}' y='{ty}' font-size='10' fill='{fill}'>{txt}</text>");
                                                    }
                                                    @((MarkupString)sbTxt.ToString())
                                                }
                                            }
                                        }
                                    </svg>
                                </div>
                            }
                        </div>
                    </div>
                </div>
            }
            @if (!string.IsNullOrEmpty(debugDump))
            {
                <div class="small text-monospace" style="white-space:pre-wrap;max-width:260px">@debugDump</div>
            }
        </div>
    </details>
    </aside>
</div>

@code {
    // --- Save state persistence enhancements ---
    // We compress (GZip) and, if still large, chunk state across multiple IndexedDB entries (kv store) to avoid size issues.
    // Manifest key: SaveKey+".manifest" holds JSON {version, compressed, parts}
    // Single-key format: prefix "GZ:" indicates base64 GZip payload.
    private const int SaveChunkCharSize = 900_000; // conservative chunk size (< ~1MB characters) to fit storage limits

    private NesEmulator.NES? nes;
    private byte[] framebuffer = new byte[256 * 240 * 4]; // Legacy framebuffer path only (HOTPOT-05 zero-copy removed)
    // Replaced timer-based loop with requestAnimationFrame loop for smoother timing
    // Removed unused System.Timers.Timer to eliminate warning (requestAnimationFrame loop used instead)
    private bool[] inputState = new bool[8]; // Up, Down, Left, Right, A, B, Select, Start
    
    private string errorMessage = "";
    // status moved to StatusService
    private bool isRunning = false;
    private bool hasBooted = false; // User must click BOOT before audio + emu start (autoplay policy compliance)
    private float fps = 0.0f;
    private int frameCount = 0;
    private DateTime lastFpsUpdate = DateTime.Now;
    private int lastFrameCount = 0;
    private string romFileName = "test.nes";
    private string currentRomName = "None";
    private string romSearch = string.Empty;
    private int lastLoadedRomSize = 0; // bytes
    private readonly Dictionary<string,int> builtInRomSizes = new();
    private bool fastForward = false; // hold Tab to fast-forward
    private int statsUpdateDivider = 6; // update stats/UI every N frames (visual draw still every frame)
    // Shader system (dynamic)
    private bool shaderOn = true; // legacy flag retained for status messaging (true if not the basic pass-through)
    private string activeShaderKey = "RF"; // default key
    private record ShaderOption(string Key, string Label);
    private List<ShaderOption> shaderOptions = new();
    private bool famicloneOn = true; // default ON per requirement
    private string apuCoreSel = ""; // dynamic suffix (e.g. FMC, FIX, QN, etc.)
    private string cpuCoreSel = ""; // dynamic suffix
    private string ppuCoreSel = "FMC"; // default to enhanced CUBE core
    private List<string> apuCoreOptions = new();
    private List<string> cpuCoreOptions = new();
    private List<string> ppuCoreOptions = new();
    private double emuScale = 1.0; // 1.0 or 0.5 (desktop only)
    private bool isFullscreen = false; // track fullscreen state
    // Flag to disable automatic test ROM static after any savestate load
    private bool autoStaticSuppressed = false;
    // Mobile fullscreen supplemental view selector: controller (default), rtc, gh
    private string mobileFsView = "controller";
    private bool touchControllerInitialized = false;
    private void SetMobileFsView(string v)
    {
        v = v.ToLowerInvariant();
        if (v != "controller" && v != "rtc" && v != "gh") return;
        if (mobileFsView == v) return;
        mobileFsView = v;
        if (mobileFsView == "controller")
        {
            // Will trigger OnAfterRender to initialize touch controller
            touchControllerInitialized = false; // force re-init if markup re-rendered
        }
        StateHasChanged();
    }
    private void SelectMobileView(string v)
    {
        SetMobileFsView(v);
        // notify JS (optional) so it can hide controller vs panels
        try { JS.InvokeVoidAsync("nesInterop.syncMobileView", v); } catch {}
    }
    private void ViewController() => SelectMobileView("controller");
    private void ViewRtc() => SelectMobileView("rtc");
    private void ViewGh() => SelectMobileView("gh");

    [JSInvokable]
    public void JsSetMobileFsView(string v) => SetMobileFsView(v);
    private const string SaveKey = "nes_state_slot0";
    private bool stateBusy = false; // prevent overlapping save/load operations
    private string debugDump = string.Empty;
    // Benchmark modal state
    private bool benchRunning = false; private string benchResultsText = string.Empty; private bool benchModalOpen = false; private int benchWeight = 1; private bool benchAutoLoadState = true; private bool benchSimple5x = true; private string benchBaselineRomName = string.Empty; // resolved ROM name from baseline state
    // Event scheduler UI state (mirrors nes.EnableEventScheduler)
    private bool eventSchedulerOn = false;
    private void ToggleEventScheduler(ChangeEventArgs e)
    {
        if (nes == null) return;
        bool desired = e.Value is bool b && b;
        // Some browsers send string "true"/"false"
        if (e.Value is string sv) { if (bool.TryParse(sv, out var parsed)) desired = parsed; }
        eventSchedulerOn = desired;
        try { nes.EnableEventScheduler = eventSchedulerOn; } catch {}
        // Persist preference (optional)
        try { JS.InvokeVoidAsync("nesInterop.idbSetItem", "pref_eventScheduler", eventSchedulerOn?"1":"0"); } catch {}
        StateHasChanged();
    }
    // Persistent benchmark history
    private class BenchHistoryEntry { public string Id {get;set;}=Guid.NewGuid().ToString(); public DateTime TimestampUtc {get;set;}=DateTime.UtcNow; public string Rom {get;set;}=""; public string CpuCore {get;set;}=""; public string PpuCore {get;set;}=""; public string ApuCore {get;set;}=""; public string Display {get;set;}=""; }
    private List<BenchHistoryEntry> benchHistory = new();
    private string? currentBenchHistoryId = null;
    private const string BenchHistoryKey = "bench_history_v1"; // single JSON array stored in IndexedDB
    // Comparison modal state & derived datasets
    private bool compareModalOpen = false;
    // Limit the number of historical points rendered in the benchmark trend graph to avoid overcrowding.
    private const int MaxTimelineTrendPoints = 69; // show only the latest 69 data points in timeline graph
    private HashSet<string> visibleTargets = new();
    private List<string> allTargets = new();
    private List<DateTime> timelineOrder = new();
    // Enhanced timeline series includes rich point data for hover tooltips
    private record TimelinePoint(DateTime When,double MsPerIter,long Reads,long Writes,long Apu,long Oam,string CpuCore,string PpuCore,string ApuCore,string Rom);
    private Dictionary<string,List<TimelinePoint>> timelineSeries = new();
    private record DiffRow(string Name,double CurMs,double PrevMs,double DeltaMs,double DeltaPct,long ReadsDelta,long WritesDelta,long ApuDelta,long OamDelta);
    private List<DiffRow> recentDiffRows = new();
    private bool diffAnimating = false; private string? highlightMetricName = null; private CancellationTokenSource? diffAnimCts;
    private bool compareNormalize = true; // per-target normalization to 0..100% range
    // SoundFont mode toggle (APU_WF & APU_MNES)
    private bool soundFontMode = false;
    private bool sampleFont = true; // attempt external sample instruments
    private bool soundFontLayering = false; // layering off by default
    private bool sfDevLogging = false; // dev logging toggle
    private bool sfOverlay = false; // overlay toggle
    private string activeSfCoreDisplay => string.IsNullOrEmpty(activeSfCore) ? (soundFontMode ? "(compat)" : "None") : activeSfCore;
    private string activeSfCore = string.Empty; // WF or MNES
    private async Task UpdateActiveSoundFontCoreAsync()
    {
        if (!soundFontMode)
        {
            activeSfCore = string.Empty;
            try { await JS.InvokeVoidAsync("nesInterop.setActiveSoundFontCore", (object?)null); } catch {}
            return;
        }
        string? core = null;
        if (string.Equals(apuCoreSel, "WF", StringComparison.OrdinalIgnoreCase)) core = "WF";
        else if (string.Equals(apuCoreSel, "MNES", StringComparison.OrdinalIgnoreCase)) core = "MNES";
        activeSfCore = core ?? string.Empty;
        try { await JS.InvokeVoidAsync("nesInterop.setActiveSoundFontCore", core, new { eager = true, flush = true }); } catch {}
        try { await JS.InvokeVoidAsync("nesInterop.setSoundFontLayering", soundFontLayering); } catch {}
    }
    private async void ToggleSoundFontLayering(ChangeEventArgs e)
    {
        bool desired = e.Value is bool b && b;
        if (e.Value is string sv && bool.TryParse(sv, out var parsed)) desired = parsed;
        soundFontLayering = desired;
        try { await JS.InvokeVoidAsync("nesInterop.setSoundFontLayering", soundFontLayering); } catch {}
        StateHasChanged();
    }
    private async Task FlushSoundFont()
    {
        try { await JS.InvokeVoidAsync("nesInterop.flushSoundFont"); } catch {}
        try { nes?.FlushSoundFont(); } catch {}
    }
    private async Task ShowSfDebug()
    {
        try {
            var rep = await JS.InvokeAsync<object>("nesInterop.debugReport");
            Logger.LogInformation($"SF Debug: {System.Text.Json.JsonSerializer.Serialize(rep)}");
        } catch {}
    }
    private async void ToggleSfDevLogging(ChangeEventArgs e)
    {
        bool desired = e.Value is bool b && b; if(e.Value is string sv && bool.TryParse(sv,out var parsed)) desired = parsed;
        sfDevLogging = desired;
        try { await JS.InvokeVoidAsync("nesInterop.enableSoundFontDevLogging", sfDevLogging); } catch {}
        StateHasChanged();
    }
    private async void ToggleSfOverlay(ChangeEventArgs e)
    {
        bool desired = e.Value is bool b && b; if(e.Value is string sv && bool.TryParse(sv,out var parsed)) desired = parsed;
        if(desired == sfOverlay) return;
        sfOverlay = desired;
        try {
            if(sfOverlay) await JS.InvokeVoidAsync("nesInterop.startSoundFontAudioOverlay"); else await JS.InvokeVoidAsync("nesInterop.stopSoundFontAudioOverlay");
        } catch {}
        StateHasChanged();
    }
    // Automatically configure SoundFont/sample mode when selecting specific APU core (WF)
    private void AutoConfigureForApuCore()
    {
        if (nes == null) return;
        try
        {
            if (string.Equals(apuCoreSel, "WF", StringComparison.OrdinalIgnoreCase))
            {
                // Enable SoundFont note-event path if not already
                if (!soundFontMode)
                {
                    soundFontMode = nes.EnableSoundFontMode(true, (ch, prog, midi, vel, on, _) =>
                    {
                        try { JS.InvokeVoidAsync("nesInterop.noteEvent", ch, prog, midi, vel, on); } catch { }
                    });
                }
                // Force sample-based mode preference
                sampleFont = true;
                try { JS.InvokeVoidAsync("eval", "window.nesSoundFont && nesSoundFont.setPreferSampleBased && nesSoundFont.setPreferSampleBased(true);"); } catch {}
                try { JS.InvokeVoidAsync("eval", "window.nesSoundFont && nesSoundFont.enableSampleMode && nesSoundFont.enableSampleMode();"); } catch {}
            }
            else if (string.Equals(apuCoreSel, "MNES", StringComparison.OrdinalIgnoreCase))
            {
                // MNES core also uses note-event mode, but may rely on an alternate JS synth/library.
                // We just enable the generic note-event bridge; library-specific init (if any) can be added later.
                if (!soundFontMode)
                {
                    soundFontMode = nes.EnableSoundFontMode(true, (ch, prog, midi, vel, on, _) =>
                    {
                        try { JS.InvokeVoidAsync("nesInterop.noteEvent", ch, prog, midi, vel, on); } catch { }
                    });
                }
                // Kick JS MNES SoundFont bridge (lazy loads MNES.sf2)
                try { JS.InvokeVoidAsync("eval", "window.mnesSf2 && mnesSf2.enable && mnesSf2.enable();"); } catch {}
                // Do NOT force nesSoundFont sample mode here since MNES may target a different playback engine.
            }
            else
            {
                // Leaving WF/MNES note-event cores -> disable SoundFont path if currently enabled (revert to PCM from other cores)
                if (soundFontMode)
                {
                    nes.EnableSoundFontMode(false, null);
                    soundFontMode = false;
                }
            }
        }
        catch { }
    // After enabling/disabling SoundFontMode update active core flag in JS
    _ = UpdateActiveSoundFontCoreAsync();
        StateHasChanged();
    }
    private void ToggleSoundFontMode(ChangeEventArgs e)
    {
        if (nes == null) return;
        bool desired = e.Value is bool b && b;
        if (e.Value is string sv && bool.TryParse(sv, out var parsed)) desired = parsed;
        if (desired == soundFontMode) return;
        soundFontMode = nes.EnableSoundFontMode(desired, (ch, prog, midi, vel, on, _)=>
        {
            try { JS.InvokeVoidAsync("nesInterop.noteEvent", ch, prog, midi, vel, on); } catch {}
        });
        if (soundFontMode && sampleFont)
        {
            // Kick off sample-based mode (fire-and-forget)
            try { JS.InvokeVoidAsync("eval", "window.nesSoundFont && nesSoundFont.enableSampleMode && nesSoundFont.enableSampleMode();"); } catch {}
        }
    _ = UpdateActiveSoundFontCoreAsync();
        StateHasChanged();
    }
    private void ToggleSampleFont(ChangeEventArgs e)
    {
        bool desired = e.Value is bool b && b;
        if (e.Value is string sv && bool.TryParse(sv, out var parsed)) desired = parsed;
        if (desired == sampleFont) return;
        sampleFont = desired;
        try { JS.InvokeVoidAsync("eval", $"window.nesSoundFont && nesSoundFont.setPreferSampleBased && nesSoundFont.setPreferSampleBased({(sampleFont?"true":"false")});"); } catch {}
        if (sampleFont && soundFontMode)
        {
            try { JS.InvokeVoidAsync("eval", "window.nesSoundFont && nesSoundFont.enableSampleMode && nesSoundFont.enableSampleMode();"); } catch {}
        }
    }

    // Corruptor state
    private int corruptIntensity = 1; // default minimal intensity
    private string lastBlastInfo = "";
    private class DomainSel { public string Key=""; public string Label=""; public bool Selected=true; public int Size; }
    private List<DomainSel> memoryDomains = new();
    private string crashBehavior = "IgnoreErrors"; // default to ignore errors
    private bool autoCorrupt = false;
    private readonly Random corruptRnd = new();
    private string blastType = "RANDOM"; // corruption mode
    private bool letItRipUsed = false; // hide Let it rip button after first click
    // ================= Glitch Harvester state =================
    private class HarvesterBaseState { public string Id {get;set;} = Guid.NewGuid().ToString(); public string Name {get;set;} = string.Empty; public string State {get;set;} = string.Empty; public DateTime Created {get;set;} = DateTime.UtcNow; }
    private class BlastInstruction { public string Domain {get;set;} = string.Empty; public int Address {get;set;} public byte Value {get;set;} }
    private class HarvestEntry { public string Id {get;set;} = Guid.NewGuid().ToString(); public string Name {get;set;} = string.Empty; public string BaseStateId {get;set;} = string.Empty; public List<BlastInstruction> Writes {get;set;} = new(); public DateTime Created {get;set;} = DateTime.UtcNow; }
    private List<HarvesterBaseState> ghBaseStates = new();
    private List<HarvestEntry> ghStash = new();
    private List<HarvestEntry> ghStockpile = new();
    private string ghSelectedBaseId = string.Empty;
    private string ghNewBaseName = string.Empty;
    private int ghStashCounter = 0;
    private int ghStockpileCounter = 0;
    private string? ghRenamingId = null; private string ghRenameText = string.Empty;
    private bool GhHasSelectedBase => ghBaseStates.Any(b=>b.Id==ghSelectedBaseId);
    // Shared DotNetObjectReference for JS interop callbacks (Theory 2 fix)
    private DotNetObjectReference<Nes>? _selfRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                Logger.LogInformation("NES Emulator initializing...");
                Status.Set("Loading default ROM...");
                // Create a single reusable DotNetObjectReference for all JS callbacks
                _selfRef = DotNetObjectReference.Create(this);
                // Load persisted core & shader preferences
                try {
                    var pShader = await JS.InvokeAsync<string>("nesInterop.idbGetItem", "pref_shader"); if(!string.IsNullOrWhiteSpace(pShader)) activeShaderKey = pShader;
                    var pCpu = await JS.InvokeAsync<string>("nesInterop.idbGetItem", "pref_cpuCore"); if(!string.IsNullOrWhiteSpace(pCpu)) cpuCoreSel = pCpu;
                    var pPpu = await JS.InvokeAsync<string>("nesInterop.idbGetItem", "pref_ppuCore"); if(!string.IsNullOrWhiteSpace(pPpu)) ppuCoreSel = pPpu;
                    var pApu = await JS.InvokeAsync<string>("nesInterop.idbGetItem", "pref_apuCore"); if(!string.IsNullOrWhiteSpace(pApu)) apuCoreSel = pApu;
                    await LoadBenchHistory();
                } catch {}

                // Get shader list immediately (ensures dropdown populated even before WebGL init)
                await RefreshShaderOptions();

                // Load any previously stored uploaded ROMs from IndexedDB via JS
                // Migrate any legacy localStorage ROM cache to IndexedDB
                try { await JS.InvokeVoidAsync("nesInterop.migrateLocalStorageRoms"); } catch {}
                var stored = await JS.InvokeAsync<UploadedRom[]>("nesInterop.getStoredRoms");
                if (stored != null)
                {
                    int restored = 0;
                    foreach (var r in stored)
                    {
                        if (string.IsNullOrWhiteSpace(r.name) || string.IsNullOrWhiteSpace(r.base64)) continue;
                        try
                        {
                            var data = Convert.FromBase64String(r.base64);
                            if (data.Length == 0) continue;
                            uploadedRoms[r.name] = data;
                            if (!romOptions.Any(o => o.Key == r.name))
                            {
                                romOptions.Add(new RomOption { Key = r.name, Label = r.name + " (uploaded)", BuiltIn = false });
                                restored++;
                            }
                        }
                        catch { }
                    }
                    if (restored > 0)
                    {
                        Status.Set($"Restored {restored} uploaded ROM(s).");
                    }
                }

                // Initialize drag & drop on ROM table instead of dedicated zone
                if (_selfRef != null)
                {
                    await JS.InvokeVoidAsync("nesInterop.initRomDragDrop", "rom-table", _selfRef);
                }

                // Auto-load default ROM then apply persisted core selections
                await LoadRomFromServer();
                ApplySelectedCores();

                // Zero-copy framebuffer initialization removed (rollback HOTPOT-05); legacy copy path always active.

                // Provide dotnet ref to JS for fullscreen/control callbacks
                try { if (_selfRef != null) await JS.InvokeVoidAsync("nesInterop.setMainRef", _selfRef); } catch {}

                // Register for keyboard input events via JS interop
                if (_selfRef != null)
                {
                    await JS.InvokeVoidAsync("nesInterop.registerInput", _selfRef);
                }

                // Build memory domain list (after ROM load)
                BuildMemoryDomains();

                // Register C#-generated shaders into JS registry, then fetch options and set initial active shader
                await RegisterShadersFromCSharp();
                await RefreshShaderOptions();
                await SetShader(activeShaderKey);

                Logger.LogInformation("NES Emulator initialized successfully");
                // After initial render, verify scoped CSS applied; inject fallback if not
                try { await JS.InvokeVoidAsync("nesInterop.ensureLayoutStyles"); } catch {}
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, $"Failed to initialize NES emulator. Exception: {ex}");
                errorMessage = $"Initialization failed: {ex.Message}\n{ex.StackTrace}";
                Status.Set("Failed to load default ROM. Please upload a ROM file above.");
            }
        }
        // Initialize touch controller JS handlers when controller view visible
        if (isFullscreen && mobileFsView == "controller" && !touchControllerInitialized)
        {
            try
            {
                await JS.InvokeVoidAsync("nesInterop.initTouchController", "touch-controller");
                touchControllerInitialized = true;
            }
            catch { }
        }
    }

    // Bridge: push generated C# shader definitions into JS registry
    private async Task RegisterShadersFromCSharp()
    {
        try
        {
            foreach (var s in ShaderProvider.All)
            {
                // key, displayName, fragmentSrc, options(null)
                await JS.InvokeVoidAsync("nesInterop.registerShader", s.Id, s.DisplayName, s.FragmentSource, (object?)null);
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to register shaders from C#");
        }
    }

    // ROM option model & storage for uploaded ROMs
    private class RomOption
    {
        public string Key { get; set; } = string.Empty; // unique key (filename or generated)
        public string Label { get; set; } = string.Empty; // display text
        public bool BuiltIn { get; set; }
    }

    private List<RomOption> romOptions = new()
    {
    new RomOption{ Key="test.nes", Label="Test ROM (test.nes)", BuiltIn=true}
    };
    private readonly Dictionary<string, byte[]> uploadedRoms = new();
    private ElementReference fileInput;
    private bool IsBuiltInSelected => romOptions.FirstOrDefault(o => o.Key == romFileName)?.BuiltIn ?? true;
    private IEnumerable<RomOption> FilteredRomOptions => string.IsNullOrWhiteSpace(romSearch)
        ? romOptions.OrderBy(o=>o.BuiltIn ? 0 : 1).ThenBy(o=>o.Label)
        : romOptions.Where(o=>o.Label.Contains(romSearch, StringComparison.OrdinalIgnoreCase) || o.Key.Contains(romSearch, StringComparison.OrdinalIgnoreCase))
            .OrderBy(o=>o.BuiltIn ? 0 : 1).ThenBy(o=>o.Label);

    private async Task<byte[]> LoadRomFromWwwroot(string filename)
    {
        try
        {
            Logger.LogInformation($"Loading ROM: {filename}");
            var romData = await Http.GetByteArrayAsync(filename);
            Logger.LogInformation($"ROM loaded successfully: {romData.Length} bytes");
            
            // Debug: Log first few bytes
            if (romData.Length >= 16)
            {
                var headerHex = string.Join(" ", romData.Take(16).Select(b => b.ToString("X2")));
                Logger.LogInformation($"ROM Header: {headerHex}");
            }
            
            return romData;
        }
        catch (HttpRequestException ex)
        {
            Logger.LogError(ex, $"HTTP error loading ROM: {filename}");
            return new byte[0]; // Return empty array instead of throwing
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Failed to load ROM: {filename}");
            return new byte[0]; // Return empty array instead of throwing
        }
    }

    private async Task StartEmulation()
    {
        try
        {
            if (nes == null)
            {
                errorMessage = "NES emulator not initialized";
                return;
            }
            if (!hasBooted)
            {
                // Guard against premature start (ensures AudioContext after user interaction)
                return;
            }

            Logger.LogInformation("Starting emulation");
            isRunning = true;
            errorMessage = "";
            Status.Set("Emulation running...");

            // Start JS requestAnimationFrame loop
            _selfRef ??= DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("nesInterop.startEmulationLoop", _selfRef);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Failed to start emulation. Exception: {ex}");
            errorMessage = $"Failed to start: {ex.Message}\n{ex.StackTrace}";
            isRunning = false;
            StateHasChanged();
        }
    }

    private async Task PauseEmulation()
    {
        try
        {
            Logger.LogInformation("Pausing emulation");
            isRunning = false;
            await JS.InvokeVoidAsync("nesInterop.stopEmulationLoop");
            // Flush SoundFont notes if WF mode active
            try { nes?.FlushSoundFont(); } catch {}
            try { await JS.InvokeVoidAsync("nesInterop.flushSoundFont"); } catch {}
            Status.Set("Emulation paused");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Failed to pause emulation. Exception: {ex}");
            errorMessage = $"Failed to pause: {ex.Message}\n{ex.StackTrace}";
        }
    }

    private async void ResetEmulation()
    {
        try
        {
            Logger.LogInformation("Resetting emulation");
            bool wasRunning = isRunning;
            await PauseEmulation();
            // Ensure auto corruption is disabled for a clean reset
                // Additional explicit SoundFont flush (PauseEmulation already attempts, but safe)
                try { nes?.FlushSoundFont(); } catch {}
                try { await JS.InvokeVoidAsync("nesInterop.flushSoundFont"); } catch {}
            if (autoCorrupt)
            {
                autoCorrupt = false;
                lastBlastInfo = "Auto-corrupt disabled (reset)";
            }
            // Force a pristine reload of the current ROM bytes (discard in-memory mutated state)
            if (!string.IsNullOrEmpty(currentRomName))
            {
                // If uploaded ROM, re-use original stored bytes; if built-in, refetch from server
                romFileName = currentRomName; // sync selection
                if (uploadedRoms.ContainsKey(currentRomName))
                {
                    // Manually reload without going through any cached emulator state
                    var data = uploadedRoms[currentRomName];
                    // Preserve previously selected audio backend; reuse existing NES instance if present
                    if (nes == null) nes = new NesEmulator.NES();
                    nes.RomName = currentRomName;
                    // Preserve currently selected APU suffix before load
                    var prevApuSuffix = apuCoreSel;
                    nes.LoadROM(data);
                    if (!string.IsNullOrEmpty(prevApuSuffix))
                    {
                        // Reapply user preference explicitly (LoadROM recreates internal cores)
                        try { nes.SetApuCore(prevApuSuffix); } catch { }
                    }
                    // Re-apply selected CPU/PPU/APU cores so the active cores match the UI selection after reload
                    // (Without this, the PPU would revert to the default core internally while the UI still shows the previous selection.)
                    ApplySelectedCores();
                    // Re-apply selected APU core explicitly after reload
                    try {
                        if (apuCoreSel == "FMC") nes.SetApuCore(NesEmulator.NES.ApuCore.Jank);
                        else if (apuCoreSel == "FIX") nes.SetApuCore(NesEmulator.NES.ApuCore.Modern);
                        else if (apuCoreSel == "QN") nes.SetApuCore(NesEmulator.NES.ApuCore.QuickNes);
                    } catch {}
                    BuildMemoryDomains();
                }
                else
                {
                    await LoadRomFromServer(); // this rebuilds nes & memory domains
                    SetApuCoreSelFromEmu();
                }
            }
            frameCount = 0;
            lastFrameCount = 0;
            fps = 0;
            // Reset the JS audio scheduling timeline so A/V stays aligned after a clean reset
            try { await JS.InvokeVoidAsync("nesInterop.resetAudioTimeline"); } catch {}
            if (wasRunning)
            {
                await StartEmulation();
            }
            Status.Set("Emulation reset (clean ROM reloaded)");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Failed to reset emulation. Exception: {ex}");
            errorMessage = $"Failed to reset: {ex.Message}\n{ex.StackTrace}";
        }
    }

    private void SetScale(double scale)
    {
        if (scale != 0.5 && scale != 1.0) return;
        emuScale = scale;
    }

    private async Task ToggleFullscreen()
    {
        try
        {
            var newState = await JS.InvokeAsync<bool>("nesInterop.toggleFullscreen");
            isFullscreen = newState;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Fullscreen toggle failed");
        }
    }

    private async Task RefreshShaderOptions()
    {
        try
        {
            var opts = await JS.InvokeAsync<object>("nesInterop.getShaderOptions");
            // opts is JS array => deserialize via System.Text.Json
            var json = System.Text.Json.JsonSerializer.Serialize(opts);
            var parsed = System.Text.Json.JsonDocument.Parse(json).RootElement;
            shaderOptions.Clear();
            foreach (var el in parsed.EnumerateArray())
            {
                string key = ""; string label = "";
                if(el.TryGetProperty("key", out var keyProp)) key = keyProp.GetString() ?? "";
                if(el.TryGetProperty("Key", out var keyProp2) && string.IsNullOrEmpty(key)) key = keyProp2.GetString() ?? ""; // fallback
                if(el.TryGetProperty("label", out var labProp)) label = labProp.GetString() ?? "";
                if(el.TryGetProperty("Label", out var labProp2) && string.IsNullOrEmpty(label)) label = labProp2.GetString() ?? ""; // fallback
                if(string.IsNullOrEmpty(label)) label = key;
                if(!string.IsNullOrEmpty(key)) shaderOptions.Add(new ShaderOption(key,label));
            }
            if(!shaderOptions.Any(o=>o.Key==activeShaderKey) && shaderOptions.Count>0){ activeShaderKey = shaderOptions[0].Key; }
        }
        catch (Exception ex) { Logger.LogWarning(ex, "Failed to refresh shader options"); }
    }

    private async Task SetShader(string key)
    {
        try
        {
            var displayName = await JS.InvokeAsync<string>("nesInterop.setShader", key);
            if(!string.IsNullOrEmpty(displayName))
            {
                activeShaderKey = key;
                shaderOn = key != "PX"; // consider PX the passthrough
                Status.Set($"Shader: {displayName}");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"SetShader error for {key}");
        }
    }

    // Called from JS every animation frame
    [JSInvokable]
    public async Task FrameTick()
    {
        if (!isRunning) return;
        await RunFrame();
    }

    private async Task RunFrame()
    {
        if (nes == null || !isRunning) return;

        try
        {
            // Auto static only for default test ROM and only before a savestate has been shown
            bool autoStatic = string.Equals(currentRomName, "test.nes", StringComparison.OrdinalIgnoreCase) && !autoStaticSuppressed;
            nes.EnableStatic(autoStatic);
            nes.SetInput(inputState);
            if (fastForward)
            {
                nes.RunFrames(3); // run multiple frames quickly
            }
            else
            {
                nes.RunFrame();
            }
            if (autoCorrupt)
            {
                // Perform corruption after CPU step but before frame buffer fetch so effects are visible quickly
                await Blast();
            }
            frameCount++;

            // Fetch audio EVERY emulation frame to maintain steady cadence
            int queued = nes.GetQueuedAudioSamples();
            // Target a chunk size aiming for ~12ms ( ~530 samples @44.1kHz ); adapt if backlog large
            int targetChunk = queued > 4096 ? 2048 : (queued > 2048 ? 1024 : 768);
            float[] audioBuffer = nes.GetAudioBuffer();
            bool queuedAudio = audioBuffer.Length > 0;
            int sampleRate = queuedAudio ? nes.GetAudioSampleRate() : 0;

            // Always draw current frame for smooth visuals / present output (legacy path only)
            framebuffer = nes.GetFrameBuffer();
#pragma warning disable CS4014
            // Coalesced present call (audio + video) to reduce JS interop calls per frame (HotPot HOTPOT-02)
            JS.InvokeVoidAsync("nesInterop.presentFrame", "nes-canvas", framebuffer, queuedAudio ? audioBuffer : null, sampleRate);
#pragma warning restore CS4014

            // Throttle stats & Blazor UI updates separately
            if (frameCount % statsUpdateDivider == 0)
            {
                var now = DateTime.Now;
                if ((now - lastFpsUpdate).TotalSeconds >= 0.5)
                {
                    fps = (frameCount - lastFrameCount) / (float)(now - lastFpsUpdate).TotalSeconds;
                    lastFrameCount = frameCount;
                    lastFpsUpdate = now;
                }
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error in RunFrame. Exception: {ex}");
            await InvokeAsync(() =>
            {
                errorMessage = $"Runtime error: {ex.Message}\n{ex.StackTrace}";
                _ = PauseEmulation();
                StateHasChanged();
            });
        }
    }

    // Legacy famiclone toggle removed; use APU core selector instead

    private void SetApuCoreSelFromEmu()
    {
        if (nes == null) return;
        try
        {
            var id = nes.GetApuCoreId();
            var suffix = NesEmulator.CoreRegistry.ExtractSuffix(id, "APU_");
            apuCoreSel = suffix;
            famicloneOn = suffix.Equals("FMC", StringComparison.OrdinalIgnoreCase);
        }
        catch { }
    }

    // Apply currently selected (or persisted) core choices to emulator instance
    private void ApplySelectedCores()
    {
        if (nes == null) return;
        try
        {
            // CPU core generic selection (fallback to legacy enum if generic fails)
            if (!string.IsNullOrEmpty(cpuCoreSel))
            {
                if (!nes.SetCpuCore(cpuCoreSel))
                {
                    nes.SetCpuCore(cpuCoreSel == "FIX" ? NesEmulator.Bus.CpuCore.FIX : NesEmulator.Bus.CpuCore.FMC);
                }
            }
            // Generic reflection-based PPU selection (fallback to legacy enum only if needed)
            if (!nes.SetPpuCore(ppuCoreSel))
            {
                // fallback for older saved prefs
                nes.SetPpuCore(ppuCoreSel switch {
                    "FIX" => NesEmulator.Bus.PpuCore.FIX,
                    "LQ" => NesEmulator.Bus.PpuCore.LQ,
                    "CUBE" => NesEmulator.Bus.PpuCore.CUBE,
                    "BFR" => NesEmulator.Bus.PpuCore.BFR,
                    _ => NesEmulator.Bus.PpuCore.FMC
                });
            }
            if (!string.IsNullOrEmpty(apuCoreSel))
            {
                if (!nes.SetApuCore(apuCoreSel))
                {
                    // legacy fallback mapping for older core ids
                    switch (apuCoreSel)
                    {
                        case "FMC": nes.SetApuCore(NesEmulator.NES.ApuCore.Jank); famicloneOn = true; break;
                        case "QN": nes.SetApuCore(NesEmulator.NES.ApuCore.QuickNes); famicloneOn = false; break;
                        default: nes.SetApuCore(NesEmulator.NES.ApuCore.Modern); famicloneOn = false; break;
                    }
                }
                famicloneOn = apuCoreSel.Equals("FMC", StringComparison.OrdinalIgnoreCase) || famicloneOn;
            }
        }
        catch { }
    // After core selection, auto-handle SoundFont if WF chosen
    AutoConfigureForApuCore();
    }

    private async Task OnApuCoreChanged(ChangeEventArgs e)
    {
        if (nes == null) return;
        var v = e.Value?.ToString() ?? string.Empty;
        if (string.IsNullOrEmpty(v)) return;
        if (v == apuCoreSel) return;
        apuCoreSel = v;
        bool ok = nes.SetApuCore(v);
        if (!ok)
        {
            // legacy fallback
            switch (v)
            {
                case "FMC": nes.SetApuCore(NesEmulator.NES.ApuCore.Jank); break;
                case "QN": nes.SetApuCore(NesEmulator.NES.ApuCore.QuickNes); break;
                default: nes.SetApuCore(NesEmulator.NES.ApuCore.Modern); break;
            }
        }
    famicloneOn = v.Equals("FMC", StringComparison.OrdinalIgnoreCase);
        Status.Set($"APU core switched to {v}");
        try { await JS.InvokeVoidAsync("nesInterop.idbSetItem", "pref_apuCore", apuCoreSel); } catch {}
    AutoConfigureForApuCore();
    }

    private async Task OnCpuCoreChanged(ChangeEventArgs e)
    {
        if (nes == null) return;
        var v = e.Value?.ToString();
        if (string.IsNullOrEmpty(v)) return;
        if (v == cpuCoreSel) return;
        cpuCoreSel = v;
        var state = nes.GetCpuState();
        bool ok = nes.SetCpuCore(v);
        if (!ok)
        {
            nes.SetCpuCore(v == "FIX" ? NesEmulator.Bus.CpuCore.FIX : NesEmulator.Bus.CpuCore.FMC);
        }
        try { nes.SetCpuState(state); } catch {}
        Status.Set($"CPU core switched to {v}");
        try { await JS.InvokeVoidAsync("nesInterop.idbSetItem", "pref_cpuCore", cpuCoreSel); } catch {}
    }

    private async Task OnPpuCoreChanged(ChangeEventArgs e)
    {
        if (nes == null) return;
        var v = e.Value?.ToString();
        if (string.IsNullOrEmpty(v)) return;
        if (v == ppuCoreSel) return;
        ppuCoreSel = v;
        var state = nes.GetPpuState();
        if (!nes.SetPpuCore(v))
        {
            nes.SetPpuCore(v switch {
                "FIX" => NesEmulator.Bus.PpuCore.FIX,
                "LQ" => NesEmulator.Bus.PpuCore.LQ,
                "CUBE" => NesEmulator.Bus.PpuCore.CUBE,
                "BFR" => NesEmulator.Bus.PpuCore.BFR,
                _ => NesEmulator.Bus.PpuCore.FMC
            });
        }
        try { nes.SetPpuState(state); } catch {}
        Status.Set($"PPU core switched to {v}");
    try { await JS.InvokeVoidAsync("nesInterop.idbSetItem", "pref_ppuCore", ppuCoreSel); } catch {}
    }

    private async Task OnShaderSelectChanged(ChangeEventArgs e)
    {
        var v = e.Value?.ToString();
        if(string.IsNullOrWhiteSpace(v)) return;
        if(v != activeShaderKey)
        {
            await SetShader(v);
            try { await JS.InvokeVoidAsync("nesInterop.idbSetItem", "pref_shader", activeShaderKey); } catch {}
        }
    }

    // Old famiclone-only handler removed; see OnApuCoreChanged

    [JSInvokable]
    public void UpdateInput(bool[] state)
    {
        try
        {
            if (state.Length == 8)
            {
                for (int i = 0; i < 8; i++)
                    inputState[i] = state[i];
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating input");
        }
    }

    // Unused (InputFile component removed)
    private async Task LoadRomFile(InputFileChangeEventArgs e)
    {
        try
        {
            Logger.LogInformation($"Loading ROM file: {e.File.Name}");
            Status.Set($"Loading {e.File.Name}...");

            using var stream = e.File.OpenReadStream(maxAllowedSize: 2 * 1024 * 1024); // 2MB max
            using var memoryStream = new MemoryStream();
            await stream.CopyToAsync(memoryStream);
            var romData = memoryStream.ToArray();

            Logger.LogInformation($"ROM file loaded: {romData.Length} bytes");
            
            // Debug: Log first few bytes
            if (romData.Length >= 16)
            {
                var headerHex = string.Join(" ", romData.Take(16).Select(b => b.ToString("X2")));
                Logger.LogInformation($"ROM Header: {headerHex}");
            }

            if (nes == null) nes = new NesEmulator.NES();
            nes.RomName = romFileName;
            var prevApuSuffix = apuCoreSel;
            nes.LoadROM(romData);
            if (!string.IsNullOrEmpty(prevApuSuffix)) { try { nes.SetApuCore(prevApuSuffix); } catch {} }
            autoStaticSuppressed = false;
            try { nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors); } catch {}
            SetApuCoreSelFromEmu();

            BuildMemoryDomains();

            currentRomName = e.File.Name;
            Status.Set($"ROM '{e.File.Name}' loaded successfully.");
            errorMessage = "";
            if (hasBooted && !isRunning)
            {
                await StartEmulation();
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Failed to load ROM file: {e.File.Name}. Exception: {ex}");
            errorMessage = $"Failed to load ROM: {ex.Message}\n{ex.StackTrace}";
            Status.Clear();
            StateHasChanged();
        }
    }

    private async Task LoadRomUpload(ChangeEventArgs e)
    {
        try
        {
            Status.Set("Reading ROM file(s)...");
            errorMessage = string.Empty;

            // Invoke JS to read selected files as base64
            var files = await JS.InvokeAsync<UploadedRom[]>("nesInterop.readSelectedRoms", fileInput);
            if (files == null || files.Length == 0)
            {
                Status.Set("No ROM files selected.");
                return;
            }

            int added = 0;
            foreach (var f in files)
            {
                if (string.IsNullOrWhiteSpace(f.name) || string.IsNullOrWhiteSpace(f.base64)) continue;
                if (!f.name.EndsWith(".nes", StringComparison.OrdinalIgnoreCase)) continue;
                byte[] data;
                try { data = Convert.FromBase64String(f.base64); }
                catch { continue; }
                if (data.Length == 0) continue;

                // size guard (<= 4MB typical)
                if (data.Length > 4 * 1024 * 1024)
                {
                    Status.Set($"File '{f.name}' too large (>4MB). Skipped.");
                    continue;
                }
                var key = f.name;
                // If duplicate, overwrite existing bytes but not label duplication
                uploadedRoms[key] = data;
                if (!romOptions.Any(o => o.Key == key))
                {
                    romOptions.Add(new RomOption { Key = key, Label = $"{f.name} (uploaded)", BuiltIn = false });
                }
                added++;
            }

            if (added == 0)
            {
                Status.Set("No valid .nes files processed.");
                return;
            }

            // Auto-select the last uploaded ROM
            var last = files.Reverse().FirstOrDefault(f => !string.IsNullOrWhiteSpace(f.name) && uploadedRoms.ContainsKey(f.name));
            if (last != null)
            {
                romFileName = last.name;
                await LoadSelectedRom();
            }

            Status.Set(added == 1 ? "ROM uploaded." : $"{added} ROMs uploaded.");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Upload failed");
            errorMessage = $"Upload failed: {ex.Message}";
            // clear status
            StateHasChanged();
        }
    }

    private async Task RomSelectionChanged(ChangeEventArgs e)
    {
        if (e.Value is string value && !string.IsNullOrWhiteSpace(value))
        {
            romFileName = value.Trim();
            await LoadSelectedRom();
        }
    }

    private Task LoadRomEntry(string key)
    {
        romFileName = key;
        return LoadSelectedRom();
    }

    private Task OnRomRowClicked(RomOption opt)
    {
        if (opt.Key == currentRomName) return Task.CompletedTask; // already active
        return LoadRomEntry(opt.Key);
    }

    private string GetDefaultBuiltInRomKey()
    {
        return romOptions.FirstOrDefault(o => o.BuiltIn)?.Key ?? string.Empty;
    }

    private async Task DeleteRom(string key)
    {
        var opt = romOptions.FirstOrDefault(o=>o.Key==key);
        if (opt == null || opt.BuiltIn) return;
        if (uploadedRoms.Remove(key))
        {
            await JS.InvokeVoidAsync("nesInterop.removeStoredRom", key);
        }
        romOptions.Remove(opt);
        if (currentRomName == key)
        {
            var fallback = GetDefaultBuiltInRomKey();
            if (!string.IsNullOrEmpty(fallback))
            {
                romFileName = fallback;
                await LoadSelectedRom();
            }
            else
            {
                nes = null; // no ROM available
                currentRomName = "None";
                Status.Set("No built-in ROMs available. Please upload a ROM.");
            }
        }
    Status.Set($"Deleted ROM {key}.");
        StateHasChanged();
    }

    private async Task ClearAllUploaded()
    {
        var toDelete = romOptions.Where(o=>!o.BuiltIn).Select(o=>o.Key).ToList();
        foreach (var k in toDelete)
        {
            await JS.InvokeVoidAsync("nesInterop.removeStoredRom", k);
        }
        romOptions = romOptions.Where(o=>o.BuiltIn).ToList();
        uploadedRoms.Clear();
        if (!IsBuiltInSelected)
        {
            var fallback = GetDefaultBuiltInRomKey();
            if (!string.IsNullOrEmpty(fallback))
            {
                romFileName = fallback;
                await LoadSelectedRom();
            }
            else
            {
                nes = null;
                currentRomName = "None";
                Status.Set("No built-in ROMs available. Please upload a ROM.");
            }
        }
    Status.Set("Cleared uploaded ROMs.");
    }

    private void OnRomSearchChanged(ChangeEventArgs e)
    {
        romSearch = e.Value?.ToString() ?? string.Empty;
    }

    private async Task TriggerFileDialog()
    {
        try { await fileInput.FocusAsync(); } catch {}
        try { await JS.InvokeVoidAsync("eval", "document.getElementById('rom-upload')?.click()"); } catch {}
    }

    private string GetRomSizeDisplay(string key)
    {
        if (uploadedRoms.TryGetValue(key, out var data)) return FormatSize(data.Length);
        if (builtInRomSizes.TryGetValue(key, out var s)) return FormatSize(s);
        return "?";
    }

    private static string FormatSize(int bytes)
    {
        if (bytes <= 0) return "0";
        if (bytes < 1024) return bytes+" B";
        if (bytes < 1024*1024) return (bytes/1024.0).ToString("F1")+" KB";
        return (bytes/1024.0/1024.0).ToString("F2")+" MB";
    }

    private async Task LoadSelectedRom()
    {
        try
        {
            bool wasRunning = isRunning;
            if (wasRunning) await PauseEmulation();
            if (uploadedRoms.TryGetValue(romFileName, out var data))
            {
                Status.Set($"Loading uploaded ROM {romFileName}...");
                if (nes == null) nes = new NesEmulator.NES();
                nes.RomName = romFileName;
                var prevApuSuffix = apuCoreSel;
                nes.LoadROM(data);
                if (!string.IsNullOrEmpty(prevApuSuffix)) { try { nes.SetApuCore(prevApuSuffix); } catch {} }
                autoStaticSuppressed = false; // new ROM -> allow static again if test.nes
                try { nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors); } catch {}
                SetApuCoreSelFromEmu();
                SetApuCoreSelFromEmu();
                ApplySelectedCores();
                BuildMemoryDomains();
                // Warm-up one frame to let subsystems settle before any follow-up actions
                try { nes.RunFrame(); framebuffer = nes.GetFrameBuffer(); await JS.InvokeVoidAsync("nesInterop.drawFrame", "nes-canvas", framebuffer); } catch {}
                currentRomName = romFileName;
                lastLoadedRomSize = data.Length;
                Status.Set($"ROM '{romFileName}' loaded from upload.");
                errorMessage = "";
                // Collapse ROM Manager and expand Corruptor panel (except test.nes)
                if (!string.Equals(currentRomName, "test.nes", StringComparison.OrdinalIgnoreCase))
                {
                    try { await JS.InvokeVoidAsync("nesInterop.focusCorruptorPanel"); } catch {}
                }
                if (hasBooted && wasRunning) { await StartEmulation(); }
                StateHasChanged();
            }
            else
            {
                Status.Set($"Loading built-in {romFileName}...");
                await LoadRomFromServer();
                SetApuCoreSelFromEmu();
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load selected ROM: {ex.Message}";
            StateHasChanged();
        }
    }

    private Task ReloadCurrentRom()
    {
        if (uploadedRoms.ContainsKey(romFileName))
        {
            return LoadSelectedRom();
        }
        else
        {
            return LoadRomFromServer();
        }
    }

    private async Task DeleteCurrentRom()
    {
        try
        {
            if (IsBuiltInSelected) return;
            if (uploadedRoms.Remove(romFileName))
            {
                await JS.InvokeVoidAsync("nesInterop.removeStoredRom", romFileName);
                var opt = romOptions.FirstOrDefault(o => o.Key == romFileName);
                if (opt != null) romOptions.Remove(opt);
                Status.Set($"Deleted ROM {romFileName}.");
                // fallback to first built-in
                var fallback = GetDefaultBuiltInRomKey();
                if (!string.IsNullOrEmpty(fallback))
                {
                    romFileName = fallback;
                    await LoadSelectedRom();
                }
                else
                {
                    nes = null;
                    currentRomName = "None";
                    Status.Set("No built-in ROMs available. Please upload a ROM.");
                }
            }
        }
        catch (Exception ex)
        {
            errorMessage = "Delete failed: " + ex.Message;
        }
        StateHasChanged();
    }

    private async Task LoadRomFromServer()
    {
        try
        {
            Logger.LogInformation($"Loading ROM from server: {romFileName}");
            Status.Set($"Loading {romFileName}...");

            var romData = await LoadRomFromWwwroot(romFileName);
            
            if (romData.Length == 0)
            {
                throw new Exception($"ROM file '{romFileName}' not found or empty");
            }

            bool wasRunning = isRunning;
            if (wasRunning) await PauseEmulation();
            if (nes == null) nes = new NesEmulator.NES();
            nes.RomName = romFileName;
            var prevApuSuffix = apuCoreSel;
            nes.LoadROM(romData);
            if (!string.IsNullOrEmpty(prevApuSuffix)) { try { nes.SetApuCore(prevApuSuffix); } catch {} }
            try { nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors); } catch {}
            SetApuCoreSelFromEmu();
            SetApuCoreSelFromEmu();
            ApplySelectedCores();
            currentRomName = romFileName;
            lastLoadedRomSize = romData.Length;
            if (!uploadedRoms.ContainsKey(romFileName))
            {
                // store built-in size cache
                builtInRomSizes[romFileName] = romData.Length;
            }
            // Warm-up one frame to let subsystems settle before any follow-up actions
            try { nes.RunFrame(); framebuffer = nes.GetFrameBuffer(); await JS.InvokeVoidAsync("nesInterop.drawFrame", "nes-canvas", framebuffer); } catch {}
            Status.Set($"ROM '{romFileName}' loaded successfully!");
            errorMessage = "";
            // Collapse ROM Manager and expand Corruptor panel (except test.nes)
            if (!string.Equals(currentRomName, "test.nes", StringComparison.OrdinalIgnoreCase))
            {
                try { await JS.InvokeVoidAsync("nesInterop.focusCorruptorPanel"); } catch {}
            }
            if (hasBooted && wasRunning) { await StartEmulation(); }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Failed to load ROM from server: {romFileName}. Exception: {ex}");
            errorMessage = $"Failed to load ROM: {ex.Message}\n{ex.StackTrace}";
            Status.Clear();
            StateHasChanged();
        }
    }

    private Task OnRawFileSelected(ChangeEventArgs e)
    {
        try
        {
            if (e.Value is not null)
            {
                // Not directly accessible to read file bytes without InputFile component.
                // Provide status message placeholder.
                Status.Set("File input selected (reload using server loader for now).");
            }
        }
        catch (Exception ex)
        {
            errorMessage = ex.Message;
        }
        return Task.CompletedTask;
    }

    private async Task SaveState()
    {
        if (nes == null || stateBusy) return; stateBusy = true;
        DateTime diagStart = DateTime.UtcNow;
    #if DIAG_LOG
    void Diag(string s){ try { Console.WriteLine($"[SaveStateUI] {{DateTime.UtcNow:O}} {s}"); } catch {} }
    #else
    void Diag(string s) { }
    #endif
        Diag("UI SaveState invoked");
        try
        {
            Diag("Calling nes.SaveState()");
            var raw = nes.SaveState();
            Diag(raw==null?"nes.SaveState returned null":"nes.SaveState returned length="+raw.Length);
            if (string.IsNullOrEmpty(raw)) { Status.Set("Empty state"); Diag("Empty state early return"); return; }

            // Attempt compression
            string payload = raw;
            bool compressed = false;
            try
            {
                Diag("Attempting compression");
                var gz = CompressString(raw);
                Diag("Compression produced length="+gz.Length);
                if (gz.Length < raw.Length * 0.95)
                {
                    payload = "GZ:" + gz; // prefix marker
                    compressed = true;
                    Diag("Using compressed payload");
                } else Diag("Compression not beneficial");
            }
            catch (Exception ex) { Diag("Compression failed: "+ex.Message); }

            // Clear any old chunked state
            Diag("Removing existing chunks (if any)");
            await RemoveExistingChunks();
            Diag("Existing chunks removed");

            if (payload.Length <= SaveChunkCharSize)
            {
                Diag("Payload fits single chunk length="+payload.Length);
                try
                {
                    Diag("Saving single chunk to IndexedDB");
                    await JS.InvokeVoidAsync("nesInterop.saveStateChunk", SaveKey, payload);
                    Diag("Saved single chunk; removing old manifest if any");
                    await JS.InvokeVoidAsync("nesInterop.removeStateKey", SaveKey + ".manifest");
                    Status.Set(compressed ? "State saved (compressed)" : "State saved");
                    Diag("Single chunk save complete");
                }
                catch (JSException jsex)
                {
                    errorMessage = "Save error: " + jsex.Message;
                    Diag("Single chunk save JSException: "+jsex.Message);
                }
                return;
            }

            Diag("Chunking payload length="+payload.Length+" chunkSize="+SaveChunkCharSize);
            var parts = new List<string>();
            for (int i = 0; i < payload.Length; i += SaveChunkCharSize)
            {
                parts.Add(payload.Substring(i, Math.Min(SaveChunkCharSize, payload.Length - i)));
            }
            Diag("Chunked into parts="+parts.Count);
            try
            {
                for (int i = 0; i < parts.Count; i++)
                {
                    Diag($"Saving part {i+1}/{parts.Count} length={parts[i].Length}");
                    await JS.InvokeVoidAsync("nesInterop.saveStateChunk", SaveKey + $".part{i}", parts[i]);
                }
                string manifest = $"{{\"version\":1,\"compressed\":{compressed.ToString().ToLowerInvariant()},\"parts\":{parts.Count}}}";
                Diag("Saving manifest: "+manifest);
                await JS.InvokeVoidAsync("nesInterop.saveStateChunk", SaveKey + ".manifest", manifest);
                Diag("Removing single-key SaveKey if exists");
                await JS.InvokeVoidAsync("nesInterop.removeStateKey", SaveKey);
                Status.Set(compressed ? $"State saved in {parts.Count} parts (compressed)" : $"State saved in {parts.Count} parts");
                Diag("Chunked save complete");
            }
            catch (JSException jsex)
            {
                errorMessage = "Save error (chunked): " + jsex.Message;
                Diag("Chunked save JSException: "+jsex.Message+" initiating cleanup");
                try { await RemoveExistingChunks(); } catch {}
            }
        }
        catch (Exception ex)
        {
            errorMessage = "Save error: " + ex.Message;
            Diag("Top-level SaveState exception: "+ex.Message+"\n"+ex.StackTrace);
        }
        finally { stateBusy = false; var elapsed = DateTime.UtcNow - diagStart; Diag("UI SaveState finished in "+elapsed.TotalMilliseconds.ToString("F2")+" ms"); }
    }

    private async Task LoadState()
    {
        if (stateBusy) return; stateBusy = true; bool wasRunning = isRunning;
        try
        {
            // Pause to stop RAF loop and CPU while we swap ROM/state
            if (wasRunning) await PauseEmulation();

            // Check for manifest (chunked save)
            var manifestJson = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey + ".manifest");
            string full = string.Empty;
            if (!string.IsNullOrWhiteSpace(manifestJson) && manifestJson.Contains("parts"))
            {
                try
                {
                    int parts = ExtractInt(manifestJson, "parts");
                    bool compressed = manifestJson.Contains("\"compressed\":true");
                    var sb = new System.Text.StringBuilder();
                    for (int i = 0; i < parts; i++)
                    {
                        var part = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey + $".part{i}");
                        if (part == null) { errorMessage = "Load error: missing part " + i; stateBusy = false; return; }
                        sb.Append(part);
                    }
                    full = sb.ToString();
                    if (compressed && full.StartsWith("GZ:"))
                    {
                        full = DecompressString(full.Substring(3));
                    }
                }
                catch (Exception ex)
                {
                    errorMessage = "Load error (chunked): " + ex.Message;
                    return;
                }
            }
            else
            {
                var single = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey);
                if (string.IsNullOrWhiteSpace(single)) { Status.Set("No saved state"); return; }
                if (single.StartsWith("GZ:"))
                {
                    try { full = DecompressString(single.Substring(3)); }
                    catch (Exception ex) { errorMessage = "Decompress error: " + ex.Message; return; }
                }
                else full = single;
            }

            if (!string.IsNullOrEmpty(full))
            {
                // Ensure correct ROM is loaded first and run one warm-up frame
                try
                {
                    using var doc = System.Text.Json.JsonDocument.Parse(full);
                    var root = doc.RootElement;
                    if (root.TryGetProperty("romData", out var romEl) && romEl.ValueKind == System.Text.Json.JsonValueKind.Array)
                    {
                        int len = romEl.GetArrayLength();
                        if (len > 0)
                        {
                            var romBytes = new byte[len];
                            int idx = 0; foreach (var v in romEl.EnumerateArray()) { if (idx >= len) break; romBytes[idx++] = (byte)v.GetByte(); }
                            nes = new NesEmulator.NES();
                            nes.LoadROM(romBytes);
                            try { nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors); } catch {}
                            // Warm-up frame
                            try { nes.RunFrame(); } catch {}
                            try { framebuffer = nes.GetFrameBuffer(); await JS.InvokeVoidAsync("nesInterop.drawFrame", "nes-canvas", framebuffer); } catch {}
                            BuildMemoryDomains();
                            // Capture romName metadata for UI labeling if present (deferred until after parse below)
                            try { if (root.TryGetProperty("romName", out var rnEl) && rnEl.ValueKind==System.Text.Json.JsonValueKind.String) { nes.RomName = rnEl.GetString() ?? nes.RomName; } } catch {}
                            lastLoadedRomSize = romBytes.Length;
                        }
                    }
                }
                catch {}

                // Now load the savestate
                nes.LoadState(full);
                try { var savedName = nes.GetSavedRomName(full); if(!string.IsNullOrWhiteSpace(savedName)) { nes.RomName = savedName; currentRomName = savedName; romFileName = savedName; } } catch {}
                autoStaticSuppressed = true; // prevent returning to static noise after manual load
                // If state restored into a crash/unsupported mapper mode, force IgnoreErrors to best-effort recover
                try { nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors); } catch { }
                // Reset audio timeline and draw
                try { await JS.InvokeVoidAsync("nesInterop.resetAudioTimeline"); } catch { }
                try { var _ = nes.GetAudioBuffer(); } catch {}
                framebuffer = nes.GetFrameBuffer();
                await JS.InvokeVoidAsync("nesInterop.drawFrame", "nes-canvas", framebuffer);
                Status.Set("State loaded");

                // Sync UI core selections from emulator
                try
                {
                    var apuId = nes.GetApuCoreId();
                    var suffix = NesEmulator.CoreRegistry.ExtractSuffix(apuId, "APU_");
                    bool prev = famicloneOn;
                    famicloneOn = suffix.Equals("FMC", StringComparison.OrdinalIgnoreCase);
                    if (prev != famicloneOn || !wasRunning) StateHasChanged();
                }
                catch { if (!wasRunning) StateHasChanged(); }

                try {
                    var cpuId = nes.GetCpuCoreId();
                    var ppuId = nes.GetPpuCoreId();
                    var apuId = nes.GetApuCoreId();
                    var cpuSuffix = NesEmulator.CoreRegistry.ExtractSuffix(cpuId, "CPU_");
                    var ppuSuffix = NesEmulator.CoreRegistry.ExtractSuffix(ppuId, "PPU_");
                    var apuSuffix = NesEmulator.CoreRegistry.ExtractSuffix(apuId, "APU_");
                    bool changed = false;
                    if(!string.IsNullOrWhiteSpace(cpuSuffix) && cpuCoreOptions.Contains(cpuSuffix) && cpuSuffix!=cpuCoreSel){ cpuCoreSel=cpuSuffix; changed=true; try{ await JS.InvokeVoidAsync("nesInterop.idbSetItem","pref_cpuCore",cpuCoreSel);}catch{} }
                    if(!string.IsNullOrWhiteSpace(ppuSuffix) && ppuCoreOptions.Contains(ppuSuffix) && ppuSuffix!=ppuCoreSel){ ppuCoreSel=ppuSuffix; changed=true; try{ await JS.InvokeVoidAsync("nesInterop.idbSetItem","pref_ppuCore",ppuCoreSel);}catch{} }
                    if(!string.IsNullOrWhiteSpace(apuSuffix) && apuCoreOptions.Contains(apuSuffix) && apuSuffix!=apuCoreSel){ apuCoreSel=apuSuffix; changed=true; try{ await JS.InvokeVoidAsync("nesInterop.idbSetItem","pref_apuCore",apuCoreSel);}catch{} }
                    if (changed) StateHasChanged();
                } catch {}

                // Resume if previously running
                if (hasBooted && wasRunning)
                {
                    await StartEmulation();
                }
            }
        }
        catch (Exception ex) { errorMessage = "Load error: " + ex.Message; }
        finally { stateBusy = false; }
    }

    private Task DumpState()
    {
        if (nes == null) return Task.CompletedTask;
        try { debugDump = nes.GetStateDigest(); } catch (Exception ex) { debugDump = "dump err: "+ex.Message; }
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void OpenBenchModal(){ benchModalOpen = true; StateHasChanged(); }
    private void ToggleBenchAutoLoad(){ benchAutoLoadState = !benchAutoLoadState; }
    private void ToggleBenchSimple5x(){ benchSimple5x = !benchSimple5x; }

    private async Task RunBenchmarks()
    {
        if (nes == null || benchRunning) { benchModalOpen = true; return; }
        benchModalOpen = true; benchRunning = true; benchResultsText = string.Empty; benchBaselineRomName = string.Empty; StateHasChanged();
        try {
            bool wasRunning = isRunning; // pause emulator for deterministic timing
            if (wasRunning) await PauseEmulation();
            if (benchAutoLoadState)
            {
                // Attempt to load savestate slot 0 (baseline)
                await TryLoadBaselineStateForBenchmarks();
            }
            int w = benchWeight; if (w<1) w=1; if (w>9) w=9; benchWeight = w;
            var results = nes.RunBenchmarks(w);
            benchResultsText = nes.FormatBenchmarksForDisplay(results);
            // Prepend ROM info if we resolved a baseline name
            var displayRom = string.IsNullOrWhiteSpace(benchBaselineRomName) ? currentRomName : benchBaselineRomName;
            benchResultsText = $"ROM: {displayRom}\n" + benchResultsText;
            var entry = new BenchHistoryEntry {
                TimestampUtc = DateTime.UtcNow,
                Rom = displayRom,
                CpuCore = nes.GetCpuCoreId(),
                PpuCore = nes.GetPpuCoreId(),
                ApuCore = nes.GetApuCoreId(),
                Display = benchResultsText
            };
            benchHistory.Insert(0, entry);
            currentBenchHistoryId = entry.Id;
            await PersistBenchHistory();
            if (wasRunning) await StartEmulation();
        } catch (Exception ex) { benchResultsText = "Benchmark error: "+ex.Message; }
        finally { benchRunning = false; StateHasChanged(); }
    }

    // Runs five benchmark passes sequentially, reloading the baseline state before each pass.
    private async Task RunBenchmarks5x()
    {
        if (nes == null || benchRunning) { benchModalOpen = true; return; }
        benchModalOpen = true; benchRunning = true; benchResultsText = string.Empty; benchBaselineRomName = string.Empty; StateHasChanged();
        bool wasRunning = isRunning;
        try {
            if (wasRunning) await PauseEmulation();
            int w = benchWeight; if (w<1) w=1; if (w>9) w=9; benchWeight = w;
            const int passes = 5;
            var passResults = new List<IReadOnlyList<NesEmulator.NES.BenchResult>>();
            for (int i=1;i<=passes;i++)
            {
                if (benchAutoLoadState) await TryLoadBaselineStateForBenchmarks();
                var res = nes.RunBenchmarks(w);
                passResults.Add(res);
                benchResultsText = $"Running pass {i}/{passes}..."; // live status
                StateHasChanged();
            }
            // Aggregate: assume all passes produced same sequence lengths & names
            var averaged = new List<NesEmulator.NES.BenchResult>();
            if (passResults.Count>0)
            {
                var first = passResults[0];
                for (int idx=0; idx<first.Count; idx++)
                {
                    var name = first[idx].Name;
                    int iters = first[idx].Iterations; // assumed constant
                    double msTotalAvg = passResults.Average(p=>p[idx].MsTotal);
                    double msPerIterAvg = passResults.Average(p=>p[idx].MsPerIter);
                    long cpuReadsAvg = (long)passResults.Average(p=>p[idx].CpuReads);
                    long cpuWritesAvg = (long)passResults.Average(p=>p[idx].CpuWrites);
                    long apuCyclesAvg = (long)passResults.Average(p=>p[idx].ApuCycles);
                    long oamDmaWritesAvg = (long)passResults.Average(p=>p[idx].OamDmaWrites);
                    long batchFlushesAvg = (long)passResults.Average(p=>p[idx].BatchFlushes);
                    averaged.Add(new NesEmulator.NES.BenchResult(name, iters, msTotalAvg, msPerIterAvg, cpuReadsAvg, cpuWritesAvg, apuCyclesAvg, oamDmaWritesAvg, batchFlushesAvg));
                }
            }
            // Build display text summarizing passes and averaged table
            var sb = new System.Text.StringBuilder();
            var displayRom = string.IsNullOrWhiteSpace(benchBaselineRomName) ? currentRomName : benchBaselineRomName;
            sb.AppendLine($"ROM: {displayRom}");
            sb.AppendLine("Benchmark Results (5-pass average)");
            sb.AppendLine($"Each pass weight={w}; fields averaged over {passes} passes.");
            sb.AppendLine();
            sb.AppendLine("Target Cat\tIter\tTot(ms)\tPer(ms)\tReads\tWrites\tAPU Cyc\tOAM DMA\tBatches\tAvgBatch");
            foreach (var r in averaged)
            {
                sb.AppendLine($"{r.Name}\t{r.Iterations}\t{r.MsTotal:F2}\t{r.MsPerIter:F3}\t{r.CpuReads}\t{r.CpuWrites}\t{r.ApuCycles}\t{r.OamDmaWrites}\t{r.BatchFlushes}\t{r.AvgBatchSize:F1}");
            }
            if (!benchSimple5x)
            {
                sb.AppendLine();
                sb.AppendLine("Raw Pass Summaries:");
                for (int i=0;i<passes;i++)
                {
                    sb.AppendLine($"-- Pass {i+1} --");
                    foreach (var r in passResults[i])
                    {
                        sb.AppendLine($"{r.Name}\t{r.Iterations}\t{r.MsTotal:F2}\t{r.MsPerIter:F3}\t{r.CpuReads}\t{r.CpuWrites}\t{r.ApuCycles}\t{r.OamDmaWrites}\t{r.BatchFlushes}\t{r.AvgBatchSize:F1}");
                    }
                    sb.AppendLine();
                }
            }
            benchResultsText = sb.ToString().TrimEnd();
            // Single history entry containing averaged + raw details
            var historyEntry = new BenchHistoryEntry {
                TimestampUtc = DateTime.UtcNow,
                Rom = displayRom,
                CpuCore = nes.GetCpuCoreId(),
                PpuCore = nes.GetPpuCoreId(),
                ApuCore = nes.GetApuCoreId(),
                Display = benchResultsText
            };
            benchHistory.Insert(0, historyEntry);
            currentBenchHistoryId = historyEntry.Id;
            await PersistBenchHistory();
        } catch (Exception ex) { benchResultsText = "Benchmark 5x error: "+ex.Message; }
        finally { benchRunning = false; if (wasRunning) await StartEmulation(); StateHasChanged(); }
    }

    // Silent baseline state loader used exclusively for benchmarks to improve result stability.
    // Returns true if a savestate was found & loaded; false if none or on failure.
    private async Task<bool> TryLoadBaselineStateForBenchmarks()
    {
        try
        {
            // If another save/load op is in progress, skip to avoid contention.
            if (stateBusy) return false;
            // Detect manifest (chunked) first
            var manifestJson = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey + ".manifest");
            string full = string.Empty;
            if (!string.IsNullOrWhiteSpace(manifestJson) && manifestJson.Contains("parts"))
            {
                int parts = ExtractInt(manifestJson, "parts");
                bool compressed = manifestJson.Contains("\"compressed\":true");
                var sb = new System.Text.StringBuilder();
                for (int i = 0; i < parts; i++)
                {
                    var part = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey + $".part{i}");
                    if (string.IsNullOrEmpty(part)) return false; // missing part -> abort silently
                    sb.Append(part);
                }
                full = sb.ToString();
                if (compressed && full.StartsWith("GZ:"))
                {
                    full = DecompressString(full.Substring(3));
                }
            }
            else
            {
                var single = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey);
                if (string.IsNullOrWhiteSpace(single)) return false; // no baseline saved
                if (single.StartsWith("GZ:"))
                {
                    full = DecompressString(single.Substring(3));
                }
                else full = single;
            }

            if (string.IsNullOrEmpty(full)) return false;

            // If state embeds ROM data, ensure we load it (mirrors logic in LoadState but without UI noise)
            try
            {
                using var doc = System.Text.Json.JsonDocument.Parse(full);
                var root = doc.RootElement;
                // Capture romName metadata for benchmark labeling (do not change currentRomName here)
                try { if (root.TryGetProperty("romName", out var rnEl) && rnEl.ValueKind==System.Text.Json.JsonValueKind.String) benchBaselineRomName = rnEl.GetString() ?? benchBaselineRomName; } catch {}
                if (root.TryGetProperty("romData", out var romEl) && romEl.ValueKind == System.Text.Json.JsonValueKind.Array)
                {
                    int len = romEl.GetArrayLength();
                    if (len > 0)
                    {
                        var romBytes = new byte[len];
                        int idx = 0; foreach (var v in romEl.EnumerateArray()) { if (idx >= len) break; romBytes[idx++] = (byte)v.GetByte(); }
                        nes = new NesEmulator.NES { RomName = currentRomName };
                        nes.LoadROM(romBytes);
                        try { nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors); } catch {}
                        // Warm-up a frame
                        try { nes.RunFrame(); } catch {}
                        try { framebuffer = nes.GetFrameBuffer(); await JS.InvokeVoidAsync("nesInterop.drawFrame", "nes-canvas", framebuffer); } catch {}
                        BuildMemoryDomains();
                        // If state contains romName metadata, capture for later UI update
                        try { if (root.TryGetProperty("romName", out var rnEl) && rnEl.ValueKind==System.Text.Json.JsonValueKind.String) { nes.RomName = rnEl.GetString() ?? nes.RomName; } } catch {}
                    }
                }
            }
            catch { /* ignore parse errors */ }

            nes?.LoadState(full);
            // Benchmark-specific behavior: force cores selected in the UI rather than those stored in the savestate.
            // This allows benchmarking different core implementations against the exact same memory/map baseline
            // without the savestate auto-switching cores under us. We intentionally reapply the selected cores
            // AFTER memory + mapper + ROM state are restored so that RAM/PRG/CHR data reflects the saved snapshot
            // while CPU/PPU/APU internal register state will correspond to a freshly switched core (cold state).
            // If in the future we want to attempt cross-core transfer of internal CPU/PPU/APU state, we could
            // extend ApplySelectedCores to capture and translate compatible fields, but for now the goal is
            // comparative performance, so a consistent memory baseline is sufficient.
            try { ApplySelectedCores(); } catch {}
            // Optional tiny warm-up to stabilize any core-initial one-time work before timing begins.
            try { nes?.RunFrame(); } catch {}
            try { if(nes!=null){ var savedName = nes.GetSavedRomName(full); if(!string.IsNullOrWhiteSpace(savedName)) { nes.RomName = savedName; currentRomName = savedName; romFileName = savedName; } } } catch {}
            autoStaticSuppressed = true; // ensure benchmarks display real frames
            try { nes?.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors); } catch {}
            try { await JS.InvokeVoidAsync("nesInterop.resetAudioTimeline"); } catch { }
            try { framebuffer = nes!.GetFrameBuffer(); await JS.InvokeVoidAsync("nesInterop.drawFrame", "nes-canvas", framebuffer); } catch {}
            return true;
        }
        catch
        {
            return false; // silent failure acceptable for benchmarks
        }
    }
    private void CloseBenchModal(){ benchModalOpen = false; }
    private async Task CopyBenchResults()
    {
        try { if (!string.IsNullOrEmpty(benchResultsText)) await JS.InvokeVoidAsync("navigator.clipboard.writeText", benchResultsText); } catch { }
    }

    private async Task PersistBenchHistory()
    {
        try {
            var payload = System.Text.Json.JsonSerializer.Serialize(benchHistory);
            await JS.InvokeVoidAsync("nesInterop.idbSetItem", BenchHistoryKey, payload);
        } catch {}
    }
    private async Task LoadBenchHistory()
    {
        try {
            var json = await JS.InvokeAsync<string>("nesInterop.idbGetItem", BenchHistoryKey);
            if (!string.IsNullOrWhiteSpace(json))
            {
                var list = System.Text.Json.JsonSerializer.Deserialize<List<BenchHistoryEntry>>(json);
                if (list != null) { benchHistory = list.OrderByDescending(e=>e.TimestampUtc).ToList(); }
            }
        } catch {}
    }
    private async Task ClearBenchHistory()
    {
        benchHistory.Clear(); currentBenchHistoryId=null; await PersistBenchHistory();
    }
    private void ShowHistoryEntry(string id)
    {
        currentBenchHistoryId = id == currentBenchHistoryId ? null : id;
    }
    private async Task DeleteBenchEntry(string id)
    {
        var e = benchHistory.FirstOrDefault(x=>x.Id==id); if (e!=null){ benchHistory.Remove(e); if (currentBenchHistoryId==id) currentBenchHistoryId=null; await PersistBenchHistory(); }
    }

    // === Comparison Modal Logic ===
    private void OpenCompareModal()
    {
        BuildComparisonDatasets();
        compareModalOpen = true; StateHasChanged();
    }
    private void CloseCompareModal()
    {
        compareModalOpen = false; CancelDiffAnim();
    }
    private void BuildComparisonDatasets()
    {
        recentDiffRows.Clear(); timelineSeries.Clear(); allTargets.Clear(); timelineOrder.Clear(); visibleTargets.Clear(); highlightMetricName=null; hoverIndex=null; hoverTarget=null; hoverPointTooltip=null;
        // Need chronological order (oldest -> newest) for timeline
        var chrono = benchHistory.OrderBy(e=>e.TimestampUtc).ToList();
        // Only keep the last MaxTimelineTrendPoints entries for timeline/graphing to reduce clutter
        if (chrono.Count > MaxTimelineTrendPoints)
        {
            chrono = chrono.Skip(chrono.Count - MaxTimelineTrendPoints).ToList();
        }
        if (chrono.Count < 2) return;
    // Parse each entry's structured table lines; format now includes extra columns: Target Cat\tIter\tTot(ms)\tPer(ms)\tReads\tWrites\tAPU Cyc\tOAM DMA\tBatches\tAvgBatch (older entries may lack last 2)
        var parsed = new List<(BenchHistoryEntry Entry, Dictionary<string,(double MsPerIter,long Reads,long Writes,long Apu,long Oam)>)>();
        foreach (var h in chrono)
        {
            var dict = new Dictionary<string,(double,long,long,long,long)>();
            try {
                using var sr = new System.IO.StringReader(h.Display);
                string? line; bool inTable=false;
                while ((line = sr.ReadLine()) != null)
                {
                    if (line.StartsWith("Target Cat")) { inTable=true; continue; }
                    if (!inTable) continue;
                    if (string.IsNullOrWhiteSpace(line)) break; // end of table
                    var parts = line.Split('\t');
                    if (parts.Length < 8) continue; // need at least legacy columns
                    string name = parts[0].Trim();
                    if (!double.TryParse(parts[3], System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out var msPer)) continue;
                    long.TryParse(parts[4], out var reads); long.TryParse(parts[5], out var writes); long.TryParse(parts[6], out var apu); long.TryParse(parts[7], out var oam);
                    dict[name]=(msPer,reads,writes,apu,oam);
                }
            } catch { }
            if (dict.Count>0) parsed.Add((h, dict));
        }
        if (parsed.Count < 2) return;
        // Timeline order & targets
        timelineOrder = parsed.Select(p=>p.Entry.TimestampUtc).ToList();
        allTargets = parsed.SelectMany(p=>p.Item2.Keys).Distinct().OrderBy(k=>k).ToList();
        foreach (var t in allTargets)
        {
            timelineSeries[t] = new List<TimelinePoint>();
            foreach (var entry in parsed)
            {
                if (entry.Item2.TryGetValue(t, out var v))
                    timelineSeries[t].Add(new TimelinePoint(entry.Entry.TimestampUtc, v.MsPerIter, v.Reads, v.Writes, v.Apu, v.Oam, entry.Entry.CpuCore, entry.Entry.PpuCore, entry.Entry.ApuCore, entry.Entry.Rom));
                else
                    timelineSeries[t].Add(new TimelinePoint(entry.Entry.TimestampUtc, double.NaN, 0,0,0,0, entry.Entry.CpuCore, entry.Entry.PpuCore, entry.Entry.ApuCore, entry.Entry.Rom));
            }
            visibleTargets.Add(t);
        }
        // Diff: latest vs previous
        var last = parsed[^1]; var prev = parsed[^2];
        foreach (var kv in last.Item2)
        {
            var name = kv.Key; var cur = kv.Value; if (!prev.Item2.TryGetValue(name, out var p)) continue;
            double deltaMs = cur.MsPerIter - p.MsPerIter;
            double deltaPct = p.MsPerIter != 0 ? (deltaMs / p.MsPerIter) * 100.0 : 0;
            recentDiffRows.Add(new DiffRow(name, cur.MsPerIter, p.MsPerIter, deltaMs, deltaPct, cur.Reads - p.Reads, cur.Writes - p.Writes, cur.Apu - p.Apu, cur.Oam - p.Oam));
        }
        recentDiffRows = recentDiffRows.OrderBy(r=>r.Name).ToList();
    }
    private void ToggleTarget(string target)
    {
        if (visibleTargets.Contains(target)) visibleTargets.Remove(target); else visibleTargets.Add(target); StateHasChanged();
    }
    // Hover state & handlers for timeline tooltip
    private int? hoverIndex = null; private string? hoverTarget = null; private HoverTooltip? hoverPointTooltip = null; private double hoverTooltipLeftPx=0; private double hoverTooltipTopPx=0;
    private record HoverTooltip(string Target,string TimeLabel,double MsPerIter,long Reads,long Writes,long ApuCycles,long OamWrites,string CpuCore,string PpuCore,string ApuCore,string Rom);
    private void TimelineMouseLeave(){ hoverIndex=null; hoverTarget=null; hoverPointTooltip=null; }
    private void TimelineMouseMove(MouseEventArgs e)
    {
        if (timelineOrder.Count==0 || visibleTargets.Count==0) return;
        double plotW=960, plotH=200, left=30, top=20; int count = timelineOrder.Count;
        double mouseX = e.OffsetX; double mouseY = e.OffsetY;
        if (mouseX < left-5 || mouseX > left+plotW+5 || mouseY < top-5 || mouseY > top+plotH+15) { TimelineMouseLeave(); StateHasChanged(); return; }
        var frac = (mouseX - left)/Math.Max(1,plotW); frac = Math.Clamp(frac,0,1); int idx = (int)Math.Round(frac*(count-1));
        if (idx<0 || idx>=count) { TimelineMouseLeave(); StateHasChanged(); return; }
        string? bestTarget=null; double bestDy=double.MaxValue; double bestY=0; double globalMax=0;
        if (!compareNormalize)
        {
            foreach (var t in visibleTargets)
                foreach (var v in timelineSeries[t]) if (!double.IsNaN(v.MsPerIter) && v.MsPerIter>globalMax) globalMax=v.MsPerIter;
            if (globalMax<=0) globalMax=1;
        }
        foreach (var t in visibleTargets)
        {
            var pt = timelineSeries[t][idx]; if (double.IsNaN(pt.MsPerIter)) continue;
            double y;
            if (compareNormalize){
                double minT=double.MaxValue,maxT=double.MinValue; foreach (var v in timelineSeries[t]) if(!double.IsNaN(v.MsPerIter)){ if(v.MsPerIter<minT) minT=v.MsPerIter; if(v.MsPerIter>maxT) maxT=v.MsPerIter; }
                if (minT==double.MaxValue){ minT=0; maxT=1; }
                if (Math.Abs(maxT-minT) < 1e-9) maxT = minT+1;
                var norm = (pt.MsPerIter - minT)/(maxT-minT);
                y = top+plotH - norm*plotH;
            } else {
                y = top+plotH - (pt.MsPerIter/globalMax)*plotH;
            }
            var dy = Math.Abs(y - mouseY);
            if (dy < bestDy){ bestDy=dy; bestTarget=t; bestY=y; }
        }
        if (bestTarget==null){ TimelineMouseLeave(); StateHasChanged(); return; }
        hoverIndex = idx; hoverTarget = bestTarget;
        var hpt = timelineSeries[bestTarget][idx];
        var timeLabel = timelineOrder[idx].ToLocalTime().ToString("HH:mm:ss");
    hoverPointTooltip = new HoverTooltip(bestTarget,timeLabel,hpt.MsPerIter,hpt.Reads,hpt.Writes,hpt.Apu,hpt.Oam,hpt.CpuCore,hpt.PpuCore,hpt.ApuCore,hpt.Rom);
        double hoverX = left + plotW*(idx/(double)Math.Max(1,count-1));
        hoverTooltipLeftPx = Math.Clamp(hoverX + 12, 0, 1000-190);
        hoverTooltipTopPx = Math.Clamp(bestY - 10, 0, 240-120);
        StateHasChanged();
    }
    private string ColorForTarget(string target)
    {
        // Simple stable hash -> color palette
        int h=0; foreach (var c in target){ h = (h*31 + c) & 0xFFFFFF; }
        int r = (h & 0xFF0000)>>16; int g=(h & 0x00FF00)>>8; int b=h&0xFF;
        // boost brightness
        r = (r+128)/2; g=(g+128)/2; b=(b+128)/2;
        return $"rgb({r},{g},{b})";
    }
    private async Task PlayDiffAnimation()
    {
        if (diffAnimating || recentDiffRows.Count==0) return; CancelDiffAnim(); diffAnimating=true; diffAnimCts = new CancellationTokenSource();
        try {
            foreach (var row in recentDiffRows)
            {
                highlightMetricName = row.Name; StateHasChanged(); await Task.Delay(900, diffAnimCts.Token);
            }
        } catch { }
        finally { diffAnimating=false; highlightMetricName=null; StateHasChanged(); }
    }
    private void CancelDiffAnim(){ try { diffAnimCts?.Cancel(); } catch {} diffAnimating=false; highlightMetricName=null; }

    private void BuildMemoryDomains()
    {
        memoryDomains.Clear();
        if (nes == null) return;
        try {
            memoryDomains.Add(new DomainSel{ Key="PRG", Label="PRG ROM", Size=GetApproxSize(idx=>nes.PeekPrg(idx)), Selected=false});
            memoryDomains.Add(new DomainSel{ Key="PRGRAM", Label="PRG RAM", Size=GetApproxSize(idx=>nes.PeekPrgRam(idx)), Selected=false});
            memoryDomains.Add(new DomainSel{ Key="CHR", Label="CHR", Size=GetApproxSize(idx=>nes.PeekChr(idx)), Selected=false});
            memoryDomains.Add(new DomainSel{ Key="RAM", Label="System RAM", Size=2048, Selected=true});
        } catch {}
        StateHasChanged();
    }

    // Inline editing of benchmark ROM/note
    private string? editingBenchRomId = null; private string editingBenchRomValue = string.Empty;
    private void StartBenchRomEdit(BenchHistoryEntry entry)
    {
        editingBenchRomId = entry.Id; editingBenchRomValue = entry.Rom; StateHasChanged();
    }
    private async Task CommitBenchRomEdit(string id)
    {
        if (editingBenchRomId != id) { editingBenchRomId=null; return; }
        var e = benchHistory.FirstOrDefault(x=>x.Id==id);
        if (e!=null)
        {
            var newVal = editingBenchRomValue?.Trim() ?? string.Empty;
            if (newVal.Length>0 && newVal != e.Rom)
            {
                e.Rom = newVal;
                // Update first line in Display if starts with ROM:
                if (!string.IsNullOrEmpty(e.Display))
                {
                    var lines = e.Display.Split('\n');
                    if (lines.Length>0 && lines[0].StartsWith("ROM:")) { lines[0] = $"ROM: {newVal}"; e.Display = string.Join('\n', lines); }
                }
                await PersistBenchHistory();
                if (compareModalOpen) BuildComparisonDatasets();
            }
        }
        editingBenchRomId=null; editingBenchRomValue=string.Empty; StateHasChanged();
    }
    private async void HandleBenchRomEditKey(KeyboardEventArgs e, string id)
    {
        if (e.Key=="Enter") await CommitBenchRomEdit(id); else if (e.Key=="Escape") { editingBenchRomId=null; StateHasChanged(); }
    }

    private void OnCrashBehaviorChanged(ChangeEventArgs e)
    {
        if (e.Value is string v)
        {
            crashBehavior = v;
            try
            {
                if (nes != null)
                {
                    if (v == "IgnoreErrors") nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.IgnoreErrors);
                    else nes.SetCrashBehavior(NesEmulator.NES.CrashBehavior.RedScreen);
                }
            }
            catch { }
        }
    }

    private int GetApproxSize(Func<int,byte> peek)
    {
        int size = 1024;
        int lastNonZero = 0;
        for (int i=0;i<size;i+=128){ if (peek(i)!=0) lastNonZero=i; }
        for (int i=1024;i<=512*1024;i*=2)
        {
            byte v = peek(i-1);
            if (v!=0) lastNonZero = i-1;
            else { size = i; break; }
        }
        return Math.Max( (lastNonZero+256) & ~255, 0);
    }

    private void DomainsChanged(ChangeEventArgs e)
    {
        // TODO: implement manual multiple select tracking if needed
    }
    private void OnIntensityChange(ChangeEventArgs e) { if (int.TryParse(e.Value?.ToString(), out var v)) corruptIntensity = Math.Clamp(v,1,65535); }
    private void OnIntensityBoxChange(ChangeEventArgs e) { OnIntensityChange(e); }
    private void ToggleAutoCorruptButton() { autoCorrupt = !autoCorrupt; lastBlastInfo = autoCorrupt ? "Auto-corrupt enabled" : "Auto-corrupt disabled"; }
    private void LetItRip()
    {
        corruptIntensity = 1;
        foreach (var d in memoryDomains)
        {
            d.Selected = d.Key == "PRG" || d.Key == "RAM"; // Only PRG ROM & System RAM
        }
        if (!autoCorrupt)
        {
            autoCorrupt = true;
            lastBlastInfo = "Auto-corrupt enabled (Let it rip)";
        }
        else
        {
            lastBlastInfo = "Let it rip engaged";
        }
    letItRipUsed = true;
        StateHasChanged();
    }

    private Task Blast()
    {
        if (nes == null) return Task.CompletedTask;
        var selected = memoryDomains.Where(d=>d.Selected && d.Size>0).ToList();
        if (selected.Count==0) return Task.CompletedTask;
        int writes = Math.Clamp(corruptIntensity,1,4096);
        for (int i=0;i<writes;i++)
        {
            var d = selected[corruptRnd.Next(selected.Count)];
            int addr = corruptRnd.Next(d.Size);
            byte orig = 0;
            switch (d.Key) {
                case "PRG": orig = nes.PeekPrg(addr); break;
                case "PRGRAM": orig = nes.PeekPrgRam(addr); break;
                case "CHR": orig = nes.PeekChr(addr); break;
                case "RAM": orig = nes.PeekSystemRam(addr); break;
            }
            string mode = blastType;
            if (mode == "RANDOMTILT") mode = corruptRnd.Next(2)==0 ? "RANDOM" : "TILT";
            byte newVal = orig;
            switch (mode)
            {
                case "RANDOM":
                    newVal = (byte)corruptRnd.Next(256);
                    break;
                case "TILT":
                    // +/-1 with wrap
                    newVal = (byte)(orig + (corruptRnd.Next(2)==0 ? 1 : 255));
                    break;
                case "NOP":
                    newVal = 0xEA; // 6502 NOP
                    break;
                case "BITFLIP":
                    int bit = corruptRnd.Next(8);
                    newVal = (byte)(orig ^ (1 << bit));
                    break;
            }
            switch (d.Key) {
                case "PRG": nes.PokePrg(addr,newVal); break;
                case "PRGRAM": nes.PokePrgRam(addr,newVal); break;
                case "CHR": nes.PokeChr(addr,newVal); break;
                case "RAM": nes.PokeSystemRam(addr,newVal); break;
            }
        }
        lastBlastInfo = autoCorrupt ? $"Auto {writes} ({blastType})/{selected.Count} domain(s)" : $"{blastType}: {writes} writes over {selected.Count} domain(s)";
        return Task.CompletedTask;
    }

    private void OnBlastTypeChanged(ChangeEventArgs e)
    {
        if (e.Value is string v && !string.IsNullOrWhiteSpace(v))
        {
            blastType = v.Trim().ToUpperInvariant();
        }
    }

    // ================ Glitch Harvester methods =================
    private void GhAddBaseState()
    {
        if (nes == null) return;
        try
        {
            var raw = nes.SaveState();
            if (string.IsNullOrEmpty(raw)) return;
            var name = string.IsNullOrWhiteSpace(ghNewBaseName) ? $"Base {ghBaseStates.Count+1}" : ghNewBaseName.Trim();
            var b = new HarvesterBaseState { Name = name, State = raw };
            ghBaseStates.Add(b);
            ghSelectedBaseId = b.Id;
            ghNewBaseName = string.Empty;
        }
    catch (Exception ex) { Status.Set("GH base add failed: "+ex.Message); }
    }
    private void GhOnBaseChanged(ChangeEventArgs e)
    { if (e.Value is string v) ghSelectedBaseId = v; }
    private async Task GhLoadSelectedBase()
    {
    if (nes == null) return; var b = ghBaseStates.FirstOrDefault(x=>x.Id==ghSelectedBaseId); if (b==null) return; try { nes.LoadState(b.State); autoStaticSuppressed = true; framebuffer = nes.GetFrameBuffer(); await JS.InvokeVoidAsync("nesInterop.drawFrame", "nes-canvas", framebuffer); Status.Set($"Loaded base '{b.Name}'"); } catch (Exception ex) { Status.Set("GH load base err: "+ex.Message); }
    }
    private void GhDeleteSelectedBase()
    { var b = ghBaseStates.FirstOrDefault(x=>x.Id==ghSelectedBaseId); if (b==null) return; ghBaseStates.Remove(b); if (!ghBaseStates.Any()) ghSelectedBaseId = string.Empty; else ghSelectedBaseId = ghBaseStates.Last().Id; }
    private List<BlastInstruction> GhGenerateBlastLayer(int writes)
    {
        var result = new List<BlastInstruction>();
        var selected = memoryDomains.Where(d=>d.Selected && d.Size>0).ToList(); if (selected.Count==0) return result; writes = Math.Clamp(writes,1,4096);
        for (int i=0;i<writes;i++)
        {
            var d = selected[corruptRnd.Next(selected.Count)];
            int addr = corruptRnd.Next(d.Size);
            byte orig = 0; try { switch(d.Key){ case "PRG": orig = nes?.PeekPrg(addr)??0; break; case "PRGRAM": orig = nes?.PeekPrgRam(addr)??0; break; case "CHR": orig = nes?.PeekChr(addr)??0; break; case "RAM": orig = nes?.PeekSystemRam(addr)??0; break; } } catch {}
            string mode = blastType; if (mode=="RANDOMTILT") mode = corruptRnd.Next(2)==0?"RANDOM":"TILT"; byte newVal = orig; switch(mode){ case "RANDOM": newVal = (byte)corruptRnd.Next(256); break; case "TILT": newVal = (byte)(orig + (corruptRnd.Next(2)==0 ? 1 : 255)); break; case "NOP": newVal = 0xEA; break; case "BITFLIP": int bit = corruptRnd.Next(8); newVal = (byte)(orig ^ (1<<bit)); break; }
            result.Add(new BlastInstruction{ Domain=d.Key, Address=addr, Value=newVal });
        }
        return result;
    }
    private void GhApplyBlastLayer(IEnumerable<BlastInstruction> writes)
    {
        if (nes==null) return; foreach (var w in writes){ try { switch(w.Domain){ case "PRG": nes.PokePrg(w.Address,w.Value); break; case "PRGRAM": nes.PokePrgRam(w.Address,w.Value); break; case "CHR": nes.PokeChr(w.Address,w.Value); break; case "RAM": nes.PokeSystemRam(w.Address,w.Value); break; } } catch {} }
    }
    private async Task GhCorruptAndStash()
    {
        if (nes==null || !GhHasSelectedBase) return; var baseState = ghBaseStates.First(b=>b.Id==ghSelectedBaseId);
        try {
            nes.LoadState(baseState.State); autoStaticSuppressed = true; // ensure deterministic start (disable static)
            var writes = GhGenerateBlastLayer(Math.Clamp(corruptIntensity,1,1024));
            GhApplyBlastLayer(writes);
            var entry = new HarvestEntry { Name = $"Stash {++ghStashCounter}", BaseStateId = baseState.Id, Writes = writes };
            ghStash.Add(entry);
            Status.Set($"Stashed {writes.Count} writes based on '{baseState.Name}'");
        } catch (Exception ex){ Status.Set("GH corrupt err: "+ex.Message); }
        await InvokeAsync(StateHasChanged);
    }
    private string GhFindBaseName(string id) => ghBaseStates.FirstOrDefault(b=>b.Id==id)?.Name ?? "?";
    private void GhDeleteStash(string id){ var e = ghStash.FirstOrDefault(x=>x.Id==id); if (e!=null) ghStash.Remove(e); }
    private void GhPromoteEntry(HarvestEntry e){ ghStash.Remove(e); e.Name = $"Entry {++ghStockpileCounter}"; ghStockpile.Add(e); }
    private async Task GhReplayEntry(HarvestEntry e, bool fromStockpile){ var baseState = ghBaseStates.FirstOrDefault(b=>b.Id==e.BaseStateId); if (nes==null || baseState==null) return; try { nes.LoadState(baseState.State); autoStaticSuppressed = true; GhApplyBlastLayer(e.Writes); framebuffer = nes.GetFrameBuffer(); await JS.InvokeVoidAsync("nesInterop.drawFrame","nes-canvas", framebuffer); Status.Set($"Replayed {(fromStockpile?"stockpile":"stash")} '{e.Name}'"); } catch (Exception ex){ Status.Set("GH replay err: "+ex.Message); } }
    private void GhDeleteStock(string id){ var e = ghStockpile.FirstOrDefault(x=>x.Id==id); if (e!=null) ghStockpile.Remove(e); if (ghRenamingId==id){ ghRenamingId=null; ghRenameText=""; } }
    private void GhClearStash(){ ghStash.Clear(); }
    private bool GhIsRenaming(string id) => ghRenamingId==id;
    private void GhBeginRename(HarvestEntry e){ ghRenamingId = e.Id; ghRenameText = e.Name; }
    private void GhCancelRename(){ ghRenamingId=null; ghRenameText=""; }
    private void GhRenameChange(ChangeEventArgs e){ if (e.Value is string v) ghRenameText=v; }
    private void GhCommitRename(string id){ var e = ghStockpile.FirstOrDefault(x=>x.Id==id); if (e!=null && !string.IsNullOrWhiteSpace(ghRenameText)) e.Name = ghRenameText.Trim(); GhCancelRename(); }
    private async Task GhExportStockpile(){ try { var exportObj = ghStockpile.Select(e=> new { e.Id, e.Name, e.BaseStateId, e.Created, Writes=e.Writes, BaseState = ghBaseStates.FirstOrDefault(b=>b.Id==e.BaseStateId)?.State }).ToList(); var json = System.Text.Json.JsonSerializer.Serialize(exportObj); await JS.InvokeVoidAsync("nesInterop.downloadText", $"stockpile_{DateTime.UtcNow:yyyyMMdd_HHmmss}.json", json); Status.Set("Exported stockpile"); } catch (Exception ex){ Status.Set("Export failed: "+ex.Message); } }
    private async Task GhImportStockpile(ChangeEventArgs e){ try { if (e.Value==null) return; // use JS to read file(s)
            var files = await JS.InvokeAsync<object[]>("nesInterop.readFilesAsText", e.Value); if (files==null) return; int added=0; foreach (var f in files){ if (f is string json){ try { var doc = System.Text.Json.JsonDocument.Parse(json); foreach (var elem in doc.RootElement.EnumerateArray()){ var baseStateId = elem.GetProperty("BaseStateId").GetString()??""; var baseStateData = elem.TryGetProperty("BaseState", out var bsEl)? bsEl.GetString():null; if (!ghBaseStates.Any(b=>b.Id==baseStateId) && !string.IsNullOrEmpty(baseStateData)){ ghBaseStates.Add( new HarvesterBaseState{ Id=baseStateId, Name=$"Imported {ghBaseStates.Count+1}", State=baseStateData }); }
                        var entry = new HarvestEntry { Id = elem.GetProperty("Id").GetString()??Guid.NewGuid().ToString(), Name = elem.GetProperty("Name").GetString()??$"Imp {++ghStockpileCounter}", BaseStateId = baseStateId, Created = elem.TryGetProperty("Created", out var cEl)? cEl.GetDateTime():DateTime.UtcNow, Writes = new List<BlastInstruction>() };
                        if (elem.TryGetProperty("Writes", out var wArr)) { foreach (var w in wArr.EnumerateArray()){ entry.Writes.Add(new BlastInstruction{ Domain = w.GetProperty("Domain").GetString()??"", Address = w.GetProperty("Address").GetInt32(), Value = (byte)w.GetProperty("Value").GetInt32()}); } }
                        ghStockpile.Add(entry); added++; }
                    } catch {} } }
            if (added>0) Status.Set($"Imported {added} entries"); }
        catch (Exception ex){ Status.Set("Import failed: "+ex.Message); } }

    public void Dispose()
    {
        try
        {
            JS.InvokeVoidAsync("nesInterop.stopEmulationLoop");
            // Dispose shared DotNetObjectReference to avoid leaks (Theory 2)
            _selfRef?.Dispose();
            _selfRef = null;
            Logger.LogInformation("BrokenNes disposed");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error disposing NES emulator");
        }
    }

    public class UploadedRom
    {
        public string name { get; set; } = string.Empty; // JS property casing
        public string base64 { get; set; } = string.Empty;
    }

    private async Task Boot()
    {
        if (hasBooted) return;
        hasBooted = true;
        try { await JS.InvokeVoidAsync("nesInterop.ensureAudioContext"); } catch { }
        // If ROM already loaded, start now
        if (nes != null && !isRunning)
        {
            await StartEmulation();
        }
        StateHasChanged();
    }

    // ===== JS Invokable wrappers for mobile fullscreen bottom bar =====
    [JSInvokable]
    public Task JsSaveState() => SaveState();
    [JSInvokable]
    public Task JsLoadState() => LoadState();
    [JSInvokable]
    public void JsResetGame() => ResetEmulation();
    [JSInvokable]
    public void JsExitFullscreen()
    {
        isFullscreen = false;
        StateHasChanged();
    }

    // Called from JS when ROMs dropped via drag & drop
    [JSInvokable]
    public async Task OnRomsDropped(UploadedRom[] roms)
    {
        if (roms == null || roms.Length == 0) return;
        int added = 0;
        foreach (var f in roms)
        {
            if (string.IsNullOrWhiteSpace(f.name) || string.IsNullOrWhiteSpace(f.base64)) continue;
            try
            {
                var data = Convert.FromBase64String(f.base64);
                if (data.Length == 0) continue;
                uploadedRoms[f.name] = data;
                if (!romOptions.Any(o => o.Key == f.name))
                {
                    romOptions.Add(new RomOption { Key = f.name, Label = f.name + " (uploaded)", BuiltIn = false });
                }
                added++;
            }
            catch { }
        }
        romFileName = roms.Last().name;
        await LoadSelectedRom();
        Status.Set($"Dropped {added} ROM(s).");
        if (!string.Equals(currentRomName, "test.nes", StringComparison.OrdinalIgnoreCase))
        {
            try { await JS.InvokeVoidAsync("nesInterop.focusCorruptorPanel"); } catch {}
        }
    }

    // ================= Helper methods for compressed & chunked saves =================
    private static string CompressString(string input)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(input);
        using var ms = new MemoryStream();
        using (var gzip = new System.IO.Compression.GZipStream(ms, System.IO.Compression.CompressionLevel.Fastest, true))
        {
            gzip.Write(bytes, 0, bytes.Length);
        }
        return Convert.ToBase64String(ms.ToArray());
    }

    private static string DecompressString(string base64)
    {
        var data = Convert.FromBase64String(base64);
        using var ms = new MemoryStream(data);
        using var gzip = new System.IO.Compression.GZipStream(ms, System.IO.Compression.CompressionMode.Decompress);
        using var outMs = new MemoryStream();
        gzip.CopyTo(outMs);
        return System.Text.Encoding.UTF8.GetString(outMs.ToArray());
    }

    private int ExtractInt(string json, string prop)
    {
        try
        {
            var token = "\"" + prop + "\":";
            int idx = json.IndexOf(token, StringComparison.Ordinal);
            if (idx >= 0)
            {
                idx += token.Length;
                int end = idx;
                while (end < json.Length && char.IsDigit(json[end])) end++;
                if (int.TryParse(json.Substring(idx, end - idx), out var val)) return val;
            }
        }
        catch { }
        return 0;
    }

    private async Task RemoveExistingChunks()
    {
        try
        {
            var manifestJson = await JS.InvokeAsync<string>("nesInterop.getStateChunk", SaveKey + ".manifest");
            if (!string.IsNullOrWhiteSpace(manifestJson) && manifestJson.Contains("parts"))
            {
                int parts = ExtractInt(manifestJson, "parts");
                for (int i = 0; i < parts; i++)
                {
                    await JS.InvokeVoidAsync("nesInterop.removeStateKey", SaveKey + $".part{i}");
                }
                await JS.InvokeVoidAsync("nesInterop.removeStateKey", SaveKey + ".manifest");
            }
        }
        catch { }
    }
}

@code {
    protected override void OnInitialized()
    {
        // Central registry discovery (cached)
        cpuCoreOptions = NesEmulator.CoreRegistry.CpuIds.ToList();
        if (string.IsNullOrEmpty(cpuCoreSel) || !cpuCoreOptions.Contains(cpuCoreSel))
        {
            // Prefer FMC first (baseline), then FIX, then first
            if (cpuCoreOptions.Contains("FMC")) cpuCoreSel = "FMC";
            else if (cpuCoreOptions.Contains("FIX")) cpuCoreSel = "FIX";
            else if (cpuCoreOptions.Count>0) cpuCoreSel = cpuCoreOptions[0];
        }
        ppuCoreOptions = NesEmulator.CoreRegistry.PpuIds.ToList();
    // Ensure stable ordering; include newer enhanced cores when present
    var desiredOrder = new List<string>{"FMC","NGTV","CUBE","BFR","LQ","FIX","LOW"};
        ppuCoreOptions = ppuCoreOptions.OrderBy(id => desiredOrder.IndexOf(id) >=0 ? desiredOrder.IndexOf(id) : 99).ToList();
        if (!ppuCoreOptions.Contains(ppuCoreSel) && ppuCoreOptions.Count>0)
        {
            // Prefer FMC baseline; else fall back to others
			if (ppuCoreOptions.Contains("FMC")) ppuCoreSel = "FMC"; else if (ppuCoreOptions.Contains("NGTV")) ppuCoreSel = "NGTV"; else if (ppuCoreOptions.Contains("CUBE")) ppuCoreSel = "CUBE"; else ppuCoreSel = ppuCoreOptions[0];
        }
        apuCoreOptions = NesEmulator.CoreRegistry.ApuIds.ToList();
        // Ordering preference: FMC (legacy), FIX (modern), QN, then others alphabetical
    apuCoreOptions = apuCoreOptions.OrderBy(id => id switch { "FMC" => 0, "FIX" => 1, "QN" => 2, _ => 3 }).ThenBy(id=>id).ToList();
        if (string.IsNullOrEmpty(apuCoreSel) || !apuCoreOptions.Contains(apuCoreSel))
        {
            if (apuCoreOptions.Contains("FMC")) apuCoreSel = "FMC";
            else if (apuCoreOptions.Contains("FIX")) apuCoreSel = "FIX";
            else if (apuCoreOptions.Count>0) apuCoreSel = apuCoreOptions[0];
        }
        // Load persisted event scheduler preference asynchronously (fire and forget)
        _ = Task.Run(async () => {
            try {
                var val = await JS.InvokeAsync<string>("nesInterop.idbGetItem", "pref_eventScheduler");
                if (!string.IsNullOrEmpty(val))
                {
                    bool on = val == "1" || val.Equals("true", StringComparison.OrdinalIgnoreCase);
                    await InvokeAsync(()=>{
                        eventSchedulerOn = on; if (nes!=null) nes.EnableEventScheduler = on; StateHasChanged();
                    });
                }
            } catch { }
        });
    }
}
