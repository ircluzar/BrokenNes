@page "/continue"
@using NesEmulator
@using NesEmulator.Shaders
@using System.Text.Json
@using BrokenNes.Shared
@inject IJSRuntime JS
@inject NavigationManager Nav
@inject BrokenNes.Services.GameSaveService SaveSvc
@inject IShaderProvider ShaderProvider

<div class="options-root continue-root">
  <h2 class="opt-title">DECK BUILDER</h2>

  <section class="cont-header">
    <div class="hdr-main">
      <div class="lvl-title">
        <span class="chip">@CurrentLevel</span>
        <strong>@LevelTitle</strong>
      </div>
      <div class="lvl-status">
        <span class="status-chip @(LevelCleared?"cleared":"not-cleared")" title="@(LevelCleared?"Any 1 achievement completed":"No achievements completed yet")">
          @(LevelCleared?"Cleared":"Not Cleared")
        </span>
      </div>
    </div>
    <div class="hdr-cards">
      <span class="small-note">Enforced:</span>
      @foreach (var c in EnforcedCards)
      {
        <button type="button" class="enf-chip" style="border-color:@c.border" title="View card" @onclick="(()=>OpenCardZoom(c.domain, c.id))">@c.label</button>
      }
    </div>
    <div class="hdr-cta">
      <button class="btn-next" disabled="@(!CanAdvanceLevel)" title="Requires @RequiredStars stars" @onclick="AdvanceLevel">Go to next level (@RequiredStars ⭐)</button>
    </div>
  </section>

  <section class="opt-section">
    <h3 class="opt-h3">Build Console</h3>
    <div class="core-grid">
      @CoreSlot("CPU", EnforcedCpu, SelectedCpu, OpenCpuPicker)
      @CoreSlot("PPU", EnforcedPpu, SelectedPpu, OpenPpuPicker)
      @CoreSlot("APU", EnforcedApu, SelectedApu, OpenApuPicker)
  @CoreSlot("SHADER", EnforcedShader, SelectedShader, OpenShaderPicker)
    </div>
  </section>

  <section class="opt-section">
    <h3 class="opt-h3">Game (ROM)</h3>
    <div class="rom-box small-note">
      No compatible ROMs registered yet. Use the ROM Manager in the Emulator to import ROMs. This panel will list compatible games in a later milestone.
    </div>
  </section>

  <section class="opt-section">
    <h3 class="opt-h3">Achievements</h3>
    <div class="ach-box small-note">Select a compatible game to view achievements. (Coming soon)
    </div>
  </section>

  <div class="opt-footer">
    <button class="opt-link start-btn" disabled title="Build valid and game with achievements required">Start the game</button>
    <a href="./deck-builder?skipHW=1" class="opt-link" @onclick="OnReturn" @onclick:preventDefault>RETURN</a>
  </div>
</div>

@if (ZoomCard != null)
{
  <div class="card-modal-backdrop @(ModalClosing?"closing":"opening")" @onclick="CloseZoom">
    <div class="card-modal-content @(ModalClosing?"closing":"opening")" @onclick="CloseZoom">
      @((MarkupString)CardSvgRenderer.Render(ZoomCard))
    </div>
  </div>
}

@code {
  // State
  private int CurrentLevel = 1;
  private int Stars = 0;
  private string LevelTitle = "FMC Warmup";
  private int RequiredStars = 5;

  private (string domain, string id, string label, string border)[] EnforcedCards = Array.Empty<(string,string,string,string)>();

  // Enforced slots (null = not enforced)
  private string? EnforcedCpu = null;
  private string? EnforcedPpu = null;
  private string? EnforcedApu = null;
  private string? EnforcedShader = null;

  // Player-selected (temporary choices for this level/session)
  private string? SelectedCpu = null;
  private string? SelectedPpu = null;
  private string? SelectedApu = null;
  private string? SelectedShader = null;

  private CoreCardModel? ZoomCard;
  private bool ModalClosing = false;
  private bool _zoomInit = false;

  // Owned choices
  private IReadOnlyList<string> OwnedCpu = Array.Empty<string>();
  private IReadOnlyList<string> OwnedPpu = Array.Empty<string>();
  private IReadOnlyList<string> OwnedApu = Array.Empty<string>();
  private IReadOnlyList<string> OwnedShader = Array.Empty<string>();

  protected override async Task OnInitializedAsync()
  {
    try { await JS.InvokeVoidAsync("nesInterop.ensureAudioContext"); } catch { }
    try { await JS.InvokeVoidAsync("nesInterop.applySavedAudioVolumes"); } catch { }
    try { await JS.InvokeVoidAsync("eval", "window.homePixelBgEnsure && window.homePixelBgEnsure();"); } catch { }

  // Load save, then fetch level data from continueDb and derive enforced chips and cost
  var save = await SaveSvc.LoadAsync();
  CurrentLevel = Math.Max(1, save.Level);
  Stars = save.Achievements?.Count ?? 0;
  await LoadLevelFromDbAsync(CurrentLevel);

  // Owned sets (used by pickers)
  OwnedCpu = (save.OwnedCpuIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();
  OwnedPpu = (save.OwnedPpuIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();
  OwnedApu = (save.OwnedApuIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();
  OwnedShader = (save.OwnedShaderIds ?? new()).OrderBy(s=>s, StringComparer.OrdinalIgnoreCase).ToArray();
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      // Crossfade into DeckBuilder music for continuity
      try { await JS.InvokeVoidAsync("nesInterop.fadeOutAndStopTitleMusic"); } catch { }
      try { await JS.InvokeVoidAsync("eval", @"(function(){try{var want='music/DeckBuilder.mp3';if(!window.music)return;var cur=(typeof window.music.currentSrc==='function'?(window.music.currentSrc()||''):''),isP=(typeof window.music.isPlaying==='function'&&!!window.music.isPlaying());if(cur.indexOf('DeckBuilder.mp3')!==-1&&isP)return;if(isP&&typeof window.music.fadeOut==='function'){try{window.music.fadeOut(700,true);}catch(e){} setTimeout(function(){try{window.music.play(want,{loop:true,fadeInMs:900});}catch(e){}},150);} else {try{window.music.play(want,{loop:true,fadeInMs:700});}catch(e){}}}catch(e){}})();"); } catch { }
    }

    if (ZoomCard != null && !_zoomInit)
    {
      _zoomInit = true;
      try { await JS.InvokeVoidAsync("eval", @"(function(){window.nesUi=window.nesUi||{};window.nesUi.zoomModalSvg=function(){try{var host=document.querySelector('.card-modal-content');if(!host)return;var svg=host.querySelector('svg');if(!svg)return;svg.removeAttribute('width');svg.removeAttribute('height');svg.style.width='98vw';svg.style.maxWidth='98vw';svg.style.height='auto';svg.style.maxHeight='98vh';svg.style.display='block';}catch(e){}};window.nesUi.zoomModalSvg();})();"); } catch { }
    }
  }

  private bool LevelCleared => Stars > 0; // Placeholder until per-level attribution exists
  private bool CanAdvanceLevel => Stars >= RequiredStars;
  private bool BuildValid => (EnforcedCpu ?? SelectedCpu) != null
    && (EnforcedPpu ?? SelectedPpu) != null
    && (EnforcedApu ?? SelectedApu) != null
    && (EnforcedShader ?? SelectedShader) != null;

  private async Task AdvanceLevel()
  {
    try
    {
      var save = await SaveSvc.LoadAsync();
      if (Stars < RequiredStars) return;
      save.Level = Math.Max(1, save.Level) + 1;
      // Grant any forced cards for next level here (stub: grant FMC if missing)
      void grant(List<string> list, string id){ if (!list.Contains(id, StringComparer.OrdinalIgnoreCase)) list.Add(id); }
      save.OwnedCpuIds ??= new(); save.OwnedPpuIds ??= new(); save.OwnedApuIds ??= new();
      grant(save.OwnedCpuIds, "FMC"); grant(save.OwnedPpuIds, "FMC"); grant(save.OwnedApuIds, "FMC");
      await SaveSvc.SaveAsync(save);
      // Reset selections for new level
      SelectedCpu = SelectedPpu = SelectedApu = null;
      CurrentLevel = save.Level;
      Stars = save.Achievements?.Count ?? 0;
  await LoadLevelFromDbAsync(CurrentLevel);
  StateHasChanged();
    }
    catch { }
  }

  private RenderFragment CoreSlot(string domain, string? enforced, string? selected, Action openPicker) => builder =>
  {
    int seq = 0; bool isLocked = !string.IsNullOrWhiteSpace(enforced);
    builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", $"core-slot{(isLocked?" locked":"")}");
      builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", "slot-title"); builder.AddContent(seq++, domain); builder.CloseElement();
      builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", "slot-body");
  // Card container
  builder.OpenElement(seq++, "div");
  builder.AddAttribute(seq++, "class", "card-wrap");
  // Inline positioning + explicit size to guarantee overlay coverage
  builder.AddAttribute(seq++, "style", "position:relative; width:142px; height:200px; line-height:0; display:inline-block;");
          // Determine which card to render
          CoreCardModel cardModel;
          if (isLocked)
          {
            cardModel = BuildCard(domain, enforced!);
          }
          else if (!string.IsNullOrWhiteSpace(selected))
          {
            cardModel = BuildCard(domain, selected!);
          }
          else
          {
            cardModel = new CoreCardModel{
              Id = "EMPTY",
              ShortName = $"{domain}",
              DisplayName = $"Select a {domain} Core",
              Description = "Click to choose from your owned cores.",
              Rating = 0,
              Performance = 0,
              FooterNote = domain,
              Domain = domain
            };
          }
          var svg = CardSvgRenderer.Render(cardModel, 142, 200);
          builder.AddMarkupContent(seq++, svg);

          if (isLocked)
          {
            builder.OpenElement(seq++, "div");
            builder.AddAttribute(seq++, "class", "card-enforced-overlay");
            // Inline overlay styles to guarantee coverage over the SVG
            builder.AddAttribute(seq++, "style", "position:absolute;inset:0;background:rgba(0,0,0,0.75);display:flex;align-items:center;justify-content:center;z-index:1000;pointer-events:none;");
            builder.AddAttribute(seq++, "title", "Enforced by level");
            builder.AddAttribute(seq++, "aria-hidden", "true");
            builder.OpenElement(seq++, "div");
            builder.AddAttribute(seq++, "class", "enforced-text");
            builder.AddAttribute(seq++, "style", "color:#fff;font-size:0.9rem;font-weight:700;text-shadow:0 1px 2px rgba(0,0,0,0.8);");
            builder.AddContent(seq++, "Enforced");
            builder.CloseElement();
            builder.CloseElement();
          }
          else
          {
            // Make the whole card clickable to open the picker when not locked
            builder.OpenElement(seq++, "button"); builder.AddAttribute(seq++, "type", "button"); builder.AddAttribute(seq++, "class", "card-cover-btn"); builder.AddAttribute(seq++, "aria-label", $"Select {domain} core"); builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, openPicker)); builder.CloseElement();
          }
        builder.CloseElement(); // .card-wrap
      builder.CloseElement(); // .slot-body
    builder.CloseElement(); // .core-slot
  };

  // Mirror the SVG card's rating-to-border palette for consistency
  private static string RatingToBorderColor(int rating)
  {
    return rating switch
    {
      <= 0 => "#6b7280", // slate/neutral
      1 => "#ef4444",    // red 500
      2 => "#f59e0b",    // amber 500
      3 => "#10b981",    // emerald 500
      4 => "#3b82f6",    // blue 500
      _ => "#a855f7"      // purple 500 for 5
    };
  }

  private void OpenCpuPicker() => OpenPicker("CPU");
  private void OpenPpuPicker() => OpenPicker("PPU");
  private void OpenApuPicker() => OpenPicker("APU");
  private void OpenShaderPicker() => OpenPicker("SHADER");

  private void OpenPicker(string domain)
  {
    // Simple cycle picker for now (first non-FMC choice if exists, else FMC)
    switch (domain)
    {
      case "CPU": SelectedCpu = OwnedCpu.FirstOrDefault() ?? "FMC"; break;
      case "PPU": SelectedPpu = OwnedPpu.FirstOrDefault() ?? "FMC"; break;
      case "APU": SelectedApu = OwnedApu.FirstOrDefault() ?? "FMC"; break;
  case "SHADER": SelectedShader = OwnedShader.FirstOrDefault() ?? "PX"; break;
    }
  }

  private async Task OpenCardZoom(string domain, string id)
  {
    ZoomCard = BuildCard(domain, id);
    ModalClosing = false; _zoomInit = false;
    await InvokeAsync(StateHasChanged);
  }

  private async Task CloseZoom()
  {
    if (ZoomCard == null) return;
    ModalClosing = true; await InvokeAsync(StateHasChanged);
    try { await Task.Delay(160); } catch { }
    ZoomCard = null; ModalClosing = false; _zoomInit = false;
  }

  private CoreCardModel BuildCard(string domain, string id)
  {
    // Fetch meta via reflection to enrich the card (best-effort)
    string name = id; string desc = string.Empty; int perf = 0; int rating = 0; string footer = domain;
    try
    {
      // Minimal iNES to allow core instantiation when needed
      var dummy = new byte[16 + 16 * 1024]; dummy[0]=0x4E; dummy[1]=0x45; dummy[2]=0x53; dummy[3]=0x1A; dummy[4]=1; dummy[5]=0; var cart = new Cartridge(dummy); var bus = new Bus(cart);
      switch (domain)
      {
        case "CPU":
          if (CoreRegistry.CpuTypes.TryGetValue(id, out var tCpu))
          {
            var cpu = CoreRegistry.CreateInstance<ICPU>(tCpu, bus);
            if (cpu != null) { name = cpu.CoreName ?? ("CPU_" + id); desc = cpu.Description ?? ""; perf = cpu.Performance; rating = Math.Clamp(cpu.Rating,0,5); footer = cpu.Category ?? domain; }
          }
          break;
        case "PPU":
          if (CoreRegistry.PpuTypes.TryGetValue(id, out var tPpu))
          {
            var ppu = CoreRegistry.CreateInstance<IPPU>(tPpu, bus);
            if (ppu != null) { name = ppu.CoreName ?? ("PPU_" + id); desc = ppu.Description ?? ""; perf = ppu.Performance; rating = Math.Clamp(ppu.Rating,0,5); footer = ppu.Category ?? domain; }
          }
          break;
        case "APU":
          if (CoreRegistry.ApuTypes.TryGetValue(id, out var tApu))
          {
            var apu = CoreRegistry.CreateInstance<IAPU>(tApu, bus);
            if (apu != null) { name = apu.CoreName ?? ("APU_" + id); desc = apu.Description ?? ""; perf = apu.Performance; rating = Math.Clamp(apu.Rating,0,5); footer = apu.Category ?? domain; }
          }
          break;
        case "SHADER":
          try
          {
            var sh = ShaderProvider?.GetById(id);
            if (sh != null)
            {
              name = !string.IsNullOrWhiteSpace(sh.DisplayName) ? sh.DisplayName : (sh.CoreName ?? ("SHADER_" + id));
              desc = sh.Description ?? string.Empty;
              perf = sh.Performance;
              rating = Math.Clamp(sh.Rating, 0, 5);
              footer = "SHADER";
            }
          }
          catch { }
          break;
        default:
          // Unknown domain (e.g., MAPPER/CLOCK/SHADER) — synthesize a reasonable card label
          name = $"{domain}_" + id; desc = string.Empty; perf = 0; rating = 0; footer = domain;
          break;
      }
    }
    catch { }
    return new CoreCardModel{ Id=id, ShortName=$"{domain}_{id}", DisplayName=name, Description=desc, Performance=perf, Rating=rating, FooterNote=footer, Domain=domain };
  }

  private string BuildRel(string path){ if(string.IsNullOrWhiteSpace(path)) return string.Empty; return path.TrimStart('/'); }

  private async Task OnReturn()
  {
    try { await JS.InvokeVoidAsync("eval", @"(function(){try{if(window.music){try{window.music.fadeOut&&window.music.fadeOut(700,true);}catch(e){}} setTimeout(function(){try{window.nesInterop&&window.nesInterop.playTitleMusic&&window.nesInterop.playTitleMusic();}catch(e){}},150);}catch(e){}})();"); } catch { }
    try { await Task.Delay(120); } catch { }
    Nav.NavigateTo(BuildRel("deck-builder?skipHW=1"), false);
  }

  // ===== Level data (continueDb) =====
  private sealed class DbLevel
  {
    public int index { get; set; }
    public string[]? requiredCards { get; set; }
    public int requiredStars { get; set; }
    public string? title { get; set; }
    public string? cardChallenge { get; set; }
  }

  private async Task LoadLevelFromDbAsync(int index)
  {
    try
    {
      // Ask continueDb for this level by primary key (index)
      var json = await JS.InvokeAsync<string>("eval", @$"(async()=>{{ try {{ if(!window.continueDb) return ''; await window.continueDb.open(); const rec = await window.continueDb.get('levels', {index}); return JSON.stringify(rec||null); }} catch(e) {{ return ''; }} }})()");
      DbLevel? level = string.IsNullOrWhiteSpace(json) ? null : JsonSerializer.Deserialize<DbLevel>(json);

      // Defaults if no record
      LevelTitle = level?.title ?? level?.cardChallenge ?? $"Level {index}";
      RequiredStars = level?.requiredStars > 0 ? level!.requiredStars : 5;

  // Reset enforced slots
  EnforcedCpu = EnforcedPpu = EnforcedApu = EnforcedShader = null;

      // Parse requiredCards => fill per-domain enforced ids and build header chips
      var enforced = new List<(string domain, string id, string label, string border)>();
      foreach (var raw in (level?.requiredCards ?? Array.Empty<string>()))
      {
        if (string.IsNullOrWhiteSpace(raw)) continue;
        var parts = raw.Split('_', 2, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length != 2) continue;
        var domain = parts[0].ToUpperInvariant();
        var id = parts[1];
        switch (domain)
        {
          case "CPU": EnforcedCpu = id; break;
          case "PPU": EnforcedPpu = id; break;
          case "APU": EnforcedApu = id; break;
          case "SHADER": EnforcedShader = id; break;
        }
  // Skip displaying CLOCK in the enforced chips header
  if (domain == "CLOCK") continue;
  var card = BuildCard(domain, id);
  enforced.Add((domain, id, $"{domain}_"+id, RatingToBorderColor(Math.Clamp(card.Rating,0,5))));
      }
      // If DB had no enforced cards, retain a sensible default to keep the page functional
      if (enforced.Count == 0)
      {
        EnforcedCpu ??= "FMC"; EnforcedPpu ??= "FMC"; EnforcedApu ??= "FMC";
        var cpu = BuildCard("CPU", EnforcedCpu);
        var ppu = BuildCard("PPU", EnforcedPpu);
        var apu = BuildCard("APU", EnforcedApu);
        enforced.Add(("CPU", EnforcedCpu, "CPU_"+EnforcedCpu, RatingToBorderColor(Math.Clamp(cpu.Rating,0,5))));
        enforced.Add(("PPU", EnforcedPpu, "PPU_"+EnforcedPpu, RatingToBorderColor(Math.Clamp(ppu.Rating,0,5))));
        enforced.Add(("APU", EnforcedApu, "APU_"+EnforcedApu, RatingToBorderColor(Math.Clamp(apu.Rating,0,5))));
      }
      EnforcedCards = enforced.ToArray();
    }
    catch
    {
      // Fallbacks if continueDb not available
      LevelTitle = $"Level {index}";
      RequiredStars = 5;
      EnforcedCpu ??= "FMC"; EnforcedPpu ??= "FMC"; EnforcedApu ??= "FMC";
      var cpu = BuildCard("CPU", EnforcedCpu);
      var ppu = BuildCard("PPU", EnforcedPpu);
      var apu = BuildCard("APU", EnforcedApu);
      EnforcedCards = new[]{
        ("CPU", EnforcedCpu, "CPU_"+EnforcedCpu, RatingToBorderColor(Math.Clamp(cpu.Rating,0,5))),
        ("PPU", EnforcedPpu, "PPU_"+EnforcedPpu, RatingToBorderColor(Math.Clamp(ppu.Rating,0,5))),
        ("APU", EnforcedApu, "APU_"+EnforcedApu, RatingToBorderColor(Math.Clamp(apu.Rating,0,5)))
      };
    }
  }
}
