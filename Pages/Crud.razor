@page "/crud"
@using Microsoft.JSInterop
@using System.Text.Json
@using NesEmulator
@using NesEmulator.RetroAchievements
@using NesEmulator.Shaders
@inject IJSRuntime JS
@inject HttpClient Http
@inject IShaderProvider ShaderProvider
@inject BrokenNes.Services.MetaGamesService MetaGames

<div class="crud-root">
    <h2 class="crud-title">DATABASE EDITOR</h2>
    <div class="crud-toolbar">
        <a class="crud-link" href="./options">Return to Options</a>
    </div>
    <div class="crud-toolbar">
        <button @onclick="ExportJson">Export DB JSON</button>
    <button type="button" @onclick="TriggerImportDialog">Import DB JSON</button>
    <input id="crud-import" type="file" accept="application/json" @onchange="ImportJson" style="display:none" @ref="importInput" />
    <button type="button" class="@GetToggleClass(autoSeedEnabled)" title="Auto-Reload from default-db.json on startup" @onclick="ToggleAutoReload">Auto-Reload</button>
        <div class="crud-columns">
            <button type="button" @onclick="ToggleColumnPicker">Columns</button>
            @if (showColumnPicker)
            {
                <div class="column-picker">
                    <div class="picker-row"><label><input type="checkbox" @bind="ColId" /> ID</label></div>
                    <div class="picker-row"><label><input type="checkbox" checked disabled /> Title</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColCommonName" /> Common Name</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColStatus" /> Status</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColNote" /> Note</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColSystem" /> System</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColBuiltIn" /> Built-in</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColSize" /> Size</label></div>
                    
                </div>
            }
        </div>
    </div>

    <div class='crud-tabs'>
        <button class='@GetTabClass("games")' @onclick='() => SetTab("games")'>Games</button>
        <button class='@GetTabClass("achievements")' @onclick='() => SetTab("achievements")'>Achievements</button>
        <button class='@GetTabClass("cards")' @onclick='() => SetTab("cards")'>Cards</button>
    <button class='@GetTabClass("meta")' @onclick='() => SetTab("meta")'>Meta</button>
        <button class='@GetTabClass("levels")' @onclick='() => SetTab("levels")'>Levels</button>
    </div>

    <div class="crud-pane">
        @if (ActiveTab == "games")
        {
            <h3>Games</h3>
            <div class="games-toolbar">
                <button @onclick="LoadGamesAsync">Refresh</button>
                <span class="small-note">Shows ROMs you've loaded; auto-added to continue DB on load.</span>
            </div>
            @if (isLoading)
            {
                <div class="grid-empty">Loading…</div>
            }
            else if (games is null || games.Count == 0)
            {
                <div class="grid-empty">No records yet.</div>
            }
            else
            {
                var colCount = VisibleColCount;
                <div class="grid-head" style="grid-template-columns: repeat(@colCount, minmax(0,1fr));">
                    @if (cols.Id) { <span>ID</span> }
                    <span>Title</span>
                    @if (cols.CommonName) { <span>Common Name</span> }
                    @if (cols.Status) { <span>Status</span> }
                    @if (cols.Note) { <span>Note</span> }
                    @if (cols.System) { <span>System</span> }
                    @if (cols.BuiltIn) { <span>Built-in</span> }
                    @if (cols.Size) { <span>Size</span> }
                    
                    <span>Actions</span>
                </div>
                @foreach (var g in games)
                {
                    <div class="grid-row" style="grid-template-columns: repeat(@colCount, minmax(0,1fr));">
                        @if (cols.Id) { <span title="@g.id">@g.id</span> }
                        <span>
                            @if (g.isEditing)
                            {
                                <input value="@g.title" @onchange="(e=> g.title = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { @g.title }
                        </span>
                        @if (cols.CommonName)
                        {
                            <span>
                                @if (g.isEditing)
                                {
                                    <input value="@GetCommonName(g)" @onchange="(e=> g.commonName = e.Value?.ToString() ?? string.Empty)" />
                                }
                                else { @GetCommonName(g) }
                            </span>
                        }
                        @if (cols.Status)
                        {
                            <span>
                                @if (g.isEditing)
                                {
                                    <select value="@GetStatus(g)" @onchange="(e=> g.status = e.Value?.ToString() ?? string.Empty)">
                                        @foreach (var s in StatusOptions)
                                        {
                                            <option value="@s">@s</option>
                                        }
                                    </select>
                                }
                                else { @GetStatus(g) }
                            </span>
                        }
                        @if (cols.Note)
                        {
                            <span>
                                @if (g.isEditing)
                                {
                                    <input value="@(g.note ?? string.Empty)" @onchange="(e=> g.note = e.Value?.ToString() ?? string.Empty)" />
                                }
                                else { @(g.note ?? string.Empty) }
                            </span>
                        }
                        @if (cols.System) { <span>@g.system</span> }
                        @if (cols.BuiltIn) { <span>@(g.builtIn ? "Yes" : "No")</span> }
                        @if (cols.Size) { <span>@(g.size?.ToString() ?? "-")</span> }
                        
                        <span>
                            @if (!g.isEditing)
                            {
                                <button @onclick="(()=>BeginEdit(g))">Edit</button>
                                <button @onclick="(()=>DeleteGameAsync(g))">Delete</button>
                            }
                            else
                            {
                                <button @onclick="(()=>SaveGameAsync(g))">Save</button>
                                <button @onclick="(()=>CancelEdit(g))">Cancel</button>
                            }
                        </span>
                    </div>
                }
            }
        }
        else if (ActiveTab == "achievements")
        {
            <h3>Achievements</h3>
            <div class="games-toolbar">
                <button @onclick="LoadAchievementsAsync">Refresh</button>
                <button @onclick="AddAchievementRow">Add new achievement</button>
                <span class="small-note">Link to a Game by its ID (shows Game common name). Requirements are multiple formula lines.</span>
            </div>
            @if (isLoadingAchievements)
            {
                <div class="grid-empty">Loading…</div>
            }
            else if (achievements is null || achievements.Count == 0)
            {
                <div class="grid-empty">No records yet.</div>
            }
            else
            {
                <div class="grid-head" style="grid-template-columns: repeat(5, minmax(0,1fr));">
                    <span>ID</span>
                    <span>Game</span>
                    <span>Title</span>
                    <span>Requirements</span>
                    <span>Controls</span>
                </div>
                @foreach (var a in achievements)
                {
                    <div class="grid-row" style="grid-template-columns: repeat(5, minmax(0,1fr));">
                        <span>
                            @if (a.isEditing)
                            {
                                <input value="@a.id" @onchange="(e=> a.id = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { @a.id }
                        </span>
                        <span>
                            @if (a.isEditing)
                            {
                                <select value="@a.gameId" @onchange="(e=> a.gameId = e.Value?.ToString() ?? string.Empty)">
                                    <option value="">Select Game…</option>
                                    @foreach (var g in GameOptions)
                                    {
                                        <option value="@g.id">@g.label</option>
                                    }
                                </select>
                            }
                            else { @GetGameLabel(a.gameId) }
                        </span>
                        <span>
                            @if (a.isEditing)
                            {
                                <input value="@a.title" @onchange="(e=> a.title = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { @a.title }
                        </span>
                        <span>
                            @if (a.isEditing)
                            {
                                <div style="display:flex;flex-direction:column;gap:.25rem">
                                    @for (var i = 0; i < (a.requirements?.Count ?? 0); i++)
                                    {
                                        var idx = i;
                                        <div style="display:flex;gap:.25rem;align-items:center">
                                            <input style="flex:1" value="@a.requirements![idx]" @onchange="(e=> UpdateRequirement(a, idx, e.Value?.ToString()))" />
                                            <button type="button" @onclick="(()=>RemoveRequirement(a, idx))">✕</button>
                                        </div>
                                    }
                                    <button type="button" @onclick="(()=>AddRequirement(a))">+ Add requirement</button>
                                </div>
                            }
                            else
                            {
                                @if (a.requirements == null || a.requirements.Count == 0)
                                {
                                    <span>None</span>
                                }
                                else
                                {
                                    <span>@string.Join(" • ", a.requirements)</span>
                                }
                            }
                        </span>
                        <span>
                            @if (!a.isEditing)
                            {
                                <button @onclick="(()=>BeginEditAchievement(a))">Edit</button>
                                <button @onclick="(()=>DeleteAchievementAsync(a))">Delete</button>
                            }
                            else
                            {
                                <button @onclick="(()=>SaveAchievementAsync(a))">Save</button>
                                <button @onclick="(()=>CancelEditAchievement(a))">Cancel</button>
                            }
                        </span>
                    </div>
                }
            }
        }
        else if (ActiveTab == "cards")
        {
            <h3>Cards</h3>
            <div class="games-toolbar">
                <button @onclick="RefreshCardsAsync">Refresh Cards</button>
                <span class="small-note">Scans CPU/PPU/APU/Clock/Shaders via reflection. Type/Note are persisted.</span>
            </div>
            @if (isLoadingCards)
            {
                <div class="grid-empty">Loading…</div>
            }
            else if (cards is null || cards.Count == 0)
            {
                <div class="grid-empty">No records yet.</div>
            }
            else
            {
                <div class="grid-head" style="grid-template-columns: repeat(10, minmax(0,1fr));">
                    <span>ID</span>
                    <span>Type</span>
                    <span>Note</span>
                    <span>Domain</span>
                    <span>Core Id</span>
                    <span>Name</span>
                    <span>Category</span>
                    <span>Perf</span>
                    <span>Rating</span>
                    <span>Actions</span>
                </div>
                @foreach (var c in cards)
                {
                    <div class="grid-row" style="grid-template-columns: repeat(10, minmax(0,1fr));">
                        <span title="@c.id">@c.id</span>
                        <span>
                            @if (c.isEditing)
                            {
                                <select value="@c.type" @onchange="(e=> c.type = e.Value?.ToString() ?? DefaultCardType)">
                                    @foreach (var t in CardTypeOptions)
                                    {
                                        <option value="@t">@t</option>
                                    }
                                </select>
                            }
                            else { @c.type }
                        </span>
                        <span>
                            @if (c.isEditing)
                            {
                                <input value="@(c.note ?? string.Empty)" @onchange="(e=> c.note = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { @(c.note ?? string.Empty) }
                        </span>
                        <span>@c.domain</span>
                        <span>@c.coreId</span>
                        <span>@c.name</span>
                        <span>@(string.IsNullOrWhiteSpace(c.category) ? "-" : c.category)</span>
                        <span>@c.performance</span>
                        <span>@c.rating</span>
                        <span>
                            @if (!c.isEditing)
                            {
                                <button @onclick="(()=>BeginEditCard(c))">Edit</button>
                                <button @onclick="(()=>DeleteCardAsync(c))">Delete</button>
                            }
                            else
                            {
                                <button @onclick="(()=>SaveCardAsync(c))">Save</button>
                                <button @onclick="(()=>CancelEditCard(c))">Cancel</button>
                            }
                        </span>
                    </div>
                }
            }
        }
    else if (ActiveTab == "meta")
        {
            <h3>Meta Achievements</h3>
            <div class="games-toolbar">
                <input placeholder="Filter by game title (exact match)" value="@metaFilterTitle" @onchange="OnMetaFilterChanged" />
                <button @onclick="LoadMetaAsync">Refresh</button>
        <button @onclick="TestAllMetaFormulasAsync">Test All Formulas</button>
                <span class="small-note">Read-only view from models/meta_games.json</span>
            </div>
            @if (isLoadingMeta)
            {
                <div class="grid-empty">Loading…</div>
            }
            else if (metaRows is null || metaRows.Count == 0)
            {
                <div class="grid-empty">No data.</div>
            }
            else
            {
                <div class="grid-head" style="grid-template-columns: 1fr 1fr 2fr;">
                    <span>Game</span>
                    <span>Achievement</span>
                    <span>Formula</span>
                </div>
                @foreach (var r in metaRows)
                {
                    <div class="grid-row" style="grid-template-columns: 1fr 1fr 2fr;">
                        <span>@r.game</span>
                        <span style="@(r.TestSucceeded ? "color:var(--success,green);font-weight:600;" : string.Empty)">@r.description</span>
                        <span style="white-space: pre-wrap; word-break: break-word; overflow-wrap: anywhere; font-family: var(--monospace, ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace)">@r.formula</span>
                    </div>
                }
            }
        }
        else if (ActiveTab == "levels")
        {
            <h3>Levels</h3>
            <div class="games-toolbar">
                <button @onclick="LoadLevelsAsync">Refresh</button>
                <button @onclick="AddLevelRow">Add new level</button>
                <span class="small-note">Manual entry. Index must be unique.</span>
            </div>
            @if (isLoadingLevels)
            {
                <div class="grid-empty">Loading…</div>
            }
            else if (levels is null || levels.Count == 0)
            {
                <div class="grid-empty">No records yet.</div>
            }
            else
            {
                <div class="grid-head" style="grid-template-columns: repeat(5, minmax(0,1fr));">
                    <span>Index</span>
                    <span>Required Cards</span>
                    <span>Required Stars</span>
                    <span>Card Challenge</span>
                    <span>Actions</span>
                </div>
                @foreach (var l in levels)
                {
                    <div class="grid-row" style="grid-template-columns: repeat(5, minmax(0,1fr));">
                        <span>
                            @if (l.isEditing)
                            {
                                <input type="number" value="@l.index" @onchange="(e=> l.index = ParseInt(e.Value))" />
                            }
                            else { @l.index }
                        </span>
                        <span>
                            @if (l.isEditing)
                            {
                                EnsureCardSlots(l);
                                <div style="display:flex;gap:.25rem;flex-wrap:wrap">
                                    @for (var i = 0; i < 5; i++)
                                    {
                                        var localI = i;
                                        <select value="@GetCardSlotValue(l, localI)" @onchange="(e=> SetCardSlotValue(l, localI, e.Value?.ToString()))" style="min-width:9rem">
                                            <option value="">None</option>
                                            @foreach (var opt in CardOptions)
                                            {
                                                <option value="@opt.id">@opt.label</option>
                                            }
                                        </select>
                                    }
                                </div>
                            }
                            else { @FormatRequiredCards(l) }
                        </span>
                        <span>
                            @if (l.isEditing)
                            {
                                <input type="number" value="@l.requiredStars" @onchange="(e=> l.requiredStars = ParseInt(e.Value))" />
                            }
                            else { @l.requiredStars }
                        </span>
                        <span>
                            @if (l.isEditing)
                            {
                                <input value="@(l.cardChallenge ?? string.Empty)" @onchange="(e=> l.cardChallenge = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { @(string.IsNullOrWhiteSpace(l.cardChallenge) ? "-" : l.cardChallenge) }
                        </span>
                        <span>
                            @if (!l.isEditing)
                            {
                                <button @onclick="(()=>BeginEditLevel(l))">Edit</button>
                                <button @onclick="(()=>DeleteLevelAsync(l))">Delete</button>
                            }
                            else
                            {
                                <button @onclick="(()=>SaveLevelAsync(l))">Save</button>
                                <button @onclick="(()=>CancelEditLevel(l))">Cancel</button>
                            }
                        </span>
                    </div>
                }
            }
        }
    </div>
</div>

@code {
    private string ActiveTab { get; set; } = "games";
    private bool isLoading = false;
    private bool isLoadingCards = false;
    private bool isLoadingLevels = false;
    private bool isLoadingAchievements = false;
    private bool isLoadingMeta = false;
    private List<GameRow> games = new();
    private List<CardRow> cards = new();
    private List<LevelRow> levels = new();
    private List<AchievementRow> achievements = new();
    private List<MetaRow> metaRows = new();
    private List<CardOption> CardOptions { get; set; } = new();
    private Dictionary<string, string> CardLabelById { get; set; } = new(StringComparer.OrdinalIgnoreCase);
    private bool autoSeedEnabled = true;
    private bool showColumnPicker = false;
    private ColumnVisibility cols = new() { Id = false, CommonName = true, Status = true, Note = false, System = false, BuiltIn = true, Size = false };
    private ElementReference importInput;

    // Title is always visible; others are conditional
    private int VisibleColCount => 1 // Title
        + (cols.Id ? 1 : 0)
        + (cols.CommonName ? 1 : 0)
        + (cols.Status ? 1 : 0)
        + (cols.Note ? 1 : 0)
        + (cols.System ? 1 : 0)
        + (cols.BuiltIn ? 1 : 0)
        + (cols.Size ? 1 : 0)
        + 1; // Actions
    private bool AutoSeedEnabled
    {
        get => autoSeedEnabled;
        set
        {
            autoSeedEnabled = value;
            try { _ = JS.InvokeVoidAsync("continueDb.setAutoSeedEnabled", value); } catch { }
        }
    }

    private void SetTab(string id)
    {
        ActiveTab = id;
        // Lazy-load when switching tabs
    if (id == "games") _ = LoadGamesAsync();
    else if (id == "cards") _ = RefreshCardsAsync();
    else if (id == "levels") _ = LoadLevelsAsync();
    else if (id == "achievements") _ = LoadAchievementsAsync();
    else if (id == "meta") _ = LoadMetaAsync();
    }

    private string GetTabClass(string id) => ActiveTab == id ? "active" : string.Empty;
    private string GetToggleClass(bool on) => on ? "active" : string.Empty;

    private async Task ExportJson()
    {
        try { await JS.InvokeVoidAsync("continueDb.exportAllToDownload"); } catch { }
    }

    private async Task ImportJson(ChangeEventArgs e)
    {
        try { await JS.InvokeVoidAsync("continueDb.importFromFileInput"); } catch { }
        await LoadGamesAsync();
    if (ActiveTab == "achievements") await LoadAchievementsAsync();
    if (ActiveTab == "levels") await LoadLevelsAsync();
    }

    private async Task TriggerImportDialog()
    {
        try { await JS.InvokeVoidAsync("eval", "document.getElementById('crud-import')?.click()"); } catch { }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Initialize toggle from JS
            try { autoSeedEnabled = await JS.InvokeAsync<bool>("continueDb.getAutoSeedEnabled"); } catch { autoSeedEnabled = true; }
            // Load column prefs
            try
            {
                var json = await JS.InvokeAsync<string>("localStorage.getItem", "crud:gamesCols");
                if (!string.IsNullOrWhiteSpace(json))
                {
                    var loaded = JsonSerializer.Deserialize<ColumnVisibility>(json);
                    if (loaded != null)
                    {
                        // Merge with defaults so new fields get sensible defaults
                        cols = new ColumnVisibility
                        {
                            Id = loaded.Id,
                            CommonName = loaded.CommonName == default ? true : loaded.CommonName,
                            Status = loaded.Status == default ? true : loaded.Status,
                            Note = loaded.Note,
                            System = loaded.System,
                            BuiltIn = loaded.BuiltIn,
                            Size = loaded.Size
                        };
                    }
                }
            }
            catch { }
            await LoadGamesAsync();
        }
    }

    private async Task LoadGamesAsync()
    {
        if (ActiveTab != "games") return;
        isLoading = true; StateHasChanged();
        try
        {
            var json = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('games'); arr.sort((a,b)=> (a.title||'').localeCompare(b.title||'')); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var list = string.IsNullOrWhiteSpace(json) ? new List<GameRow>() : JsonSerializer.Deserialize<List<GameRow>>(json) ?? new List<GameRow>();
            foreach (var g in list) { if (string.IsNullOrWhiteSpace(g.status)) g.status = "Nothing"; if (g.note == null) g.note = string.Empty; }
            games = list;
        }
        catch { games = new(); }
        finally { isLoading = false; StateHasChanged(); }
    }

    private void ToggleColumnPicker() => showColumnPicker = !showColumnPicker;

    private void ToggleAutoReload()
    {
        AutoSeedEnabled = !AutoSeedEnabled;
        StateHasChanged();
    }

    private Task SaveColumnsAsync()
    {
        try { return JS.InvokeVoidAsync("localStorage.setItem", "crud:gamesCols", JsonSerializer.Serialize(cols)).AsTask(); }
        catch { return Task.CompletedTask; }
    }

    private static string GetCommonName(GameRow g)
    {
        if (!string.IsNullOrWhiteSpace(g.commonName)) return g.commonName!;
        if (!string.IsNullOrWhiteSpace(g.title)) return g.title!;
        return g.romKey ?? string.Empty;
    }

    private static string GetStatus(GameRow g)
    {
        return string.IsNullOrWhiteSpace(g.status) ? "Nothing" : g.status!;
    }

    private static readonly string[] StatusOptions = new[] { "Nothing", "Broken", "Jank", "Works" };

    private void BeginEdit(GameRow g)
    {
        g.isEditing = true; StateHasChanged();
    }

    private void CancelEdit(GameRow g)
    {
        _ = LoadGamesAsync();
    }

    private async Task SaveGameAsync(GameRow g)
    {
        try
        {
            var rec = new {
                id = g.id,
                title = g.title ?? string.Empty,
                commonName = g.commonName ?? string.Empty,
                status = string.IsNullOrWhiteSpace(g.status) ? "Nothing" : g.status,
                note = g.note ?? string.Empty,
                system = g.system ?? "nes",
                romKey = g.romKey,
                headerSignature = g.headerSignature,
                builtIn = g.builtIn,
                size = g.size,
                createdAt = g.createdAt
            };
            var recJson = JsonSerializer.Serialize(rec);
            var safe = recJson.Replace("\\", "\\\\").Replace("'", "\\'").Replace("\n","\\n").Replace("\r", "");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); const rec = JSON.parse('{safe}'); await window.continueDb.put('games', rec); }} catch(e) {{ console.warn('save failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadGamesAsync();
    }

    private async Task DeleteGameAsync(GameRow g)
    {
        try
        {
            var idSafe = (g.id ?? string.Empty).Replace("'", "\'");
            var confirm = await JS.InvokeAsync<bool>("eval", $"confirm('Delete game ' + {JsonSerializer.Serialize(GetCommonName(g))} + ' (ID: ' + {JsonSerializer.Serialize(g.id ?? string.Empty)} + ')? This cannot be undone.')");
            if (!confirm) return;
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); await window.continueDb.delete('games', '{idSafe}'); }} catch(e) {{ console.warn('delete game failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadGamesAsync();
    }

    // ===== ACHIEVEMENTS TAB =====
    private List<GameOption> GameOptions { get; set; } = new();

    private async Task LoadAchievementsAsync()
    {
        if (ActiveTab != "achievements") return;
        isLoadingAchievements = true; StateHasChanged();
        try
        {
            // build game options from games store (ID + label is common name or title)
            var gamesJson = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('games'); arr.sort((a,b)=> (a.title||'').localeCompare(b.title||'')); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var gameList = string.IsNullOrWhiteSpace(gamesJson) ? new List<GameRow>() : JsonSerializer.Deserialize<List<GameRow>>(gamesJson) ?? new List<GameRow>();
            GameOptions = gameList
                .Where(g => !string.IsNullOrWhiteSpace(g.id))
                .Select(g => new GameOption { id = g.id!, label = GetCommonName(g) })
                .OrderBy(g => g.label, StringComparer.OrdinalIgnoreCase)
                .ToList();

            var json = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('achievements'); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var list = string.IsNullOrWhiteSpace(json) ? new List<AchievementRow>() : JsonSerializer.Deserialize<List<AchievementRow>>(json) ?? new List<AchievementRow>();
            foreach (var a in list)
            {
                a.requirements ??= new List<string>();
                a.id ??= string.Empty;
                a.title ??= string.Empty;
                a.gameId ??= string.Empty;
            }
            achievements = list.OrderBy(a => a.id, StringComparer.OrdinalIgnoreCase).ToList();
        }
        catch { achievements = new(); }
        finally { isLoadingAchievements = false; StateHasChanged(); }
    }

    private void AddAchievementRow()
    {
        achievements ??= new List<AchievementRow>();
        var nextId = SuggestAchievementId();
        achievements.Add(new AchievementRow
        {
            id = nextId,
            gameId = GameOptions.FirstOrDefault()?.id ?? string.Empty,
            title = string.Empty,
            requirements = new List<string>(),
            isEditing = true
        });
        StateHasChanged();
    }

    private string SuggestAchievementId()
    {
        var baseId = "ach_";
        var i = 1;
        var set = new HashSet<string>(achievements.Select(a => a.id ?? string.Empty), StringComparer.OrdinalIgnoreCase);
        while (set.Contains(baseId + i)) i++;
        return baseId + i;
    }

    private void BeginEditAchievement(AchievementRow a)
    {
        a.isEditing = true; StateHasChanged();
    }

    private async Task CancelEditAchievement(AchievementRow a)
    {
        await LoadAchievementsAsync();
    }

    private async Task SaveAchievementAsync(AchievementRow a)
    {
        try
        {
            var rec = new {
                id = a.id ?? string.Empty,
                gameId = a.gameId ?? string.Empty,
                title = a.title ?? string.Empty,
                requirements = (a.requirements ?? new List<string>()).Where(s => !string.IsNullOrWhiteSpace(s)).ToArray()
            };
            var recJson = JsonSerializer.Serialize(rec);
            var safe = recJson.Replace("\\", "\\\\").Replace("'", "\\'").Replace("\n","\\n").Replace("\r", "");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); const rec = JSON.parse('{safe}'); await window.continueDb.put('achievements', rec); }} catch(e) {{ console.warn('save achievement failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadAchievementsAsync();
    }

    private async Task DeleteAchievementAsync(AchievementRow a)
    {
        try
        {
            var label = a.id ?? string.Empty;
            var confirm = await JS.InvokeAsync<bool>("eval", $"confirm('Delete achievement ' + {JsonSerializer.Serialize(label)} + '? This cannot be undone.')");
            if (!confirm) return;
            var idSafe = label.Replace("'", "\'");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); await window.continueDb.delete('achievements', '{idSafe}'); }} catch(e) {{ console.warn('delete achievement failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadAchievementsAsync();
    }

    private void AddRequirement(AchievementRow a)
    {
        a.requirements ??= new List<string>();
        a.requirements.Add(string.Empty);
        StateHasChanged();
    }

    private void RemoveRequirement(AchievementRow a, int index)
    {
        try { a.requirements?.RemoveAt(index); } catch { }
        StateHasChanged();
    }

    private void UpdateRequirement(AchievementRow a, int index, string? value)
    {
        try { if (a.requirements != null && index >= 0 && index < a.requirements.Count) a.requirements[index] = value ?? string.Empty; } catch { }
    }

    private string GetGameLabel(string? gameId)
    {
        if (string.IsNullOrWhiteSpace(gameId)) return "-";
        var opt = GameOptions.FirstOrDefault(g => string.Equals(g.id, gameId, StringComparison.OrdinalIgnoreCase));
        return opt?.label ?? gameId;
    }

    // ===== LEVELS TAB =====
    private async Task LoadLevelsAsync()
    {
        if (ActiveTab != "levels") return;
        isLoadingLevels = true; StateHasChanged();
        try
        {
            // Build card options once for dropdowns
            if (CardOptions.Count == 0)
            {
                var meta = await ScanAllCardMetaAsync();
                CardOptions = meta
                    .OrderBy(m => m.domain)
                    .ThenBy(m => m.name, StringComparer.OrdinalIgnoreCase)
                    .Select(m => {
                        var id = m.domain + "_" + m.coreId; // short form label
                        return new CardOption { id = id, label = id };
                    })
                    .ToList();
                CardLabelById = CardOptions.GroupBy(o => o.id).ToDictionary(g => g.Key, g => g.First().label, StringComparer.OrdinalIgnoreCase);
            }

            var json = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('levels'); arr.sort((a,b)=> (a.index||0) - (b.index||0)); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var list = string.IsNullOrWhiteSpace(json) ? new List<LevelRow>() : JsonSerializer.Deserialize<List<LevelRow>>(json) ?? new List<LevelRow>();
            foreach (var l in list)
            {
                l.requiredCards ??= new List<string>();
                if (l.requiredStars < 0) l.requiredStars = 0;
            }
            levels = list;
        }
        catch { levels = new(); }
        finally { isLoadingLevels = false; StateHasChanged(); }
    }

    private void AddLevelRow()
    {
        var nextIndex = 1;
        try { if (levels != null && levels.Count > 0) nextIndex = Math.Max(1, levels.Max(l => l.index)) + 1; } catch { nextIndex = 1; }
        levels ??= new List<LevelRow>();
        levels.Add(new LevelRow
        {
            index = nextIndex,
            requiredCards = new List<string>(),
            requiredStars = 0,
            cardChallenge = string.Empty,
            isEditing = true
        });
        StateHasChanged();
    }

    private void BeginEditLevel(LevelRow l)
    {
        l.isEditing = true; StateHasChanged();
    }

    private async Task CancelEditLevel(LevelRow l)
    {
        await LoadLevelsAsync();
    }

    private async Task SaveLevelAsync(LevelRow l)
    {
        try
        {
            if (l.index < 1) l.index = 1;
            var rec = new {
                index = l.index,
                requiredCards = (l.requiredCards ?? new List<string>()).Where(s => !string.IsNullOrWhiteSpace(s)).Take(5).ToArray(),
                requiredStars = Math.Max(0, l.requiredStars),
                cardChallenge = l.cardChallenge ?? string.Empty
            };
            var recJson = JsonSerializer.Serialize(rec);
            var safe = recJson.Replace("\\", "\\\\").Replace("'", "\\'").Replace("\n","\\n").Replace("\r", "");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); const rec = JSON.parse('{safe}'); await window.continueDb.put('levels', rec); }} catch(e) {{ console.warn('save level failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadLevelsAsync();
    }

    private async Task DeleteLevelAsync(LevelRow l)
    {
        try
        {
            var confirm = await JS.InvokeAsync<bool>("eval", $"confirm('Delete level #' + {l.index} + '? This cannot be undone.')");
            if (!confirm) return;
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); await window.continueDb.delete('levels', {l.index}); }} catch(e) {{ console.warn('delete level failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadLevelsAsync();
    }

    private static int ParseInt(object? v)
    {
        try { return Convert.ToInt32(v); } catch { return 0; }
    }

    private sealed class LevelRow
    {
        public int index { get; set; }
        public List<string>? requiredCards { get; set; }
        public int requiredStars { get; set; }
        public string? cardChallenge { get; set; }
        public bool isEditing { get; set; }
    }

    private sealed class CardOption { public string id { get; set; } = string.Empty; public string label { get; set; } = string.Empty; }

    private static void EnsureCardSlots(LevelRow l)
    {
        l.requiredCards ??= new List<string>();
        while (l.requiredCards.Count < 5) l.requiredCards.Add(string.Empty);
        if (l.requiredCards.Count > 5) l.requiredCards = l.requiredCards.Take(5).ToList();
    }

    private string GetCardSlotValue(LevelRow l, int i)
    {
        try { return l.requiredCards![i] ?? string.Empty; } catch { return string.Empty; }
    }

    private void SetCardSlotValue(LevelRow l, int i, string? value)
    {
        EnsureCardSlots(l);
        l.requiredCards![i] = value ?? string.Empty;
    }

    private string FormatRequiredCards(LevelRow l)
    {
        if (l.requiredCards == null || l.requiredCards.Count == 0) return "0";
        var labels = l.requiredCards
            .Where(id => !string.IsNullOrWhiteSpace(id))
            .Select(id => CardLabelById.TryGetValue(id, out var lbl) ? lbl : id)
            .ToList();
        if (labels.Count == 0) return "0";
        return string.Join(", ", labels);
    }

    private class GameRow
    {
        public string? id { get; set; }
        public string? title { get; set; }
    public string? commonName { get; set; }
    public string? status { get; set; }
    public string? note { get; set; }
    public string? system { get; set; }
    public string? romKey { get; set; }
    public string? headerSignature { get; set; }
    public bool builtIn { get; set; }
    public int? size { get; set; }
    public string? createdAt { get; set; }
    public bool isEditing { get; set; }
    }

    // ===== CARDS TAB =====
    private const string DefaultCardType = "Last";
    private static readonly string[] CardTypeOptions = new[] { "Reserved", "Random", DefaultCardType };

    private async Task RefreshCardsAsync()
    {
        if (ActiveTab != "cards") return;
        isLoadingCards = true; StateHasChanged();
        try
        {
            // 1) Scan reflection for all available cores/cards
            var meta = await ScanAllCardMetaAsync();

            // 2) Load persisted selections (type/note) from continueDb
            var json = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('cards'); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var persisted = string.IsNullOrWhiteSpace(json) ? new List<CardPersisted>() : JsonSerializer.Deserialize<List<CardPersisted>>(json) ?? new List<CardPersisted>();
            var map = new Dictionary<string, CardPersisted>(StringComparer.OrdinalIgnoreCase);
            foreach (var p in persisted) if (!string.IsNullOrWhiteSpace(p.id)) map[p.id!] = p;

            // 3) Build rows, join on id
            var rows = new List<CardRow>(meta.Count);
            foreach (var m in meta.OrderBy(m => m.domain).ThenBy(m => m.name, StringComparer.OrdinalIgnoreCase))
            {
                var id = m.domain + "_" + m.coreId; // composite
                map.TryGetValue(id, out var p);
                rows.Add(new CardRow
                {
                    id = id,
                    domain = m.domain,
                    coreId = m.coreId,
                    name = m.name,
                    category = m.category,
                    performance = m.performance,
                    rating = m.rating,
                    type = string.IsNullOrWhiteSpace(p?.type) ? "Last" : p!.type!,
                    note = p?.note ?? string.Empty,
                    isEditing = false
                });
            }
            cards = rows;
        }
        catch { cards = new(); }
        finally { isLoadingCards = false; StateHasChanged(); }
    }

    private void BeginEditCard(CardRow c)
    {
        c.isEditing = true; StateHasChanged();
    }

    private Task CancelEditCard(CardRow c)
    {
        return RefreshCardsAsync();
    }

    private async Task SaveCardAsync(CardRow c)
    {
        try
        {
            var rec = new { id = c.id, type = string.IsNullOrWhiteSpace(c.type) ? "Last" : c.type, note = c.note ?? string.Empty };
            var recJson = JsonSerializer.Serialize(rec);
            var safe = recJson.Replace("\\", "\\\\").Replace("'", "\\'").Replace("\n","\\n").Replace("\r", "");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); const rec = JSON.parse('{safe}'); await window.continueDb.put('cards', rec); }} catch(e) {{ console.warn('save card failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await RefreshCardsAsync();
    }

    private async Task DeleteCardAsync(CardRow c)
    {
        try
        {
            var label = c.id;
            var confirm = await JS.InvokeAsync<bool>("eval", $"confirm('Delete card ' + {JsonSerializer.Serialize(label)} + '? This cannot be undone.')");
            if (!confirm) return;
            var idSafe = (label ?? string.Empty).Replace("'", "\'");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); await window.continueDb.delete('cards', '{idSafe}'); }} catch(e) {{ console.warn('delete card failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await RefreshCardsAsync();
    }

    private sealed class CardRow
    {
        public string id { get; set; } = string.Empty; // composite: DOMAIN_ID
        public string domain { get; set; } = string.Empty; // CPU/PPU/APU/CLOCK/SHADER
        public string coreId { get; set; } = string.Empty; // short id within domain
        public string name { get; set; } = string.Empty;   // display name (from reflection)
        public string category { get; set; } = string.Empty;
        public int performance { get; set; }
        public int rating { get; set; }
        public string type { get; set; } = "Last"; // Reserved | Random | Last
        public string? note { get; set; }
        public bool isEditing { get; set; }
    }

    private sealed class CardPersisted
    {
        public string? id { get; set; }
        public string? type { get; set; }
        public string? note { get; set; }
    }

    private sealed class CardMeta
    {
        public string domain { get; set; } = string.Empty; // CPU/PPU/APU/CLOCK/SHADER
        public string coreId { get; set; } = string.Empty;
        public string name { get; set; } = string.Empty;
        public string category { get; set; } = string.Empty;
        public int performance { get; set; }
        public int rating { get; set; }
    }

    private sealed class AchievementRow
    {
        public string? id { get; set; }
        public string? gameId { get; set; }
        public string? title { get; set; }
        public List<string>? requirements { get; set; }
        public bool isEditing { get; set; }
    }

    private sealed class MetaRow
    {
        public string game { get; set; } = string.Empty;
        public string description { get; set; } = string.Empty;
        public string formula { get; set; } = string.Empty;
    public bool TestSucceeded { get; set; } = false;
    }

    private sealed class GameOption { public string id { get; set; } = string.Empty; public string label { get; set; } = string.Empty; }

    private static T? SafeGet<T>(Func<T> getter)
    {
        try { return getter(); } catch { return default; }
    }

    private static T? SafeGetStruct<T>(Func<T> getter) where T : struct
    {
        try { return getter(); } catch { return null; }
    }

    private async Task<List<CardMeta>> ScanAllCardMetaAsync()
    {
        var list = new List<CardMeta>();
        // Build a tiny, valid iNES ROM (NROM-128: 1x16KB PRG, 0 CHR) so cores can instantiate
        try
        {
            var dummy = new byte[16 + 16 * 1024];
            dummy[0] = 0x4E; dummy[1] = 0x45; dummy[2] = 0x53; dummy[3] = 0x1A; // NES\x1A
            dummy[4] = 1; // PRG banks
            dummy[5] = 0; // CHR banks
            dummy[6] = 0; dummy[7] = 0; // flags
            var cart = new Cartridge(dummy);
            var bus = new Bus(cart);

            // CPU
            try
            {
                foreach (var kv in CoreRegistry.CreateInstances<ICPU>(bus, "CPU_"))
                {
                    list.Add(new CardMeta
                    {
                        domain = "CPU",
                        coreId = kv.Key,
                        name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
                        category = SafeGet(() => kv.Value.Category) ?? "",
                        performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
                        rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
                    });
                }
            }
            catch { }

            // PPU
            try
            {
                foreach (var kv in CoreRegistry.CreateInstances<IPPU>(bus, "PPU_"))
                {
                    list.Add(new CardMeta
                    {
                        domain = "PPU",
                        coreId = kv.Key,
                        name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
                        category = SafeGet(() => kv.Value.Category) ?? "",
                        performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
                        rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
                    });
                }
            }
            catch { }

            // APU
            try
            {
                foreach (var kv in CoreRegistry.CreateInstances<IAPU>(bus, "APU_"))
                {
                    list.Add(new CardMeta
                    {
                        domain = "APU",
                        coreId = kv.Key,
                        name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
                        category = SafeGet(() => kv.Value.Category) ?? "",
                        performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
                        rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
                    });
                }
            }
            catch { }

            // CLOCK
            try
            {
                foreach (var id in ClockRegistry.Ids)
                {
                    try
                    {
                        var clk = ClockRegistry.Create(id);
                        if (clk != null)
                        {
                            list.Add(new CardMeta
                            {
                                domain = "CLOCK",
                                coreId = id,
                                name = clk.DisplayName,
                                category = SafeGet(() => clk.Category) ?? "",
                                performance = SafeGetStruct(() => clk.Performance) ?? 0,
                                rating = SafeGetStruct(() => clk.Rating) ?? 0,
                            });
                        }
                    }
                    catch { }
                }
            }
            catch { }

            // SHADERS
            try
            {
                var allShaders = ShaderProvider?.All ?? Array.Empty<IShader>();
                foreach (var s in allShaders)
                {
                    string? cat = null;
                    try { cat = s.Defines != null && s.Defines.TryGetValue("Category", out var c) ? c : null; } catch { }
                    list.Add(new CardMeta
                    {
                        domain = "SHADER",
                        coreId = s.Id,
                        name = SafeGet(() => s.CoreName) ?? s.DisplayName,
                        category = cat ?? "",
                        performance = SafeGetStruct(() => s.Performance) ?? 0,
                        rating = SafeGetStruct(() => s.Rating) ?? 0,
                    });
                }
            }
            catch { }
        }
        catch { }

        await Task.Yield();
        return list;
    }

    // === META tab helpers ===
    private string metaFilterTitle = string.Empty;
    private async Task LoadMetaAsync()
    {
        if (ActiveTab != "meta") return;
        isLoadingMeta = true; StateHasChanged();
        try
        {
            IReadOnlyList<BrokenNes.Services.MetaGamesService.AchievementWithGame> list;
            if (string.IsNullOrWhiteSpace(metaFilterTitle))
            {
                list = await MetaGames.GetAllAchievementsFlatAsync();
            }
            else
            {
                var items = await MetaGames.GetAchievementsByTitleAsync(metaFilterTitle);
                list = items.Select(a => new BrokenNes.Services.MetaGamesService.AchievementWithGame(metaFilterTitle, a.Description, a.Formula)).ToList();
            }
            metaRows = list
                .Select(x => new MetaRow { game = x.GameTitle, description = x.Description, formula = x.Formula })
                .OrderBy(r => r.game, StringComparer.OrdinalIgnoreCase)
                .ThenBy(r => r.description, StringComparer.OrdinalIgnoreCase)
                .ToList();
        }
        catch { metaRows = new(); }
        finally { isLoadingMeta = false; StateHasChanged(); }
    }

    private async Task OnMetaFilterChanged(ChangeEventArgs e)
    {
        metaFilterTitle = e.Value?.ToString() ?? string.Empty;
        await LoadMetaAsync();
    }

    private async Task TestAllMetaFormulasAsync()
    {
        try
        {
            var prevDebug = Parser.DebugLogging;
            Parser.DebugLogging = true;
            // Ensure we have data loaded
            if (metaRows is null || metaRows.Count == 0)
            {
                await LoadMetaAsync();
            }
            if (metaRows is null || metaRows.Count == 0)
            {
                try { await JS.InvokeVoidAsync("eval", "alert('No meta formulas to test.')"); } catch { }
                return;
            }

            // Load test ROM bytes (from wwwroot/test.nes)
            byte[] romBytes = Array.Empty<byte>();
            try { romBytes = await Http.GetByteArrayAsync("test.nes"); }
            catch { romBytes = Array.Empty<byte>(); }
            if (romBytes == null || romBytes.Length == 0)
            {
                var msg = "test.nes not found or empty in wwwroot. Place a valid ROM at wwwroot/test.nes.";
                try { await JS.InvokeVoidAsync("console.error", msg); } catch { }
                try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize(msg)})"); } catch { }
                Parser.DebugLogging = prevDebug;
                return;
            }

            // Create a dedicated NES instance and load the test ROM once
            var nes = new NES();
            try { nes.RomName = "test.nes"; nes.LoadROM(romBytes); }
            catch (Exception ex)
            {
                var msg = $"Failed to load test.nes: {ex.Message}";
                try { await JS.InvokeVoidAsync("console.error", msg); } catch { }
                try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize(msg)})"); } catch { }
                Parser.DebugLogging = prevDebug;
                return;
            }

            int parsed = 0;
            int tested = 0;
            // Reset success markers
            foreach (var rr in metaRows) rr.TestSucceeded = false;
            StateHasChanged();
            foreach (var r in metaRows)
            {
                var formula = r.formula ?? string.Empty;
                if (string.IsNullOrWhiteSpace(formula)) continue;
                // Split into individual lines to mimic RA multi-line requirements
                var lines = formula.Replace("\r\n", "\n").Replace("\r", "\n").Split('\n');
                var allLinesOk = true;
                for (int li = 0; li < lines.Length; li++)
                {
                    var line = lines[li]?.Trim();
                    if (string.IsNullOrWhiteSpace(line)) continue;
                    // 1) Parse
                    try { _ = Parser.ParseConditions(line); parsed++; }
                    catch (Exception ex)
                    {
                        var msg = $"Meta formula parse failed: Game='{r.game}', Achievement='{r.description}', Line='{line}'. Error: {ex.Message}";
                        try { await JS.InvokeVoidAsync("console.error", msg); } catch { }
                        try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize("Parsing failed:\n" + msg)})"); } catch { }
                        Parser.DebugLogging = prevDebug; return;
                    }

                    // Ensure a clean baseline by reloading the ROM for this line
                    try { nes.LoadROM(romBytes); }
                    catch { /* continue; NES was already loaded earlier */ }

                    // 2) Build a plan and run a closed-loop unlock test on a fresh engine
                    AchievementsTester.TestPlan plan;
                    try { plan = AchievementsTester.BuildPlan(line); }
                    catch (Exception ex)
                    {
                        var msg = $"Plan build failed: Game='{r.game}', Achievement='{r.description}', Line='{line}'. Error: {ex.Message}";
                        try { await JS.InvokeVoidAsync("console.error", msg); } catch { }
                        try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize(msg)})"); } catch { }
                        Parser.DebugLogging = prevDebug; return;
                    }

                    // Fresh engine per-line to avoid cross-talk; seed snapshots before checks
                    var engine = new AchievementsEngine(new NesRamDomain(nes));
                    var tempId = $"meta_{tested}";
                    engine.Load(new[] { (tempId, line) });
                    // Seed two frames so delta/prior have stable baselines
                    nes.RunFrame(); _ = engine.EvaluateFrame();
                    nes.RunFrame(); var unlockedNow = engine.EvaluateFrame();
                    if (unlockedNow.Contains(tempId))
                    {
                        var msg = $"Initial state already unlocked before testing: Game='{r.game}', Achievement='{r.description}', Line='{line}'.";
                        try { await JS.InvokeVoidAsync("console.error", msg); } catch { }
                        try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize(msg)})"); } catch { }
                        Parser.DebugLogging = prevDebug; return;
                    }

                    bool ok;
                    try { ok = AchievementsTester.ExecutePlan(nes, plan, engine, tempId); }
                    catch (Exception ex)
                    {
                        var msg = $"Execution failed: Game='{r.game}', Achievement='{r.description}', Line='{line}'. Error: {ex.Message}";
                        try { await JS.InvokeVoidAsync("console.error", msg); } catch { }
                        try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize(msg)})"); } catch { }
                        Parser.DebugLogging = prevDebug; return;
                    }
                    // Final confirmation (advance one more frame to settle hitcounts)
                    if (!ok)
                    {
                        nes.RunFrame(); var post = engine.EvaluateFrame(); ok = post.Contains(tempId) || (engine.Get(tempId)?.Unlocked == true);
                    }
                    if (!ok)
                    {
                        // Build a detailed diagnostic report: plan steps, memory writes, before/after values, and condition states
                        string Hex2(byte b) => b.ToString("X2");
                        string Hex3(int i) => (i & 0x7FF).ToString("X3");
                        string DescribePrefix(NesEmulator.RetroAchievements.MemoryPrefix p) => p.ToString();
                        string DescribeOperand(NesEmulator.RetroAchievements.Operand op)
                        {
                            static string DescribeMem(NesEmulator.RetroAchievements.MemoryRef m)
                            {
                                var mods = (m.UseDelta ? "d" : "") + (m.UsePrior ? "p" : "") + (m.UseBcd ? "b" : "") + (m.UseInvert ? "~" : "");
                                var modsPart = mods.Length > 0 ? $" mods={mods}" : string.Empty;
                                return $"Mem({m.Prefix} @0x{m.Address:X}{modsPart})";
                            }
                            return op.Kind switch
                            {
                                NesEmulator.RetroAchievements.OperandKind.Constant => op.Const.Kind == NesEmulator.RetroAchievements.ValueKind.Float ? $"Const(float)={op.Const.F64}" : $"Const(int)={op.Const.I64}",
                                NesEmulator.RetroAchievements.OperandKind.Recall => "Recall",
                                NesEmulator.RetroAchievements.OperandKind.Memory => DescribeMem(op.Mem!),
                                _ => "(unknown)"
                            };
                        }

                        // Collect addresses touched by the plan
                        var touched = new HashSet<int>();
                        foreach (var st in plan.Steps) foreach (var w in st.Writes) touched.Add(w.Address & 0x7FF);
                        var before = new Dictionary<int, byte>();
                        foreach (var a in touched) before[a] = nes.PeekSystemRam(a);

                        // One more EvaluateFrame to capture post-state and conditions
                        nes.RunFrame(); var postIds = engine.EvaluateFrame();
                        var ach = engine.Get(tempId);
                        var after = new Dictionary<int, byte>();
                        foreach (var a in touched) after[a] = nes.PeekSystemRam(a);

                        // Build log lines
                        var linesDiag = new List<string>();
                        linesDiag.Add($"[MetaTest] Unlock verification failed");
                        linesDiag.Add($"  Game='{r.game}' Achievement='{r.description}'");
                        linesDiag.Add($"  Line='{line}'");
                        linesDiag.Add($"  Plan: {plan.Steps.Count} step(s)");
                        for (int si = 0; si < plan.Steps.Count; si++)
                        {
                            var st = plan.Steps[si];
                            linesDiag.Add($"   Step {si+1}: {st.Note} — {st.Writes.Count} write(s)");
                            foreach (var w in st.Writes)
                            {
                                int addr = w.Address & 0x7FF; string mask = w.Mask == 0xFF ? "FF" : Hex2(w.Mask);
                                linesDiag.Add($"     @{Hex3(addr)} mask={mask} val={Hex2(w.Value)}");
                            }
                        }
                        if (touched.Count > 0)
                        {
                            linesDiag.Add("  Memory before/after for touched addresses:");
                            foreach (var a in touched)
                            {
                                linesDiag.Add($"   @{Hex3(a)}: {Hex2(before[a])} -> {Hex2(after[a])}");
                            }
                        }
                        if (ach != null)
                        {
                            linesDiag.Add($"  Engine: primed={ach.Primed} unlocked={ach.Unlocked} (post Eval ids=[{string.Join(",", postIds)}])");
                            linesDiag.Add("  Conditions:");
                            foreach (var c in ach.Conditions)
                            {
                                linesDiag.Add($"   [{c.Flag}] {DescribeOperand(c.Left)} {c.Op} {DescribeOperand(c.Right)} | hits={c.Hits}/{c.HitTarget} met={c.IsMet}");
                            }
                        }
                        var joined = string.Join("\n", linesDiag);
                        try { await JS.InvokeVoidAsync("console.error", joined); } catch { }
                        try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize("Unlock verification failed. See console for details.")})"); } catch { }
                        Parser.DebugLogging = prevDebug; return;
                    }
                    if (!ok) allLinesOk = false;
                    tested++;
                    // Update UI per-line so user sees progress
                    StateHasChanged();
                }
                // Mark achievement (row) green if all lines passed
                if (allLinesOk)
                {
                    r.TestSucceeded = true;
                    StateHasChanged();
                }
            }

            try { await JS.InvokeVoidAsync("console.log", $"Parsed {parsed} and successfully unlocked {tested} formula line(s) using test.nes."); } catch { }
            try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize($"Success: parsed {parsed} and unlocked {tested} formula line(s).")})"); } catch { }
            Parser.DebugLogging = prevDebug;
        }
        catch (Exception ex)
        {
            var msg = $"Unexpected error during meta formula test: {ex.Message}";
            try { await JS.InvokeVoidAsync("console.error", msg); } catch { }
            try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize("Parsing failed:\n" + msg)})"); } catch { }
            Parser.DebugLogging = false;
        }
    }

    private class ColumnVisibility
    {
    public bool Id { get; set; } = false;
    public bool CommonName { get; set; } = true;
    public bool Status { get; set; } = true;
        public bool Note { get; set; } = false;
        public bool System { get; set; } = false;
        public bool BuiltIn { get; set; } = true;
        public bool Size { get; set; } = false;
    }

    // Wrapper properties to intercept changes and persist to localStorage
    private bool ColSystem
    {
        get => cols.System;
        set { cols.System = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColId
    {
        get => cols.Id;
        set { cols.Id = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColCommonName
    {
        get => cols.CommonName;
        set { cols.CommonName = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColStatus
    {
        get => cols.Status;
        set { cols.Status = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColNote
    {
        get => cols.Note;
        set { cols.Note = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColBuiltIn
    {
        get => cols.BuiltIn;
        set { cols.BuiltIn = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColSize
    {
        get => cols.Size;
        set { cols.Size = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    
}
