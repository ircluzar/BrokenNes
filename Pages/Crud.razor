@page "/crud"
@using Microsoft.JSInterop
@using System.Text.Json
@using NesEmulator
@using NesEmulator.RetroAchievements
@using NesEmulator.Shaders
@inject IJSRuntime JS
@inject HttpClient Http
@inject IShaderProvider ShaderProvider
@inject BrokenNes.Services.MetaGamesService MetaGames

<div class="crud-root">
    <h2 class="crud-title">DATABASE EDITOR</h2>
    <div class="crud-toolbar">
        <a class="crud-link" href="./options">Return to Options</a>
    </div>
    <div class="crud-toolbar">
        <button @onclick="ExportJson">Export DB JSON</button>
    <button type="button" @onclick="TriggerImportDialog">Import DB JSON</button>
    <input id="crud-import" type="file" accept="application/json" @onchange="ImportJson" style="display:none" @ref="importInput" />
    <button type="button" class="@GetToggleClass(autoSeedEnabled)" title="Auto-Reload from default-db.json on startup" @onclick="ToggleAutoReload">Auto-Reload</button>
        <div class="crud-columns">
            <button type="button" @onclick="ToggleColumnPicker">Columns</button>
            @if (showColumnPicker)
            {
                <div class="column-picker">
                    <div class="picker-row"><label><input type="checkbox" @bind="ColId" /> ID</label></div>
                    <div class="picker-row"><label><input type="checkbox" checked disabled /> Title</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColCommonName" /> Common Name</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColStatus" /> Status</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColNote" /> Note</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColSystem" /> System</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColBuiltIn" /> Built-in</label></div>
                    <div class="picker-row"><label><input type="checkbox" @bind="ColSize" /> Size</label></div>
                    
                </div>
            }
        </div>
    </div>

    <div class='crud-tabs'>
        <button class='@GetTabClass("games")' @onclick='() => SetTab("games")'>Games</button>
        <button class='@GetTabClass("achievements")' @onclick='() => SetTab("achievements")'>Achievements</button>
        <button class='@GetTabClass("cards")' @onclick='() => SetTab("cards")'>Cards</button>
    <button class='@GetTabClass("meta")' @onclick='() => SetTab("meta")'>Meta</button>
        <button class='@GetTabClass("levels")' @onclick='() => SetTab("levels")'>Levels</button>
    </div>

    <div class="crud-pane">
        @if (ActiveTab == "games")
        {
            <h3>Games</h3>
            <div class="games-toolbar">
                <button @onclick="LoadGamesAsync">Refresh</button>
                <span class="small-note">Shows ROMs you've loaded; auto-added to continue DB on load.</span>
            </div>
            @if (isLoading)
            {
                <div class="grid-empty">Loading…</div>
            }
            else if (games is null || games.Count == 0)
            {
                <div class="grid-empty">No records yet.</div>
            }
            else
            {
                var colCount = VisibleColCount;
                <div class="grid-head" style="grid-template-columns: repeat(@colCount, minmax(0,1fr));">
                    @if (cols.Id) { <span>ID</span> }
                    <span>Title</span>
                    @if (cols.CommonName) { <span>Common Name</span> }
                    @if (cols.Status) { <span>Status</span> }
                    @if (cols.Note) { <span>Note</span> }
                    @if (cols.System) { <span>System</span> }
                    @if (cols.BuiltIn) { <span>Built-in</span> }
                    @if (cols.Size) { <span>Size</span> }
                    
                    <span>Actions</span>
                </div>
                @foreach (var g in games)
                {
                    <div class="grid-row" style="grid-template-columns: repeat(@colCount, minmax(0,1fr));">
                        @if (cols.Id) { <span title="@g.id">@g.id</span> }
                        <span>
                            @if (g.isEditing)
                            {
                                <input value="@g.title" @onchange="(e=> g.title = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { @g.title }
                        </span>
                        @if (cols.CommonName)
                        {
                            <span>
                                @if (g.isEditing)
                                {
                                    <input value="@GetCommonName(g)" @onchange="(e=> g.commonName = e.Value?.ToString() ?? string.Empty)" />
                                }
                                else { @GetCommonName(g) }
                            </span>
                        }
                        @if (cols.Status)
                        {
                            <span>
                                @if (g.isEditing)
                                {
                                    <select value="@GetStatus(g)" @onchange="(e=> g.status = e.Value?.ToString() ?? string.Empty)">
                                        @foreach (var s in StatusOptions)
                                        {
                                            <option value="@s">@s</option>
                                        }
                                    </select>
                                }
                                else { @GetStatus(g) }
                            </span>
                        }
                        @if (cols.Note)
                        {
                            <span>
                                @if (g.isEditing)
                                {
                                    <input value="@(g.note ?? string.Empty)" @onchange="(e=> g.note = e.Value?.ToString() ?? string.Empty)" />
                                }
                                else { @(g.note ?? string.Empty) }
                            </span>
                        }
                        @if (cols.System) { <span>@g.system</span> }
                        @if (cols.BuiltIn) { <span>@(g.builtIn ? "Yes" : "No")</span> }
                        @if (cols.Size) { <span>@(g.size?.ToString() ?? "-")</span> }
                        
                        <span>
                            @if (!g.isEditing)
                            {
                                <button @onclick="(()=>BeginEdit(g))">Edit</button>
                                <button @onclick="(()=>DeleteGameAsync(g))">Delete</button>
                            }
                            else
                            {
                                <button @onclick="(()=>SaveGameAsync(g))">Save</button>
                                <button @onclick="(()=>CancelEdit(g))">Cancel</button>
                            }
                        </span>
                    </div>
                }
            }
        }
        else if (ActiveTab == "achievements")
        {
            <h3>Achievements</h3>
            <div class="games-toolbar">
                <button @onclick="LoadAchievementsAsync">Refresh</button>
                <button @onclick="AddAchievementRow">Add new achievement</button>
                    <span class="small-note">Link to a Game by its ID; select a Meta Achievement (formulas resolved from Meta DB).</span>
            </div>
            @if (isLoadingAchievements)
            {
                <div class="grid-empty">Loading…</div>
            }
            else if (achievements is null || achievements.Count == 0)
            {
                <div class="grid-empty">No records yet.</div>
            }
            else
            {
                <div class="grid-head" style="grid-template-columns: 1fr 1fr 1fr 2fr 1fr;">
                    <span>ID</span>
                    <span>Game</span>
                    <span>Title</span>
                    <span>Meta Achievement</span>
                    <span>Controls</span>
                </div>
                @foreach (var a in achievements)
                {
                    <div class="grid-row" style="grid-template-columns: 1fr 1fr 1fr 2fr 1fr;">
                        <span class="id-cell">
                            @if (a.isEditing)
                            {
                                <input class="id-input" value="@a.id" @onchange="(e=> a.id = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { <span class="id-text" title="@a.id">@a.id</span> }
                        </span>
                        <span>
                            @if (a.isEditing)
                            {
                                <select value="@a.gameId" @onchange="(e=> a.gameId = e.Value?.ToString() ?? string.Empty)">
                                    <option value="">Select Game…</option>
                                    @foreach (var g in GameOptions)
                                    {
                                        <option value="@g.id">@g.label</option>
                                    }
                                </select>
                            }
                            else { @GetGameLabel(a.gameId) }
                        </span>
                        <span>
                            @if (a.isEditing)
                            {
                                <input value="@a.title" @onchange="(e=> a.title = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { @a.title }
                        </span>
                        <span class="meta-cell">
                            @if (a.isEditing)
                            {
                                var gameTitle = GetGameLabel(a.gameId);
                                <select class="meta-select" value="@a.metaAchievementName" @onchange="(e=> a.metaAchievementName = e.Value?.ToString() ?? string.Empty)" title="@a.metaAchievementName">
                                    <option value="">Select Meta Achievement…</option>
                                    @foreach (var opt in GetMetaOptionsForGame(gameTitle))
                                    {
                                        <option value="@opt.name" title="@opt.name">@opt.name</option>
                                    }
                                </select>
                            }
                            else
                            {
                                <span class="meta-text" title="@a.metaAchievementName">@(string.IsNullOrWhiteSpace(a.metaAchievementName) ? "-" : a.metaAchievementName)</span>
                            }
                        </span>
                        <span>
                            @if (!a.isEditing)
                            {
                                <button @onclick="(()=>BeginEditAchievement(a))">Edit</button>
                                <button @onclick="(()=>DeleteAchievementAsync(a))">Delete</button>
                            }
                            else
                            {
                                <button @onclick="(()=>SaveAchievementAsync(a))">Save</button>
                                <button @onclick="(()=>CancelEditAchievement(a))">Cancel</button>
                            }
                        </span>
                    </div>
                }
            }
        }
        else if (ActiveTab == "cards")
        {
            <h3>Cards</h3>
            <div class="games-toolbar">
                <button @onclick="RefreshCardsAsync">Refresh Cards</button>
                <span class="small-note">Scans CPU/PPU/APU/Clock/Shaders via reflection. Type/Note are persisted.</span>
            </div>
            @if (isLoadingCards)
            {
                <div class="grid-empty">Loading…</div>
            }
            else if (cards is null || cards.Count == 0)
            {
                <div class="grid-empty">No records yet.</div>
            }
            else
            {
                <div class="grid-head" style="grid-template-columns: repeat(10, minmax(0,1fr));">
                    <span>ID</span>
                    <span>Type</span>
                    <span>Note</span>
                    <span>Domain</span>
                    <span>Core Id</span>
                    <span>Name</span>
                    <span>Category</span>
                    <span>Perf</span>
                    <span>Rating</span>
                    <span>Actions</span>
                </div>
                @foreach (var c in cards)
                {
                    <div class="grid-row" style="grid-template-columns: repeat(10, minmax(0,1fr));">
                        <span title="@c.id">@c.id</span>
                        <span>
                            @if (c.isEditing)
                            {
                                <select value="@c.type" @onchange="(e=> c.type = e.Value?.ToString() ?? DefaultCardType)">
                                    @foreach (var t in CardTypeOptions)
                                    {
                                        <option value="@t">@t</option>
                                    }
                                </select>
                            }
                            else { @c.type }
                        </span>
                        <span>
                            @if (c.isEditing)
                            {
                                <input value="@(c.note ?? string.Empty)" @onchange="(e=> c.note = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { @(c.note ?? string.Empty) }
                        </span>
                        <span>@c.domain</span>
                        <span>@c.coreId</span>
                        <span>@c.name</span>
                        <span>@(string.IsNullOrWhiteSpace(c.category) ? "-" : c.category)</span>
                        <span>@c.performance</span>
                        <span>@c.rating</span>
                        <span>
                            @if (!c.isEditing)
                            {
                                <button @onclick="(()=>BeginEditCard(c))">Edit</button>
                                <button @onclick="(()=>DeleteCardAsync(c))">Delete</button>
                            }
                            else
                            {
                                <button @onclick="(()=>SaveCardAsync(c))">Save</button>
                                <button @onclick="(()=>CancelEditCard(c))">Cancel</button>
                            }
                        </span>
                    </div>
                }
            }
        }
    else if (ActiveTab == "meta")
        {
            <h3>Meta Achievements</h3>
            <div class="games-toolbar">
                <input placeholder="Filter by game title (exact match)" value="@metaFilterTitle" @onchange="OnMetaFilterChanged" />
                <button @onclick="LoadMetaAsync">Refresh</button>
        <button @onclick="TestAllMetaFormulasAsync">Test All Formulas</button>
                <span class="small-note">Read-only view from models/meta_games.json</span>
            </div>
            @if (isLoadingMeta)
            {
                <div class="grid-empty">Loading…</div>
            }
            else if (metaRows is null || metaRows.Count == 0)
            {
                var metaErr = MetaGames.GetLastError();
                if (!string.IsNullOrWhiteSpace(metaErr))
                {
                    <div class="grid-empty">No data. Error: @metaErr</div>
                }
                else
                {
                    <div class="grid-empty">No data.</div>
                }
            }
            else
            {
                <div class="grid-head" style="grid-template-columns: 1fr 1fr 2fr 0.6fr;">
                    <span>Game</span>
                    <span>Achievement</span>
                    <span>Formula</span>
                    <span>Approved</span>
                </div>
                @foreach (var r in metaRows)
                {
                    <div class="grid-row" style="grid-template-columns: 1fr 1fr 2fr 0.6fr;">
                        <span>@r.game</span>
                        <span title="Click to test just this achievement"
                              @onclick="(()=> TestSingleMetaFormulaAsync(r))"
                              style="cursor:pointer;@(r.TestSucceeded ? "color:var(--success,green);font-weight:600;" : (r.TestFailed ? "color:var(--danger,crimson);font-weight:600;" : string.Empty))">@r.description</span>
                        <span style="white-space: pre-wrap; word-break: break-word; overflow-wrap: anywhere; font-family: var(--monospace, ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace)">@r.formula</span>
                        <span><input type="checkbox" checked="@r.Approved" @onchange="(e=> OnToggleApprovedAsync(r, e))" /></span>
                    </div>
                }
            }
        }
        else if (ActiveTab == "levels")
        {
            <h3>Levels</h3>
            <div class="games-toolbar">
                <button @onclick="LoadLevelsAsync">Refresh</button>
                <button @onclick="AddLevelRow">Add new level</button>
                <span class="small-note">Manual entry. Index must be unique.</span>
            </div>
            @if (isLoadingLevels)
            {
                <div class="grid-empty">Loading…</div>
            }
            else if (levels is null || levels.Count == 0)
            {
                <div class="grid-empty">No records yet.</div>
            }
            else
            {
                <div class="grid-head" style="grid-template-columns: repeat(6, minmax(0,1fr));">
                    <span>Index</span>
                    <span>Required Cards</span>
                    <span>Required Stars</span>
                    <span>Card Challenge</span>
                    <span>Message</span>
                    <span>Actions</span>
                </div>
                @foreach (var l in levels)
                {
                    <div class="grid-row" style="grid-template-columns: repeat(6, minmax(0,1fr));">
                        <span>
                            @if (l.isEditing)
                            {
                                <input type="number" value="@l.index" @onchange="(e=> l.index = ParseInt(e.Value))" />
                            }
                            else { @l.index }
                        </span>
                        <span>
                            @if (l.isEditing)
                            {
                                EnsureCardSlots(l);
                                <div style="display:flex;gap:.25rem;flex-wrap:wrap">
                                    @for (var i = 0; i < 5; i++)
                                    {
                                        var localI = i;
                                        <select value="@GetCardSlotValue(l, localI)" @onchange="(e=> SetCardSlotValue(l, localI, e.Value?.ToString()))" style="min-width:9rem">
                                            <option value="">None</option>
                                            @foreach (var opt in CardOptions)
                                            {
                                                <option value="@opt.id">@opt.label</option>
                                            }
                                        </select>
                                    }
                                </div>
                            }
                            else { @FormatRequiredCards(l) }
                        </span>
                        <span>
                            @if (l.isEditing)
                            {
                                <input type="number" value="@l.requiredStars" @onchange="(e=> l.requiredStars = ParseInt(e.Value))" />
                            }
                            else { @l.requiredStars }
                        </span>
                        <span>
                            @if (l.isEditing)
                            {
                                <input value="@(l.cardChallenge ?? string.Empty)" @onchange="(e=> l.cardChallenge = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { @(string.IsNullOrWhiteSpace(l.cardChallenge) ? "-" : l.cardChallenge) }
                        </span>
                        <span style="white-space: pre-wrap; word-break: break-word; overflow-wrap: anywhere;">
                            @if (l.isEditing)
                            {
                                <input value="@(l.message ?? string.Empty)" @onchange="(e=> l.message = e.Value?.ToString() ?? string.Empty)" />
                            }
                            else { @(string.IsNullOrWhiteSpace(l.message) ? "-" : l.message) }
                        </span>
                        <span>
                            @if (!l.isEditing)
                            {
                                <button @onclick="(()=>BeginEditLevel(l))">Edit</button>
                                <button @onclick="(()=>DeleteLevelAsync(l))">Delete</button>
                            }
                            else
                            {
                                <button @onclick="(()=>SaveLevelAsync(l))">Save</button>
                                <button @onclick="(()=>CancelEditLevel(l))">Cancel</button>
                            }
                        </span>
                    </div>
                }
            }
        }
    </div>
</div>

@code {
    private string ActiveTab { get; set; } = "games";
    private bool isLoading = false;
    private bool isLoadingCards = false;
    private bool isLoadingLevels = false;
    private bool isLoadingAchievements = false;
    private bool isLoadingMeta = false;
    private List<GameRow> games = new();
    private List<CardRow> cards = new();
    private List<LevelRow> levels = new();
    private List<AchievementRow> achievements = new();
    private List<MetaRow> metaRows = new();
    private List<CardOption> CardOptions { get; set; } = new();
    private Dictionary<string, string> CardLabelById { get; set; } = new(StringComparer.OrdinalIgnoreCase);
    private bool autoSeedEnabled = true;
    private bool showColumnPicker = false;
    private ColumnVisibility cols = new() { Id = false, CommonName = true, Status = true, Note = false, System = false, BuiltIn = true, Size = false };
    private ElementReference importInput;

    // Title is always visible; others are conditional
    private int VisibleColCount => 1 // Title
        + (cols.Id ? 1 : 0)
        + (cols.CommonName ? 1 : 0)
        + (cols.Status ? 1 : 0)
        + (cols.Note ? 1 : 0)
        + (cols.System ? 1 : 0)
        + (cols.BuiltIn ? 1 : 0)
        + (cols.Size ? 1 : 0)
        + 1; // Actions
    private bool AutoSeedEnabled
    {
        get => autoSeedEnabled;
        set
        {
            autoSeedEnabled = value;
            try { _ = JS.InvokeVoidAsync("continueDb.setAutoSeedEnabled", value); } catch { }
        }
    }

    private void SetTab(string id)
    {
        ActiveTab = id;
        // Lazy-load when switching tabs
    if (id == "games") _ = LoadGamesAsync();
    else if (id == "cards") _ = RefreshCardsAsync();
    else if (id == "levels") _ = LoadLevelsAsync();
    else if (id == "achievements") _ = LoadAchievementsAsync();
    else if (id == "meta") _ = LoadMetaAsync();
    }

    private string GetTabClass(string id) => ActiveTab == id ? "active" : string.Empty;
    private string GetToggleClass(bool on) => on ? "active" : string.Empty;

    private async Task ExportJson()
    {
        try { await JS.InvokeVoidAsync("continueDb.exportAllToDownload"); } catch { }
    }

    private async Task ImportJson(ChangeEventArgs e)
    {
        try { await JS.InvokeVoidAsync("continueDb.importFromFileInput"); } catch { }
        await LoadGamesAsync();
    if (ActiveTab == "achievements") await LoadAchievementsAsync();
    if (ActiveTab == "levels") await LoadLevelsAsync();
    }

    private async Task TriggerImportDialog()
    {
        try { await JS.InvokeVoidAsync("eval", "document.getElementById('crud-import')?.click()"); } catch { }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Initialize toggle from JS
            try { autoSeedEnabled = await JS.InvokeAsync<bool>("continueDb.getAutoSeedEnabled"); } catch { autoSeedEnabled = true; }
            // Load column prefs
            try
            {
                var json = await JS.InvokeAsync<string>("localStorage.getItem", "crud:gamesCols");
                if (!string.IsNullOrWhiteSpace(json))
                {
                    var loaded = JsonSerializer.Deserialize<ColumnVisibility>(json);
                    if (loaded != null)
                    {
                        // Merge with defaults so new fields get sensible defaults
                        cols = new ColumnVisibility
                        {
                            Id = loaded.Id,
                            CommonName = loaded.CommonName == default ? true : loaded.CommonName,
                            Status = loaded.Status == default ? true : loaded.Status,
                            Note = loaded.Note,
                            System = loaded.System,
                            BuiltIn = loaded.BuiltIn,
                            Size = loaded.Size
                        };
                    }
                }
            }
            catch { }
            await LoadGamesAsync();
        }
    }

    private async Task LoadGamesAsync()
    {
        if (ActiveTab != "games") return;
        isLoading = true; StateHasChanged();
        try
        {
            var json = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('games'); arr.sort((a,b)=> (a.title||'').localeCompare(b.title||'')); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var list = string.IsNullOrWhiteSpace(json) ? new List<GameRow>() : JsonSerializer.Deserialize<List<GameRow>>(json) ?? new List<GameRow>();
            foreach (var g in list) { if (string.IsNullOrWhiteSpace(g.status)) g.status = "Nothing"; if (g.note == null) g.note = string.Empty; }
            games = list;
        }
        catch { games = new(); }
        finally { isLoading = false; StateHasChanged(); }
    }

    private void ToggleColumnPicker() => showColumnPicker = !showColumnPicker;

    private void ToggleAutoReload()
    {
        AutoSeedEnabled = !AutoSeedEnabled;
        StateHasChanged();
    }

    private Task SaveColumnsAsync()
    {
        try { return JS.InvokeVoidAsync("localStorage.setItem", "crud:gamesCols", JsonSerializer.Serialize(cols)).AsTask(); }
        catch { return Task.CompletedTask; }
    }

    private static string GetCommonName(GameRow g)
    {
        if (!string.IsNullOrWhiteSpace(g.commonName)) return g.commonName!;
        if (!string.IsNullOrWhiteSpace(g.title)) return g.title!;
        return g.romKey ?? string.Empty;
    }

    private static string GetStatus(GameRow g)
    {
        return string.IsNullOrWhiteSpace(g.status) ? "Nothing" : g.status!;
    }

    private static readonly string[] StatusOptions = new[] { "Nothing", "Broken", "Jank", "Works" };

    private void BeginEdit(GameRow g)
    {
        g.isEditing = true; StateHasChanged();
    }

    private void CancelEdit(GameRow g)
    {
        _ = LoadGamesAsync();
    }

    private async Task SaveGameAsync(GameRow g)
    {
        try
        {
            var rec = new {
                id = g.id,
                title = g.title ?? string.Empty,
                commonName = g.commonName ?? string.Empty,
                status = string.IsNullOrWhiteSpace(g.status) ? "Nothing" : g.status,
                note = g.note ?? string.Empty,
                system = g.system ?? "nes",
                romKey = g.romKey,
                headerSignature = g.headerSignature,
                builtIn = g.builtIn,
                size = g.size,
                createdAt = g.createdAt
            };
            var recJson = JsonSerializer.Serialize(rec);
            var safe = recJson.Replace("\\", "\\\\").Replace("'", "\\'").Replace("\n","\\n").Replace("\r", "");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); const rec = JSON.parse('{safe}'); await window.continueDb.put('games', rec); }} catch(e) {{ console.warn('save failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadGamesAsync();
    }

    private async Task DeleteGameAsync(GameRow g)
    {
        try
        {
            var idSafe = (g.id ?? string.Empty).Replace("'", "\'");
            var confirm = await JS.InvokeAsync<bool>("eval", $"confirm('Delete game ' + {JsonSerializer.Serialize(GetCommonName(g))} + ' (ID: ' + {JsonSerializer.Serialize(g.id ?? string.Empty)} + ')? This cannot be undone.')");
            if (!confirm) return;
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); await window.continueDb.delete('games', '{idSafe}'); }} catch(e) {{ console.warn('delete game failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadGamesAsync();
    }

    // ===== ACHIEVEMENTS TAB =====
    private List<GameOption> GameOptions { get; set; } = new();

    private async Task LoadAchievementsAsync()
    {
        if (ActiveTab != "achievements") return;
        isLoadingAchievements = true; StateHasChanged();
        try
        {
            // build game options from games store (ID + label is common name or title)
            var gamesJson = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('games'); arr.sort((a,b)=> (a.title||'').localeCompare(b.title||'')); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var gameList = string.IsNullOrWhiteSpace(gamesJson) ? new List<GameRow>() : JsonSerializer.Deserialize<List<GameRow>>(gamesJson) ?? new List<GameRow>();
            GameOptions = gameList
                .Where(g => !string.IsNullOrWhiteSpace(g.id))
                .Select(g => new GameOption { id = g.id!, label = GetCommonName(g) })
                .OrderBy(g => g.label, StringComparer.OrdinalIgnoreCase)
                .ToList();

            var json = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('achievements'); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var list = string.IsNullOrWhiteSpace(json) ? new List<AchievementRow>() : JsonSerializer.Deserialize<List<AchievementRow>>(json) ?? new List<AchievementRow>();
            foreach (var a in list)
            {
                a.requirements ??= new List<string>();
                a.id ??= string.Empty;
                a.title ??= string.Empty;
                a.gameId ??= string.Empty;
            }
            achievements = list.OrderBy(a => a.id, StringComparer.OrdinalIgnoreCase).ToList();
        }
        catch { achievements = new(); }
        finally { isLoadingAchievements = false; StateHasChanged(); }
    }

    private void AddAchievementRow()
    {
        achievements ??= new List<AchievementRow>();
        var nextId = SuggestAchievementId();
        achievements.Add(new AchievementRow
        {
            id = nextId,
            gameId = GameOptions.FirstOrDefault()?.id ?? string.Empty,
            title = string.Empty,
            requirements = new List<string>(),
            isEditing = true
        });
        StateHasChanged();
    }

    private string SuggestAchievementId()
    {
        var baseId = "ach_";
        var i = 1;
        var set = new HashSet<string>(achievements.Select(a => a.id ?? string.Empty), StringComparer.OrdinalIgnoreCase);
        while (set.Contains(baseId + i)) i++;
        return baseId + i;
    }

    private void BeginEditAchievement(AchievementRow a)
    {
    a.isEditing = true; StateHasChanged();
    var title = GetGameLabel(a.gameId);
    _ = EnsureMetaOptionsForGameAsync(title);
    }

    private async Task CancelEditAchievement(AchievementRow a)
    {
        await LoadAchievementsAsync();
    }

    private async Task SaveAchievementAsync(AchievementRow a)
    {
        try
        {
            var rec = new {
                id = a.id ?? string.Empty,
                gameId = a.gameId ?? string.Empty,
                title = a.title ?? string.Empty,
                requirements = (a.requirements ?? new List<string>()).Where(s => !string.IsNullOrWhiteSpace(s)).ToArray(),
                metaAchievementName = a.metaAchievementName ?? string.Empty
            };
            var recJson = JsonSerializer.Serialize(rec);
            var safe = recJson.Replace("\\", "\\\\").Replace("'", "\\'").Replace("\n","\\n").Replace("\r", "");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); const rec = JSON.parse('{safe}'); await window.continueDb.put('achievements', rec); }} catch(e) {{ console.warn('save achievement failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadAchievementsAsync();
    }

    private async Task DeleteAchievementAsync(AchievementRow a)
    {
        try
        {
            var label = a.id ?? string.Empty;
            var confirm = await JS.InvokeAsync<bool>("eval", $"confirm('Delete achievement ' + {JsonSerializer.Serialize(label)} + '? This cannot be undone.')");
            if (!confirm) return;
            var idSafe = label.Replace("'", "\'");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); await window.continueDb.delete('achievements', '{idSafe}'); }} catch(e) {{ console.warn('delete achievement failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadAchievementsAsync();
    }

    private void AddRequirement(AchievementRow a)
    {
        a.requirements ??= new List<string>();
        a.requirements.Add(string.Empty);
        StateHasChanged();
    }

    private void RemoveRequirement(AchievementRow a, int index)
    {
        try { a.requirements?.RemoveAt(index); } catch { }
        StateHasChanged();
    }

    private void UpdateRequirement(AchievementRow a, int index, string? value)
    {
        try { if (a.requirements != null && index >= 0 && index < a.requirements.Count) a.requirements[index] = value ?? string.Empty; } catch { }
    }

    private string GetGameLabel(string? gameId)
    {
        if (string.IsNullOrWhiteSpace(gameId)) return "-";
        var opt = GameOptions.FirstOrDefault(g => string.Equals(g.id, gameId, StringComparison.OrdinalIgnoreCase));
        return opt?.label ?? gameId;
    }

    // ===== LEVELS TAB =====
    private async Task LoadLevelsAsync()
    {
        if (ActiveTab != "levels") return;
        isLoadingLevels = true; StateHasChanged();
        try
        {
            // Build card options once for dropdowns
            if (CardOptions.Count == 0)
            {
                var meta = await ScanAllCardMetaAsync();
                CardOptions = meta
                    .OrderBy(m => m.domain)
                    .ThenBy(m => m.name, StringComparer.OrdinalIgnoreCase)
                    .Select(m => {
                        var id = m.domain + "_" + m.coreId; // short form label
                        return new CardOption { id = id, label = id };
                    })
                    .ToList();
                CardLabelById = CardOptions.GroupBy(o => o.id).ToDictionary(g => g.Key, g => g.First().label, StringComparer.OrdinalIgnoreCase);
            }

            var json = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('levels'); arr.sort((a,b)=> (a.index||0) - (b.index||0)); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var list = string.IsNullOrWhiteSpace(json) ? new List<LevelRow>() : JsonSerializer.Deserialize<List<LevelRow>>(json) ?? new List<LevelRow>();
            foreach (var l in list)
            {
                l.requiredCards ??= new List<string>();
                if (l.requiredStars < 0) l.requiredStars = 0;
            }
            levels = list;
        }
        catch { levels = new(); }
        finally { isLoadingLevels = false; StateHasChanged(); }
    }

    private void AddLevelRow()
    {
        var nextIndex = 1;
        try { if (levels != null && levels.Count > 0) nextIndex = Math.Max(1, levels.Max(l => l.index)) + 1; } catch { nextIndex = 1; }
        levels ??= new List<LevelRow>();
        levels.Add(new LevelRow
        {
            index = nextIndex,
            requiredCards = new List<string>(),
            requiredStars = 0,
            cardChallenge = string.Empty,
            message = string.Empty,
            isEditing = true
        });
        StateHasChanged();
    }

    private void BeginEditLevel(LevelRow l)
    {
        l.isEditing = true; StateHasChanged();
    }

    private async Task CancelEditLevel(LevelRow l)
    {
        await LoadLevelsAsync();
    }

    private async Task SaveLevelAsync(LevelRow l)
    {
        try
        {
            if (l.index < 1) l.index = 1;
            var rec = new {
                index = l.index,
                requiredCards = (l.requiredCards ?? new List<string>()).Where(s => !string.IsNullOrWhiteSpace(s)).Take(5).ToArray(),
                requiredStars = Math.Max(0, l.requiredStars),
                cardChallenge = l.cardChallenge ?? string.Empty,
                message = l.message ?? string.Empty
            };
            var recJson = JsonSerializer.Serialize(rec);
            var safe = recJson.Replace("\\", "\\\\").Replace("'", "\\'").Replace("\n","\\n").Replace("\r", "");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); const rec = JSON.parse('{safe}'); await window.continueDb.put('levels', rec); }} catch(e) {{ console.warn('save level failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadLevelsAsync();
    }

    private async Task DeleteLevelAsync(LevelRow l)
    {
        try
        {
            var confirm = await JS.InvokeAsync<bool>("eval", $"confirm('Delete level #' + {l.index} + '? This cannot be undone.')");
            if (!confirm) return;
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); await window.continueDb.delete('levels', {l.index}); }} catch(e) {{ console.warn('delete level failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadLevelsAsync();
    }

    private static int ParseInt(object? v)
    {
        try { return Convert.ToInt32(v); } catch { return 0; }
    }

    private sealed class LevelRow
    {
        public int index { get; set; }
        public List<string>? requiredCards { get; set; }
        public int requiredStars { get; set; }
        public string? cardChallenge { get; set; }
    public string? message { get; set; }
        public bool isEditing { get; set; }
    }

    private sealed class CardOption { public string id { get; set; } = string.Empty; public string label { get; set; } = string.Empty; }

    private static void EnsureCardSlots(LevelRow l)
    {
        l.requiredCards ??= new List<string>();
        while (l.requiredCards.Count < 5) l.requiredCards.Add(string.Empty);
        if (l.requiredCards.Count > 5) l.requiredCards = l.requiredCards.Take(5).ToList();
    }

    private string GetCardSlotValue(LevelRow l, int i)
    {
        try { return l.requiredCards![i] ?? string.Empty; } catch { return string.Empty; }
    }

    private void SetCardSlotValue(LevelRow l, int i, string? value)
    {
        EnsureCardSlots(l);
        l.requiredCards![i] = value ?? string.Empty;
    }

    private string FormatRequiredCards(LevelRow l)
    {
        if (l.requiredCards == null || l.requiredCards.Count == 0) return "0";
        var labels = l.requiredCards
            .Where(id => !string.IsNullOrWhiteSpace(id))
            .Select(id => CardLabelById.TryGetValue(id, out var lbl) ? lbl : id)
            .ToList();
        if (labels.Count == 0) return "0";
        return string.Join(", ", labels);
    }

    private class GameRow
    {
        public string? id { get; set; }
        public string? title { get; set; }
    public string? commonName { get; set; }
    public string? status { get; set; }
    public string? note { get; set; }
    public string? system { get; set; }
    public string? romKey { get; set; }
    public string? headerSignature { get; set; }
    public bool builtIn { get; set; }
    public int? size { get; set; }
    public string? createdAt { get; set; }
    public bool isEditing { get; set; }
    }

    // ===== CARDS TAB =====
    private const string DefaultCardType = "Last";
    private static readonly string[] CardTypeOptions = new[] { "Reserved", "Random", DefaultCardType };

    private async Task RefreshCardsAsync()
    {
        if (ActiveTab != "cards") return;
        isLoadingCards = true; StateHasChanged();
        try
        {
            // 1) Scan reflection for all available cores/cards
            var meta = await ScanAllCardMetaAsync();

            // 2) Load persisted selections (type/note) from continueDb
            var json = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('cards'); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var persisted = string.IsNullOrWhiteSpace(json) ? new List<CardPersisted>() : JsonSerializer.Deserialize<List<CardPersisted>>(json) ?? new List<CardPersisted>();
            var map = new Dictionary<string, CardPersisted>(StringComparer.OrdinalIgnoreCase);
            foreach (var p in persisted) if (!string.IsNullOrWhiteSpace(p.id)) map[p.id!] = p;

            // 3) Build rows, join on id
            var rows = new List<CardRow>(meta.Count);
            foreach (var m in meta.OrderBy(m => m.domain).ThenBy(m => m.name, StringComparer.OrdinalIgnoreCase))
            {
                var id = m.domain + "_" + m.coreId; // composite
                map.TryGetValue(id, out var p);
                rows.Add(new CardRow
                {
                    id = id,
                    domain = m.domain,
                    coreId = m.coreId,
                    name = m.name,
                    category = m.category,
                    performance = m.performance,
                    rating = m.rating,
                    type = string.IsNullOrWhiteSpace(p?.type) ? "Last" : p!.type!,
                    note = p?.note ?? string.Empty,
                    isEditing = false
                });
            }
            cards = rows;
        }
        catch { cards = new(); }
        finally { isLoadingCards = false; StateHasChanged(); }
    }

    private void BeginEditCard(CardRow c)
    {
        c.isEditing = true; StateHasChanged();
    }

    private Task CancelEditCard(CardRow c)
    {
        return RefreshCardsAsync();
    }

    private async Task SaveCardAsync(CardRow c)
    {
        try
        {
            var rec = new { id = c.id, type = string.IsNullOrWhiteSpace(c.type) ? "Last" : c.type, note = c.note ?? string.Empty };
            var recJson = JsonSerializer.Serialize(rec);
            var safe = recJson.Replace("\\", "\\\\").Replace("'", "\\'").Replace("\n","\\n").Replace("\r", "");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); const rec = JSON.parse('{safe}'); await window.continueDb.put('cards', rec); }} catch(e) {{ console.warn('save card failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await RefreshCardsAsync();
    }

    private async Task DeleteCardAsync(CardRow c)
    {
        try
        {
            var label = c.id;
            var confirm = await JS.InvokeAsync<bool>("eval", $"confirm('Delete card ' + {JsonSerializer.Serialize(label)} + '? This cannot be undone.')");
            if (!confirm) return;
            var idSafe = (label ?? string.Empty).Replace("'", "\'");
            var js = $@"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); await window.continueDb.delete('cards', '{idSafe}'); }} catch(e) {{ console.warn('delete card failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await RefreshCardsAsync();
    }

    private sealed class CardRow
    {
        public string id { get; set; } = string.Empty; // composite: DOMAIN_ID
        public string domain { get; set; } = string.Empty; // CPU/PPU/APU/CLOCK/SHADER
        public string coreId { get; set; } = string.Empty; // short id within domain
        public string name { get; set; } = string.Empty;   // display name (from reflection)
        public string category { get; set; } = string.Empty;
        public int performance { get; set; }
        public int rating { get; set; }
        public string type { get; set; } = "Last"; // Reserved | Random | Last
        public string? note { get; set; }
        public bool isEditing { get; set; }
    }

    private sealed class CardPersisted
    {
        public string? id { get; set; }
        public string? type { get; set; }
        public string? note { get; set; }
    }

    private sealed class CardMeta
    {
        public string domain { get; set; } = string.Empty; // CPU/PPU/APU/CLOCK/SHADER
        public string coreId { get; set; } = string.Empty;
        public string name { get; set; } = string.Empty;
        public string category { get; set; } = string.Empty;
        public int performance { get; set; }
        public int rating { get; set; }
    }

    private sealed class AchievementRow
    {
        public string? id { get; set; }
        public string? gameId { get; set; }
        public string? title { get; set; }
    public List<string>? requirements { get; set; } // legacy only
    public string? metaAchievementName { get; set; }
        public bool isEditing { get; set; }
    }

    private sealed class MetaRow
    {
        public string game { get; set; } = string.Empty;
        public string description { get; set; } = string.Empty;
        public string formula { get; set; } = string.Empty;
        public bool TestSucceeded { get; set; } = false;
        public bool TestFailed { get; set; } = false;
    public bool Approved { get; set; } = false;
    }

    private sealed class GameOption { public string id { get; set; } = string.Empty; public string label { get; set; } = string.Empty; }

    private static T? SafeGet<T>(Func<T> getter)
    {
        try { return getter(); } catch { return default; }
    }

    private static T? SafeGetStruct<T>(Func<T> getter) where T : struct
    {
        try { return getter(); } catch { return null; }
    }

    private async Task<List<CardMeta>> ScanAllCardMetaAsync()
    {
        var list = new List<CardMeta>();
        // Build a tiny, valid iNES ROM (NROM-128: 1x16KB PRG, 0 CHR) so cores can instantiate
        try
        {
            var dummy = new byte[16 + 16 * 1024];
            dummy[0] = 0x4E; dummy[1] = 0x45; dummy[2] = 0x53; dummy[3] = 0x1A; // NES\x1A
            dummy[4] = 1; // PRG banks
            dummy[5] = 0; // CHR banks
            dummy[6] = 0; dummy[7] = 0; // flags
            var cart = new Cartridge(dummy);
            var bus = new Bus(cart);

            // CPU
            try
            {
                foreach (var kv in CoreRegistry.CreateInstances<ICPU>(bus, "CPU_"))
                {
                    list.Add(new CardMeta
                    {
                        domain = "CPU",
                        coreId = kv.Key,
                        name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
                        category = SafeGet(() => kv.Value.Category) ?? "",
                        performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
                        rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
                    });
                }
            }
            catch { }

            // PPU
            try
            {
                foreach (var kv in CoreRegistry.CreateInstances<IPPU>(bus, "PPU_"))
                {
                    list.Add(new CardMeta
                    {
                        domain = "PPU",
                        coreId = kv.Key,
                        name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
                        category = SafeGet(() => kv.Value.Category) ?? "",
                        performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
                        rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
                    });
                }
            }
            catch { }

            // APU
            try
            {
                foreach (var kv in CoreRegistry.CreateInstances<IAPU>(bus, "APU_"))
                {
                    list.Add(new CardMeta
                    {
                        domain = "APU",
                        coreId = kv.Key,
                        name = SafeGet(() => kv.Value.CoreName) ?? kv.Key,
                        category = SafeGet(() => kv.Value.Category) ?? "",
                        performance = SafeGetStruct(() => kv.Value.Performance) ?? 0,
                        rating = SafeGetStruct(() => kv.Value.Rating) ?? 0,
                    });
                }
            }
            catch { }

            // CLOCK
            try
            {
                foreach (var id in ClockRegistry.Ids)
                {
                    try
                    {
                        var clk = ClockRegistry.Create(id);
                        if (clk != null)
                        {
                            list.Add(new CardMeta
                            {
                                domain = "CLOCK",
                                coreId = id,
                                name = clk.DisplayName,
                                category = SafeGet(() => clk.Category) ?? "",
                                performance = SafeGetStruct(() => clk.Performance) ?? 0,
                                rating = SafeGetStruct(() => clk.Rating) ?? 0,
                            });
                        }
                    }
                    catch { }
                }
            }
            catch { }

            // SHADERS
            try
            {
                var allShaders = ShaderProvider?.All ?? Array.Empty<IShader>();
                foreach (var s in allShaders)
                {
                    string? cat = null;
                    try { cat = s.Defines != null && s.Defines.TryGetValue("Category", out var c) ? c : null; } catch { }
                    list.Add(new CardMeta
                    {
                        domain = "SHADER",
                        coreId = s.Id,
                        name = SafeGet(() => s.CoreName) ?? s.DisplayName,
                        category = cat ?? "",
                        performance = SafeGetStruct(() => s.Performance) ?? 0,
                        rating = SafeGetStruct(() => s.Rating) ?? 0,
                    });
                }
            }
            catch { }
        }
        catch { }

        await Task.Yield();
        return list;
    }

    // === META tab helpers ===
    private string metaFilterTitle = string.Empty;

    // Meta achievement selection options for Achievements tab
    private sealed class MetaOption { public string name { get; set; } = string.Empty; public string formula { get; set; } = string.Empty; }
    private readonly Dictionary<string, List<MetaOption>> MetaOptionsByGameTitle = new(StringComparer.OrdinalIgnoreCase);
    private async Task EnsureMetaOptionsForGameAsync(string? gameTitle)
    {
        if (string.IsNullOrWhiteSpace(gameTitle)) return;
        if (MetaOptionsByGameTitle.ContainsKey(gameTitle)) return;
        try
        {
            var items = await MetaGames.GetAchievementsByTitleAsync(gameTitle);
            var opts = items.Select(i => new MetaOption { name = i.Description, formula = i.Formula })
                            .OrderBy(o => o.name, StringComparer.OrdinalIgnoreCase)
                            .ToList();
            MetaOptionsByGameTitle[gameTitle] = opts;
            StateHasChanged();
        }
        catch { MetaOptionsByGameTitle[gameTitle] = new List<MetaOption>(); }
    }
    private IEnumerable<MetaOption> GetMetaOptionsForGame(string? gameTitle)
    {
        if (string.IsNullOrWhiteSpace(gameTitle)) return Array.Empty<MetaOption>();
        _ = EnsureMetaOptionsForGameAsync(gameTitle);
        return MetaOptionsByGameTitle.TryGetValue(gameTitle, out var list) ? list : Array.Empty<MetaOption>();
    }

    // Title <-> GameId maps (for Meta Approved toggle)
    private Dictionary<string, string> GameIdByLabel { get; set; } = new(StringComparer.OrdinalIgnoreCase);
    private Dictionary<string, string> GameLabelById { get; set; } = new(StringComparer.OrdinalIgnoreCase);
    private async Task EnsureGamesIndexAsync()
    {
        if (GameIdByLabel.Count > 0 && GameLabelById.Count > 0) return;
        try
        {
            var gamesJson = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('games'); arr.sort((a,b)=> (a.title||'').localeCompare(b.title||'')); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var gameList = string.IsNullOrWhiteSpace(gamesJson) ? new List<GameRow>() : JsonSerializer.Deserialize<List<GameRow>>(gamesJson) ?? new List<GameRow>();
            GameIdByLabel.Clear(); GameLabelById.Clear();
            foreach (var g in gameList)
            {
                if (string.IsNullOrWhiteSpace(g.id)) continue;
                var label = GetCommonName(g);
                GameIdByLabel[label] = g.id!;
                GameLabelById[g.id!] = label;
            }
        }
        catch { GameIdByLabel.Clear(); GameLabelById.Clear(); }
    }

    private async Task LoadMetaAsync()
    {
        if (ActiveTab != "meta") return;
        isLoadingMeta = true; StateHasChanged();
        try
        {
            IReadOnlyList<BrokenNes.Services.MetaGamesService.AchievementWithGame> list;
            if (string.IsNullOrWhiteSpace(metaFilterTitle))
            {
                list = await MetaGames.GetAllAchievementsFlatAsync();
            }
            else
            {
                var items = await MetaGames.GetAchievementsByTitleAsync(metaFilterTitle);
                list = items.Select(a => new BrokenNes.Services.MetaGamesService.AchievementWithGame(metaFilterTitle, a.Description, a.Formula)).ToList();
            }

            metaRows = list
                .Select(x => new MetaRow { game = x.GameTitle, description = x.Description, formula = x.Formula })
                .OrderBy(r => r.game, StringComparer.OrdinalIgnoreCase)
                .ThenBy(r => r.description, StringComparer.OrdinalIgnoreCase)
                .ToList();

            // Compute Approved = exists in Achievements DB for (game title, meta name)
            await EnsureGamesIndexAsync();
            var achJson = await JS.InvokeAsync<string>("eval", @"(async()=>{ try { if (!window.continueDb) return '[]'; await window.continueDb.open(); const arr = await window.continueDb.getAll('achievements'); return JSON.stringify(arr); } catch(e){ return '[]'; } })()");
            var achArr = string.IsNullOrWhiteSpace(achJson) ? new List<AchievementRow>() : JsonSerializer.Deserialize<List<AchievementRow>>(achJson) ?? new List<AchievementRow>();
            var approved = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            foreach (var a in achArr)
            {
                var gid = a.gameId ?? string.Empty; var metaName = a.metaAchievementName ?? string.Empty;
                if (string.IsNullOrWhiteSpace(gid) || string.IsNullOrWhiteSpace(metaName)) continue;
                if (GameLabelById.TryGetValue(gid, out var title))
                {
                    approved.Add(title + "||" + metaName);
                }
            }
            foreach (var r in metaRows)
            {
                r.Approved = approved.Contains(r.game + "||" + r.description);
            }
            // If still empty, log any service error to console once for visibility
            try
            {
                if (metaRows.Count == 0)
                {
                    var err = MetaGames.GetLastError();
                    if (!string.IsNullOrWhiteSpace(err))
                    {
                        await JS.InvokeVoidAsync("console.error", $"CRUD Meta load: {err}");
                    }
                }
            }
            catch { }
        }
        catch { metaRows = new(); }
        finally { isLoadingMeta = false; StateHasChanged(); }
    }

    private async Task OnToggleApprovedAsync(MetaRow r, ChangeEventArgs e)
    {
        bool desired = false;
        if (e?.Value is bool b) desired = b;
        else if (e?.Value != null) { var s = e.Value.ToString(); desired = string.Equals(s, "true", StringComparison.OrdinalIgnoreCase) || string.Equals(s, "on", StringComparison.OrdinalIgnoreCase); }

        await EnsureGamesIndexAsync();
        if (!GameIdByLabel.TryGetValue(r.game, out var gameId) || string.IsNullOrWhiteSpace(gameId))
        {
            try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize($"Game not found for title '{r.game}'.")})"); } catch { }
            return;
        }
        if (desired)
        {
            await UpsertAchievementByLinkAsync(gameId, r.description);
            r.Approved = true;
        }
        else
        {
            await DeleteAchievementByLinkAsync(gameId, r.description);
            r.Approved = false;
        }
        StateHasChanged();
    }

    private async Task UpsertAchievementByLinkAsync(string gameId, string metaName)
    {
        try
        {
            var findJs = @"(async()=>{ try { if (!window.continueDb) return null; await window.continueDb.open(); const arr = await window.continueDb.getAll('achievements'); const gameId = ARGS_gameId; const meta = ARGS_meta; const found = arr.find(a=> (a.gameId||'')===gameId && (a.metaAchievementName||'')===meta); return found? JSON.stringify(found): null; } catch(e){ return null; }})()";
            findJs = findJs.Replace("ARGS_gameId", JsonSerializer.Serialize(gameId)).Replace("ARGS_meta", JsonSerializer.Serialize(metaName));
            var json = await JS.InvokeAsync<string>("eval", findJs);
            string id;
            if (!string.IsNullOrWhiteSpace(json))
            {
                var existing = JsonSerializer.Deserialize<AchievementRow>(json!);
                id = existing?.id ?? SlugifyId($"ach_{gameId}_{metaName}");
            }
            else
            {
                id = SlugifyId($"ach_{gameId}_{metaName}");
            }
            var rec = new { id = id, gameId = gameId, title = metaName, requirements = Array.Empty<string>(), metaAchievementName = metaName };
            var recJson = JsonSerializer.Serialize(rec).Replace("\\", "\\\\").Replace("'", "\\'").Replace("\n","\\n").Replace("\r", "");
            var js = $"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); const rec = JSON.parse('{recJson}'); await window.continueDb.put('achievements', rec); }} catch(e) {{ console.warn('upsert achievement failed', e); }} }})()";
            await JS.InvokeVoidAsync("eval", js);
        }
        catch { }
        await LoadAchievementsAsync();
    }

    private async Task DeleteAchievementByLinkAsync(string gameId, string metaName)
    {
        try
        {
            var findJs = @"(async()=>{ try { if (!window.continueDb) return null; await window.continueDb.open(); const arr = await window.continueDb.getAll('achievements'); const gameId = ARGS_gameId; const meta = ARGS_meta; const found = arr.find(a=> (a.gameId||'')===gameId && (a.metaAchievementName||'')===meta); return found? JSON.stringify(found): null; } catch(e){ return null; }})()";
            findJs = findJs.Replace("ARGS_gameId", JsonSerializer.Serialize(gameId)).Replace("ARGS_meta", JsonSerializer.Serialize(metaName));
            var json = await JS.InvokeAsync<string>("eval", findJs);
            if (!string.IsNullOrWhiteSpace(json))
            {
                var existing = JsonSerializer.Deserialize<AchievementRow>(json!);
                var idSafe = (existing?.id ?? string.Empty).Replace("'", "\\'");
                var delJs = $"(async()=>{{ try {{ if(!window.continueDb) return; await window.continueDb.open(); await window.continueDb.delete('achievements', '{idSafe}'); }} catch(e) {{ console.warn('delete achievement by link failed', e); }} }})()";
                await JS.InvokeVoidAsync("eval", delJs);
            }
        }
        catch { }
        await LoadAchievementsAsync();
    }

    private static string SlugifyId(string s)
    {
        if (string.IsNullOrWhiteSpace(s)) return "ach_empty";
        var sb = new System.Text.StringBuilder(s.Length);
        foreach (var ch in s)
        {
            if (char.IsLetterOrDigit(ch)) sb.Append(char.ToLowerInvariant(ch));
            else if (ch == '_' || ch == '-') sb.Append(ch);
            else sb.Append('_');
        }
        return sb.ToString();
    }

    private async Task TestAllMetaFormulasAsync()
    {
        var prevDebug = Parser.DebugLogging;
        Parser.DebugLogging = true;
        try
        {
            // Ensure we have data loaded
            if (metaRows is null || metaRows.Count == 0)
            {
                await LoadMetaAsync();
            }
            if (metaRows is null || metaRows.Count == 0)
            {
                try { await JS.InvokeVoidAsync("eval", "alert('No meta formulas to test.')"); } catch { }
                return;
            }

            // Load test ROM bytes (from wwwroot/test.nes)
            byte[] romBytes = Array.Empty<byte>();
            try { romBytes = await Http.GetByteArrayAsync("test.nes"); }
            catch { romBytes = Array.Empty<byte>(); }
            if (romBytes == null || romBytes.Length == 0)
            {
                var msg = "test.nes not found or empty in wwwroot. Place a valid ROM at wwwroot/test.nes.";
                try { await JS.InvokeVoidAsync("console.error", msg); } catch { }
                try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize(msg)})"); } catch { }
                return;
            }

            // Reset markers
            foreach (var rr in metaRows) { rr.TestSucceeded = false; rr.TestFailed = false; }
            StateHasChanged();

            int success = 0, failed = 0;
            foreach (var r in metaRows)
            {
                var ok = await EvaluateMetaRowAsync(r, romBytes);
                if (ok) success++; else failed++;
                StateHasChanged();
            }

            try { await JS.InvokeVoidAsync("console.log", $"Meta test summary: {success} succeeded, {failed} failed."); } catch { }
            try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize($"Meta tests done: {success} passed, {failed} failed.")})"); } catch { }
        }
        catch (Exception ex)
        {
            var msg = $"Unexpected error during meta formula test: {ex.Message}";
            try { await JS.InvokeVoidAsync("console.error", msg); } catch { }
            try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize("Parsing failed:\n" + msg)})"); } catch { }
        }
        finally
        {
            Parser.DebugLogging = prevDebug;
        }
    }

    private async Task<bool> EvaluateMetaRowAsync(MetaRow r, byte[] romBytes)
    {
        try
        {
            r.TestSucceeded = false; r.TestFailed = false;
            var formula = r.formula ?? string.Empty;
            if (string.IsNullOrWhiteSpace(formula)) { r.TestFailed = true; return false; }

            var lines = formula.Replace("\r\n", "\n").Replace("\r", "\n").Split('\n');
            bool allOk = true;
            foreach (var raw in lines)
            {
                var line = raw?.Trim();
                if (string.IsNullOrWhiteSpace(line)) continue;
                try { _ = Parser.ParseConditions(line); }
                catch (Exception ex)
                {
                    try { await JS.InvokeVoidAsync("console.error", $"Parse failed for '{r.description}': {ex.Message}"); } catch { }
                    allOk = false; continue;
                }

                // Fresh NES per line to avoid state drift
                var nes = new NES();
                try { nes.RomName = "test.nes"; nes.LoadROM(romBytes); }
                catch (Exception ex)
                {
                    try { await JS.InvokeVoidAsync("console.error", $"LoadROM failed: {ex.Message}"); } catch { }
                    allOk = false; continue;
                }

                AchievementsTester.TestPlan plan;
                try { plan = AchievementsTester.BuildPlan(line); }
                catch (Exception ex)
                {
                    try { await JS.InvokeVoidAsync("console.error", $"Plan build failed for '{r.description}': {ex.Message}"); } catch { }
                    allOk = false; continue;
                }

                var engine = new AchievementsEngine(new NesRamDomain(nes));
                const string tempId = "meta_temp";
                engine.Load(new[] { (tempId, line) });
                // Seed frames
                nes.RunFrame(); _ = engine.EvaluateFrame();
                nes.RunFrame(); var unlockedNow = engine.EvaluateFrame();
                if (unlockedNow.Contains(tempId))
                {
                    // Already unlocked before executing plan counts as failure for verification
                    allOk = false; continue;
                }

                bool ok;
                try { ok = AchievementsTester.ExecutePlan(nes, plan, engine, tempId); }
                catch (Exception ex)
                {
                    try { await JS.InvokeVoidAsync("console.error", $"ExecutePlan failed for '{r.description}': {ex.Message}"); } catch { }
                    allOk = false; continue;
                }
                if (!ok)
                {
                    nes.RunFrame(); var post = engine.EvaluateFrame();
                    ok = post.Contains(tempId) || (engine.Get(tempId)?.Unlocked == true);
                }
                if (!ok) allOk = false;
            }

            r.TestSucceeded = allOk; r.TestFailed = !allOk;
            return allOk;
        }
        catch
        {
            r.TestSucceeded = false; r.TestFailed = true; return false;
        }
    }

    private async Task TestSingleMetaFormulaAsync(MetaRow r)
    {
        var prevDebug = Parser.DebugLogging;
        Parser.DebugLogging = true;
        try
        {
            byte[] romBytes = Array.Empty<byte>();
            try { romBytes = await Http.GetByteArrayAsync("test.nes"); } catch { }
            if (romBytes == null || romBytes.Length == 0)
            {
                var msg = "test.nes not found or empty in wwwroot. Place a valid ROM at wwwroot/test.nes.";
                try { await JS.InvokeVoidAsync("console.error", msg); } catch { }
                try { await JS.InvokeVoidAsync("eval", $"alert({JsonSerializer.Serialize(msg)})"); } catch { }
                return;
            }
            await EvaluateMetaRowAsync(r, romBytes);
            StateHasChanged();
        }
        finally
        {
            Parser.DebugLogging = prevDebug;
        }
    }

    private async Task OnMetaFilterChanged(ChangeEventArgs e)
    {
        metaFilterTitle = e.Value?.ToString() ?? string.Empty;
        await LoadMetaAsync();
    }

    private class ColumnVisibility
    {
    public bool Id { get; set; } = false;
    public bool CommonName { get; set; } = true;
    public bool Status { get; set; } = true;
        public bool Note { get; set; } = false;
        public bool System { get; set; } = false;
        public bool BuiltIn { get; set; } = true;
        public bool Size { get; set; } = false;
    }

    // Wrapper properties to intercept changes and persist to localStorage
    private bool ColSystem
    {
        get => cols.System;
        set { cols.System = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColId
    {
        get => cols.Id;
        set { cols.Id = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColCommonName
    {
        get => cols.CommonName;
        set { cols.CommonName = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColStatus
    {
        get => cols.Status;
        set { cols.Status = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColNote
    {
        get => cols.Note;
        set { cols.Note = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColBuiltIn
    {
        get => cols.BuiltIn;
        set { cols.BuiltIn = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    private bool ColSize
    {
        get => cols.Size;
        set { cols.Size = value; _ = SaveColumnsAsync(); StateHasChanged(); }
    }
    
}
